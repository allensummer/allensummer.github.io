<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WMind Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-14T00:47:15.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Allen Wolf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是机器学习</title>
    <link href="http://yoursite.com/2016/08/01/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/08/01/什么是机器学习/</id>
    <published>2016-08-01T00:00:00.000Z</published>
    <updated>2016-04-14T00:47:15.518Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　在介绍机器学习之前，我想先列几个关于机器学习的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾邮件检测：根据邮箱中的邮件，识别哪些是垃圾邮件，哪些不是。这样的模型，可以程序帮助归类垃圾邮件和非垃圾邮件。这个例子，我们应该都不陌生。&lt;/li&gt;
&lt;li&gt;信用卡欺诈检测：根据用户一个月内的信用卡交易，识别哪些交易是该用户操作的，哪些不是。这样的决策模型，可以帮助程序退还那些欺诈交易。&lt;/li&gt;
&lt;li&gt;数字识别：根据信封上手写的邮编，识别出每一个手写字符所代表的数字。这样的模型，可以帮助程序阅读和理解手写邮编，并根据地利位置分类信件。&lt;/li&gt;
&lt;li&gt;语音识别：从一个用户的话语，确定用户提出的具体要求。这样的模型，可以帮助程序能够并尝试自动填充用户需求。带有Siri系统的iPhone就有这种功能。&lt;/li&gt;
&lt;li&gt;人脸识别：根据相册中的众多数码照片，识别出那些包含某一个人的照片。这样的决策模型，可以帮助程序根据人脸管理照片。某些相机或软件，如iPhoto，就有这种功能。&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7cc829d3gw1eebxsvbwnhj20hc0d2jt6.jpg&quot; alt=&quot;人脸识别&quot;&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;产品推荐：根据一个用户的购物记录和冗长的收藏清单，识别出这其中哪些是该用户真正感兴趣，并且愿意购买的产品。这样的决策模型，可以帮助程序为客户提供建议并鼓励产品消费。登录Facebook或GooglePlus，它们就会推荐可能有关联的用户给你。&lt;/li&gt;
&lt;li&gt;医学分析：根据病人的症状和一个匿名的病人资料数据库，预测该病人可能患了什么病。这样的决策模型，可以程序为专业医疗人士提供支持。&lt;/li&gt;
&lt;li&gt;股票交易：根据一支股票现有的和以往的价格波动，判断这支股票是该建仓、持仓还是减仓。这样的决策模型，可以帮助程序为金融分析提供支持。&lt;/li&gt;
&lt;li&gt;客户细分：根据用户在试用期的的行为模式和所有用户过去的行为，识别出哪些用户会转变成该产品的付款用户，哪些不会。这样的决策模型，可以帮助程序进行用户干预，以说服用户早些付款使用或更好的参与产品试用。&lt;/li&gt;
&lt;li&gt;形状鉴定：根据用户在触摸屏幕上的手绘和一个已知的形状资料库，判断用户想描绘的形状。这样的决策模型，可以帮助程序显示该形状的理想版本，以绘制清晰的图像。iPhone应用Instaviz就能做到这样。[1]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;机器学习(Machine Learning, ML)&lt;/strong&gt;是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，主要使用&lt;strong&gt;归纳、综合而不是演绎&lt;/strong&gt;[2]&lt;/p&gt;
&lt;p&gt;关于机器学习的定义有很多，一种经常被引用的英文定义是：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.[3]&lt;/p&gt;
&lt;p&gt;上面的这个定义如何理解呢？想象一下有一个邮箱过滤程序接受到一封邮件，该程序如何判断这封邮件是不是垃圾邮件呢？首先这封邮件先观察你之前标记过是不是垃圾邮件的邮件，基于这个学习到的经验，该过滤程序为你过滤掉垃圾邮件了。在这个任务中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断邮件是不是垃圾邮件,这个&lt;strong&gt;任务T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;观察到你之前标记过是不是垃圾邮件的邮件，这个是&lt;strong&gt;经验E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正确分类垃圾邮件与非垃圾邮件的数量，这个是&lt;strong&gt;性能P&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2012/0515/151727_DtZB_260935.jpg&quot; alt=&quot;163邮箱&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;机器学习分类&quot;&gt;&lt;a href=&quot;#机器学习分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习分类&quot;&gt;&lt;/a&gt;机器学习分类&lt;/h1&gt;&lt;p&gt;从最广义的讲，任何涉及机器学习所用的方法，只要它利用了训练样本的信息，都可以认为运用了学习。实践中和有意义的机器学习都是如此困难，以至于根本无法实现猜测出一个最佳的分类判决。因此大部分的时间都运用与研究学习问题。实现一个机器学习算法设计：给定一般的模型或分类器的形式，利用训练样本去学习或评估模型的未知参数。这里的学习指用某种算法来降低训练样本的分类误差。一大类基于梯度下降的算法，能够调节分类器的参数，使它朝着能够降低误差的方向前进，目前已成为机器学习领域的主流学习算法。[4]&lt;br&gt;在一个机器学习的应用中，根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。[5]&lt;/p&gt;
&lt;h2 id=&quot;监督式学习&quot;&gt;&lt;a href=&quot;#监督式学习&quot; class=&quot;headerlink&quot; title=&quot;监督式学习&quot;&gt;&lt;/a&gt;监督式学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/7cc829d3gw1ekoj9ozt1xj208c06nq31.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常见的算法有：逻辑回归，感知机，SVM支持向量机。&lt;/p&gt;
&lt;h2 id=&quot;非监督学习&quot;&gt;&lt;a href=&quot;#非监督学习&quot; class=&quot;headerlink&quot; title=&quot;非监督学习&quot;&gt;&lt;/a&gt;非监督学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7cc829d3gw1ekoj9pp0wxj208c069mxc.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括：Apriori算法以及k-Means算法。&lt;/p&gt;
&lt;h2 id=&quot;半监督学习&quot;&gt;&lt;a href=&quot;#半监督学习&quot; class=&quot;headerlink&quot; title=&quot;半监督学习&quot;&gt;&lt;/a&gt;半监督学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/7cc829d3gw1ekoj9qcia3j208c05kq3b.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。&lt;/p&gt;
&lt;h2 id=&quot;强化学习&quot;&gt;&lt;a href=&quot;#强化学习&quot; class=&quot;headerlink&quot; title=&quot;强化学习&quot;&gt;&lt;/a&gt;强化学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7cc829d3gw1ekoj9r0xldj208c04wgls.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）&lt;/p&gt;
&lt;h1 id=&quot;机器学习框架&quot;&gt;&lt;a href=&quot;#机器学习框架&quot; class=&quot;headerlink&quot; title=&quot;机器学习框架&quot;&gt;&lt;/a&gt;机器学习框架&lt;/h1&gt;&lt;p&gt;在机器学习领域有很&lt;a href=&quot;http://&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;多的框架、库以及软件。比较出名的有：C++的opencv, shark等，java中weka、hadoop的mahout、spark的mllib，matlab中的LibSVM、caffe，python的scikit-learn、NLTK、theano、brain、caffe等。&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习框架、库与软件列表&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;目录（持续更新）&quot;&gt;&lt;a href=&quot;#目录（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;目录（持续更新）&quot;&gt;&lt;/a&gt;目录（持续更新）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基础知识  &lt;!--* 概率论
  * 模型评估与选择
  * 维灾难
  * 决策论
  * 信息论--&gt;&lt;/li&gt;
&lt;li&gt;概率分布  &lt;!--* 二项式分布
  * 多项式分布
  * 高斯分布
  * 指数分布族
  * 非常数分布--&gt;&lt;/li&gt;
&lt;li&gt;回归&lt;ul&gt;
&lt;li&gt;CART：分类和回归树算法&lt;/li&gt;
&lt;li&gt;SVR支持向量回归&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/earl211/article/details/48974865&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;感知机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;逻辑回归&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/08/逻辑斯蒂（Logistic-回归/#more&quot;&gt;逻辑回归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/09/logistic实现/&quot;&gt;逻辑回归实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/09/scikit-learn中的逻辑回归/&quot;&gt;scikit-learn中的逻辑回归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分类决策数算法C4.5&lt;/li&gt;
&lt;li&gt;最近邻分类&lt;/li&gt;
&lt;li&gt;朴素贝叶斯算法&lt;/li&gt;
&lt;li&gt;CART：分类和回归树算法&lt;/li&gt;
&lt;li&gt;Ada Boost迭代算法&lt;/li&gt;
&lt;li&gt;支持向量机&lt;/li&gt;
&lt;li&gt;图模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聚类&lt;ul&gt;
&lt;li&gt;k均值聚类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间序列&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/03/29/test/&quot;&gt;时间序列完全教程（R）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HMM隐马尔科夫模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降维&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/08/LDA浅显理解/&quot;&gt;LDA浅显理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他算法&lt;ul&gt;
&lt;li&gt;最大期望（EM）算法&lt;/li&gt;
&lt;li&gt;Apriori算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最优化算法&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/14/挑战程序设计竞赛-抽签/&quot;&gt;梯度下降法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#参考资料&lt;br&gt;[1] &lt;a href=&quot;http://blog.jobbole.com/62334&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习十个实例&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://baike.baidu.com/link?url=yeJM3HqBaKfzroNnRkaFt2Uya85p822Ct2Ke6DSQQtono8-JJdfB9iBiiz3uc35WfwuN5vT2FwQgFga4eP6onq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度百科&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;https://www.coursera.org/learn/machine-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习&lt;/a&gt;&lt;br&gt;[4] 模式分类&lt;br&gt;[5] &lt;a href=&quot;http://blog.jobbole.com/77620/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习常见分类&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　在介绍机器学习之前，我想先列几个关于机器学习的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾邮件检测：根据邮箱中的邮件，识别哪些是垃圾邮件，哪些不是。这样的模型，可以程序帮助归类垃圾邮件和非垃圾邮件。这个例子，我们应该都不陌生。&lt;/li&gt;
&lt;li&gt;信用卡欺诈检测：根据用户一个月内的信用卡交易，识别哪些交易是该用户操作的，哪些不是。这样的决策模型，可以帮助程序退还那些欺诈交易。&lt;/li&gt;
&lt;li&gt;数字识别：根据信封上手写的邮编，识别出每一个手写字符所代表的数字。这样的模型，可以帮助程序阅读和理解手写邮编，并根据地利位置分类信件。&lt;/li&gt;
&lt;li&gt;语音识别：从一个用户的话语，确定用户提出的具体要求。这样的模型，可以帮助程序能够并尝试自动填充用户需求。带有Siri系统的iPhone就有这种功能。&lt;/li&gt;
&lt;li&gt;人脸识别：根据相册中的众多数码照片，识别出那些包含某一个人的照片。这样的决策模型，可以帮助程序根据人脸管理照片。某些相机或软件，如iPhoto，就有这种功能。&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7cc829d3gw1eebxsvbwnhj20hc0d2jt6.jpg&quot; alt=&quot;人脸识别&quot;&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>POJ-2386 Lake Counting 挑战程序设计竞赛</title>
    <link href="http://yoursite.com/2016/04/15/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/"/>
    <id>http://yoursite.com/2016/04/15/深度优先/</id>
    <published>2016-04-14T23:39:12.000Z</published>
    <updated>2016-04-14T23:45:04.683Z</updated>
    
    <content type="html">&lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &amp;lt;= N &amp;lt;= 100; 1 &amp;lt;= M &amp;lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. &lt;/p&gt;
&lt;p&gt;Given a diagram of Farmer John’s field, determine how many ponds he has.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h1&gt;&lt;p&gt;深度优先查找,查找相邻的W块有多少个&lt;/p&gt;
&lt;h1 id=&quot;代码：&quot;&gt;&lt;a href=&quot;#代码：&quot; class=&quot;headerlink&quot; title=&quot;代码：&quot;&gt;&lt;/a&gt;代码：&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX_N 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N, M;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; field[MAX_N][MAX_N+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//现在位置（x, y)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    field[x][y] = &lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nx, ny;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//循环遍历8个方向&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;; j &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nx = x + i; ny = y + j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nx &amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nx &amp;lt; N &amp;amp;&amp;amp; ny &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ny &amp;lt;= M &amp;amp;&amp;amp; field[nx][ny] == &lt;span class=&quot;string&quot;&gt;&#39;W&#39;&lt;/span&gt;) dfs(nx, ny);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; M ; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(field[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;W&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dfs(i, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, res);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;, &amp;amp;N, &amp;amp;M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; N;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//  scanf(&quot;%c &quot;, &amp;amp;field[i][j]);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt; &amp;gt;&amp;gt; field[i][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; N;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%c &quot;&lt;/span&gt;, field[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    solve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &amp;lt;= N &amp;lt;= 100; 1 &amp;lt;= M &amp;lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. &lt;/p&gt;
&lt;p&gt;Given a diagram of Farmer John’s field, determine how many ponds he has.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="挑战程序设计" scheme="http://yoursite.com/tags/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>抽签 挑战程序设计竞赛</title>
    <link href="http://yoursite.com/2016/04/14/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%8A%BD%E7%AD%BE/"/>
    <id>http://yoursite.com/2016/04/14/挑战程序设计竞赛-抽签/</id>
    <published>2016-04-13T23:08:33.000Z</published>
    <updated>2016-04-14T00:45:44.014Z</updated>
    
    <content type="html">&lt;p&gt;问题：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/74311666jw1f2vv43yt30j20ow09nq4c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;如果是我，我肯定最开始想到的是暴力破解，然而时间复杂度太高了，数据量小还好，如果数据量太大，时间会疯涨。&lt;br&gt;书中给了一个思路:将数组内相加等于某个值，转换为查找这个值减去数组内的一个或两个变量，这样就将问题转换为查找问题了，可以使用二分查找。这里再回顾一下查找算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序查找（时间复杂度O(n))&lt;/li&gt;
&lt;li&gt;折半查找(时间复杂度O(log(n)))&lt;/li&gt;
&lt;li&gt;B树又称二叉查找&lt;/li&gt;
&lt;li&gt;B+树&lt;/li&gt;
&lt;li&gt;散列表（如果散列表构建的好，时间复杂度会是O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里使用折半查找，折半查找需要将数组排好序，排序算法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部排序（使用内存）&lt;ul&gt;
&lt;li&gt;插入排序&lt;ul&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择排序&lt;ul&gt;
&lt;li&gt;简单选择排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换排序&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部排序（内存和外存结合使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;将问题转换为查找number[k]=m-number[i]-number[j]&lt;br&gt;时间复杂度$O(n^{2}log(n))&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myfunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (i &amp;lt; j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; number)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::sort(number.begin(), number.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; f = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; n; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//                std::cout &amp;lt;&amp;lt;m - number[i]-number[j]&amp;lt;&amp;lt;&quot;search&quot; &amp;lt;&amp;lt; number[k]&amp;lt;&amp;lt;std::endl;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::binary_search(number.begin(), number.end(),m-number[i]-number[j]-number[k], myfunction))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    f = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f) &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Yes&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;No&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, m, buf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k.push_back(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    solve(n, m, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法二：&lt;br&gt;将问题转换为查找number[i]+number[j] = m - number[k]&lt;br&gt;时间复杂度$O(n_{2}log(n))&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myfunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (i &amp;lt; j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; number)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; number2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt; n; j ++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                number2.push_back(number[i] + number[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::sort(number2.begin(), number2.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; f = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//                std::cout &amp;lt;&amp;lt;m - number[i]-number[j]&amp;lt;&amp;lt;&quot;search&quot; &amp;lt;&amp;lt; number[k]&amp;lt;&amp;lt;std::endl;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::binary_search(number.begin(), number.end(),m-number[i]-number[j], myfunction))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    f = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f) &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Yes&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;No&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, m, buf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k.push_back(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    solve(n, m, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;问题：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/74311666jw1f2vv43yt30j20ow09nq4c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="挑战程序设计" scheme="http://yoursite.com/tags/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降法</title>
    <link href="http://yoursite.com/2016/04/13/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/13/梯度下降法/</id>
    <published>2016-04-13T11:56:19.000Z</published>
    <updated>2016-04-13T14:01:17.340Z</updated>
    
    <content type="html">&lt;p&gt;梯度下降法主要应用与找到最小值，是求解&lt;strong&gt;无约束最优化&lt;/strong&gt;问题的一种最常用的方法。这里求解的是凸优化问题，如果不是凸优化，那么使用梯度下降法只能找到局部最优解。&lt;br&gt;举一个例子，假设你正在山坡上，也就是开始的点上面，你&lt;strong&gt;只能看到周围1mm&lt;/strong&gt;的地方，你想要最快到达最低点，你怎么办？正常人应该会想，从周围1mm范围内最低的点走，肯定会走越低的。有人说，如果地上有一个坑，那就一直在坑里吗？这个问题…就是非凸优化的问题啦，不较真不较真啦。&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/031bc97949ed0128.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;随机梯度下降法&quot;&gt;&lt;a href=&quot;#随机梯度下降法&quot; class=&quot;headerlink&quot; title=&quot;随机梯度下降法&quot;&gt;&lt;/a&gt;随机梯度下降法&lt;/h1&gt;&lt;p&gt;用公式表达上面的问题就是：&lt;br&gt;$$min_{a\in R^{n}}J(a)$$&lt;br&gt;这里J(a)是目标函数&lt;br&gt;梯度家奖罚是一种迭代算法，选取适当的初值，不断迭代，更新x的值，进行目标函数的极小化，直到收敛。即：&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/0c36a0aa4382c920.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;关键问题：如何设计步长&lt;img src=&quot;http://i2.piimg.com/d5bea32b6683285a.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果选的太小，则算法收敛慢，如果步长太大，容易导致发散。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法 梯度下降法&lt;/strong&gt;&lt;br&gt;输入：目标函数J(a), 梯度函数$s = \nabla J(x)$,计算精度$\varepsilon$;&lt;br&gt;输出：$F(x)$的极小值$x^{*}$&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/c168b315202bf4e4.png&quot; alt=&quot;Drawing&quot; width=&quot;400px&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里面的初始点选择也会导致局部最优，而不是全局最优点。如图：&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/031bc97949ed0128.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果你初始点选择载右边那个高峰，有可能到达右边的低谷中。解决这个问题的思路，可以在迭代过程中加入模拟退火或遗传算法的思想进去。&lt;/p&gt;
&lt;h1 id=&quot;梯度下降法的集中变形形式&quot;&gt;&lt;a href=&quot;#梯度下降法的集中变形形式&quot; class=&quot;headerlink&quot; title=&quot;梯度下降法的集中变形形式&quot;&gt;&lt;/a&gt;梯度下降法的集中变形形式&lt;/h1&gt;&lt;p&gt;在具体使用梯度下降法的过程中，主要有以下几种不同的变种，即：batch、mini-batch、SGD和online。其主要区别是不同的变形在训练数据的选择上。&lt;/p&gt;
&lt;h2 id=&quot;batch-gradient-descent&quot;&gt;&lt;a href=&quot;#batch-gradient-descent&quot; class=&quot;headerlink&quot; title=&quot;batch gradient descent&quot;&gt;&lt;/a&gt;batch gradient descent&lt;/h2&gt;&lt;p&gt;批梯度下降法(Batch Gradient Descent)针对的是整个数据集，通过对所有的样本的计算来求解梯度的方向。&lt;/p&gt;
&lt;p&gt;批梯度下降法的损失函数为：&lt;/p&gt;
&lt;p&gt;(θ)=12m∑(h(x)−y)&lt;br&gt;针对上述的损失函数，在批梯度的优化过程中，对每一个样本都需要计算其梯度，批梯度的优化过程为：&lt;/p&gt;
&lt;p&gt;repeate{θ:=θ−α1m∑(h(x)−y)x}&lt;/p&gt;
&lt;h2 id=&quot;mini-batch-gradient-descent&quot;&gt;&lt;a href=&quot;#mini-batch-gradient-descent&quot; class=&quot;headerlink&quot; title=&quot;mini-batch gradient descent&quot;&gt;&lt;/a&gt;mini-batch gradient descent&lt;/h2&gt;&lt;p&gt;在上述的批梯度的方式中每次迭代都要使用到所有的样本，对于数据量特别大的情况，如大规模的机器学习应用，每次迭代求解所有样本需要花费大量的计算成本。是否可以在每次的迭代过程中利用部分样本代替所有的样本呢？基于这样的思想，便出现了mini-batch的概念。&lt;br&gt;假设训练集中的样本的个数为，则每个mini-batch只是其一个子集，假设，每个mini-batch中含有个样本，这样，整个训练数据集可以分为个mini-batch。&lt;/p&gt;
&lt;p&gt;{foreachωinΩ:θ:=θ−α1b∑(h(x)−y)x}for(k=1,2…m/b)&lt;/p&gt;
&lt;h2 id=&quot;stochastic-gradient-descent&quot;&gt;&lt;a href=&quot;#stochastic-gradient-descent&quot; class=&quot;headerlink&quot; title=&quot;stochastic gradient descent&quot;&gt;&lt;/a&gt;stochastic gradient descent&lt;/h2&gt;&lt;p&gt;随机梯度下降算法(stochastic gradient descent)可以看成是mini-batch gradient descent的一个特殊的情形，即在随机梯度下降法中每次仅根据一个样本对模型中的参数进行调整，等价于上述的b=1情况下的mini-batch gradient descent，即每个mini-batch中只有一个训练样本。&lt;br&gt;随机梯度下降法的优化过程为： &lt;/p&gt;
&lt;p&gt;{foreachx:θ:=θ−α(h(x)−y)x}&lt;/p&gt;
&lt;h2 id=&quot;online-gradient-descent&quot;&gt;&lt;a href=&quot;#online-gradient-descent&quot; class=&quot;headerlink&quot; title=&quot;online gradient descent&quot;&gt;&lt;/a&gt;online gradient descent&lt;/h2&gt;&lt;p&gt;对于互联网上的应用来说，数据的获取变得实时，例如推荐中，系统希望能够根据用户的实时的信息对模型进行调整，这样就产生了在线学习，在线学习(Online Learning)算法就是充分利用实时数据的一个训练算法。&lt;/p&gt;
&lt;p&gt;在线梯度下降法(Online gradient descent)对于所有训练数据只用一次，然后丢弃。每次根据实时的数据计算梯度，进而调整模型中的参数。&lt;/p&gt;
&lt;h1 id=&quot;python实现&quot;&gt;&lt;a href=&quot;#python实现&quot; class=&quot;headerlink&quot; title=&quot;python实现&quot;&gt;&lt;/a&gt;python实现&lt;/h1&gt;&lt;p&gt;下面代码是逻辑回归中的随机梯度下降法的代码，具体请见&lt;a href=&quot;http://localhost:4000/2016/04/09/logistic%E5%AE%9E%E7%8E%B0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逻辑回归&lt;/a&gt;&lt;br&gt;```python&lt;/p&gt;
&lt;p&gt;def SGD(self, dataMatrix, classLabels, alpha， function):&lt;br&gt;    ‘’’根据训练数据拟合模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参数
------------
dataMatrix:
    训练样本属性矩阵
    类型：array
classLabels：
    训练样本标签
    类型：list
alpha:
    步长
function:
    目标函数的一阶导

&amp;apos;&amp;apos;&amp;apos;
row,col = dataMatrix.shape
weights = ones(col)   #初始化权值矩阵2
diff = weights
j = 0 #迭代次数
while(abs(max(diff))&amp;gt;0.01):
    dataIndex = range(row)
    for i in range(row):
        randIndex = int(random.uniform(0,len(dataIndex)))#随机选取训练对象
        h = function(sum(dataMatrix[randIndex]*weights))#矩阵
        error = classLabels[randIndex] - h

        diff = weights
        weights = weights + alpha * error * dataMatrix[randIndex]
        diff = weights - diff
        j += 1
        del(dataIndex[randIndex])
self.weights = weights
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;梯度下降法主要应用与找到最小值，是求解&lt;strong&gt;无约束最优化&lt;/strong&gt;问题的一种最常用的方法。这里求解的是凸优化问题，如果不是凸优化，那么使用梯度下降法只能找到局部最优解。&lt;br&gt;举一个例子，假设你正在山坡上，也就是开始的点上面，你&lt;strong&gt;只能看到周围1mm&lt;/strong&gt;的地方，你想要最快到达最低点，你怎么办？正常人应该会想，从周围1mm范围内最低的点走，肯定会走越低的。有人说，如果地上有一个坑，那就一直在坑里吗？这个问题…就是非凸优化的问题啦，不较真不较真啦。&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/031bc97949ed0128.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="梯度下降" scheme="http://yoursite.com/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
      <category term="凸优化问题" scheme="http://yoursite.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1852 Ants 挑战程序设计竞赛</title>
    <link href="http://yoursite.com/2016/04/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93POJ-1852-Ants/"/>
    <id>http://yoursite.com/2016/04/13/每天一道POJ-1852-Ants/</id>
    <published>2016-04-12T22:54:37.000Z</published>
    <updated>2016-04-13T22:08:01.391Z</updated>
    
    <content type="html">&lt;p&gt;Ants:Lcm长的杆子上有n只蚂蚁，蚂蚁以1cm的速度向左或者向右爬行，碰见就转向，知道每只蚂蚁距离杆子左端的距离x，不知道当前方向，计算所有蚂蚁落下竿子所需要的最短时间和最长时间。&lt;/p&gt;
&lt;p&gt;首先想到的是穷举法，枚举所有蚂蚁的初始朝向组合，可以利用递归实现，但是复杂度太高。观察这题，蚂蚁相遇会变成什么样子？如果1号蚂蚁跟2号蚂蚁碰到了，转向爬行，不纠结具体哪只蚂蚁，知道两只蚂蚁类似于交错爬行。每只蚂蚁都是独立运动的，所以每只蚂蚁都是独立运动，所以要求最长时间，只要求蚂蚁到竿子端点的最大距离就好了。&lt;br&gt;换个角度，发现整个世界都变了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; Max(a, b) a&amp;gt;b?a:b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; Min(a, b) a&amp;lt;b?a:b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; T, m, n, k, minT=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, maxT=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//T多少输入，m杠子长度，n蚂蚁个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;T);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(T--)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;                                                                       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;, &amp;amp;m, &amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;n--;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, &amp;amp;k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minT = Min(minT, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxT = Max(maxT, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;, minT, maxT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Ants:Lcm长的杆子上有n只蚂蚁，蚂蚁以1cm的速度向左或者向右爬行，碰见就转向，知道每只蚂蚁距离杆子左端的距离x，不知道当前方向，计算所有蚂蚁落下竿子所需要的最短时间和最长时间。&lt;/p&gt;
&lt;p&gt;首先想到的是穷举法，枚举所有蚂蚁的初始朝向组合，可以利用递归实现，但是复杂度太高。观察这题，蚂蚁相遇会变成什么样子？如果1号蚂蚁跟2号蚂蚁碰到了，转向爬行，不纠结具体哪只蚂蚁，知道两只蚂蚁类似于交错爬行。每只蚂蚁都是独立运动的，所以每只蚂蚁都是独立运动，所以要求最长时间，只要求蚂蚁到竿子端点的最大距离就好了。&lt;br&gt;换个角度，发现整个世界都变了。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="挑战程序设计" scheme="http://yoursite.com/tags/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>python&amp;R机器学习速查表</title>
    <link href="http://yoursite.com/2016/04/12/python-R%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2016/04/12/python-R机器学习速查表/</id>
    <published>2016-04-11T23:25:29.000Z</published>
    <updated>2016-04-12T23:47:27.946Z</updated>
    
    <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://www.analyticsvidhya.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.analyticsvidhya.com/&lt;/a&gt;&lt;br&gt;我个人对机器学习特别感兴趣，让机器能够自动的学习经验，听起来就特别的有意思，R我并不常用，我用的最多的还是python中的scikit-learn的库，但是这两个都是机器学习、数据挖掘中十分常用的东西。&lt;br&gt;下面这些速查表能让更多的人成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/09/1.jpg?w=1017&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://www.analyticsvidhya.com/&quot;&gt;http://www.analyticsvidhya.com/&lt;/a&gt;&lt;br&gt;我个人对机器学习特别感兴趣，让机器能够自动的学习经验，听起来就特别的有意思，R我并不常用，我用的最多的还是python中的scikit-learn的库，但是这两个都是机器学习、数据挖掘中十分常用的东西。&lt;br&gt;下面这些速查表能让更多的人成为机器学习的支持者。这是10个最常用的机器学习算法，这些算法使用了Python和R代码。考虑到机器学习在构建模型中的应用，这些速查表可以很好作为编码指南帮助你学好这些机器学习算法。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图像分割综述</title>
    <link href="http://yoursite.com/2016/04/11/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    <id>http://yoursite.com/2016/04/11/图像分割/</id>
    <published>2016-04-11T05:19:34.000Z</published>
    <updated>2016-04-13T08:33:36.420Z</updated>
    
    <content type="html">&lt;p&gt;图像分割是什么东西？根据字面意思就是将图像中的某块区域分割出来。至于分割测程度可做什么样子的分割则要取决于问题，如何做分割则需要取决于图像的灰度、位置信息、边（线，曲线等）、颜色、纹理和形状等特征把图像划分成若干互不交迭的区域。更精确的说，图像分割就是将每一个像素点贴上标签，而相同标签的像素点具有共同的特征。这里先对图像分割方法做一个总体的介绍，后面再对某些算法做具体的学习和了解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;p&gt;以下是图像分割的具体应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器视觉&lt;/li&gt;
&lt;li&gt;医学图像&lt;ul&gt;
&lt;li&gt;定位肿瘤或者其他异常&lt;/li&gt;
&lt;li&gt;测量组织体积&lt;/li&gt;
&lt;li&gt;诊断解剖学上的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物体检测&lt;/li&gt;
&lt;li&gt;识别任务&lt;/li&gt;
&lt;li&gt;交通控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面列出图像分割中的主流的算法和技术.如果想要更好的解决领域分割的问题，都必须要结合一定的领域知识。&lt;/p&gt;
&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;基于阈值的方法&quot;&gt;&lt;a href=&quot;#基于阈值的方法&quot; class=&quot;headerlink&quot; title=&quot;基于阈值的方法&quot;&gt;&lt;/a&gt;基于阈值的方法&lt;/h2&gt;&lt;p&gt;　　阈值法的基本思想是基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中每个像素的灰度值与阈值相比较，最后将像素根据比较结果分到合适的类别中。最近CT图像中阈值法有不错的发展。这个方法最关键的地方在于选取阈值（或者多个阈值）。通用的方法包括：最大熵方法，Otsu’s方法，或者k均值聚类，会受到到光照个应用的影响。&lt;/p&gt;
&lt;h2 id=&quot;基于聚类的方法&quot;&gt;&lt;a href=&quot;#基于聚类的方法&quot; class=&quot;headerlink&quot; title=&quot;基于聚类的方法&quot;&gt;&lt;/a&gt;基于聚类的方法&lt;/h2&gt;&lt;p&gt;  基于k均值算法是一种迭代方法，将一幅图划分成k个聚类。思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选取k个中心&lt;/li&gt;
&lt;li&gt;将每个像素点划分到最近的中心点&lt;/li&gt;
&lt;li&gt;重新计算每一类的中心，重新进行第二步&lt;/li&gt;
&lt;li&gt;重复2-3次知道收敛&lt;br&gt;聚这个方法在于选取聚类中心和类的个数。[2]&lt;br&gt;还有一种是基于双分类的方法，利用像素点的三个特征：位置和亮度变化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;基于直方图的方法&quot;&gt;&lt;a href=&quot;#基于直方图的方法&quot; class=&quot;headerlink&quot; title=&quot;基于直方图的方法&quot;&gt;&lt;/a&gt;基于直方图的方法&lt;/h2&gt;&lt;p&gt;　　所谓的直方图，就是计算一幅图的所有像素点的直方图，找到直方图中的峰和谷来确定图像中的簇。有一个改进就是递归求图像中的集群，可以分成更小的簇。基于直方图的方法能够很好的适应与多帧的情况，此方法可以对静态环境中的活动的对象的分割，进行视频跟踪。&lt;/p&gt;
&lt;h2 id=&quot;基于边检测的方法&quot;&gt;&lt;a href=&quot;#基于边检测的方法&quot; class=&quot;headerlink&quot; title=&quot;基于边检测的方法&quot;&gt;&lt;/a&gt;基于边检测的方法&lt;/h2&gt;&lt;p&gt;　　所谓边缘是指图像中两个不同区域的边界线上连续的像素点的集合，是图像局部特征不连续性的反映，体现了灰度、颜色、纹理等图像特性的突变。通常情况下，基于边缘的分割方法指的是基于灰度值的边缘检测，它是建立在边缘灰度值会呈现出阶跃型或屋顶型变化这一观测基础上的方法。&lt;br&gt;    该方法是基于不同区域边界的一个强烈强度、颜色、亮度等的一个挑战。边缘检测是其他分割方法的基础。&lt;/p&gt;
&lt;h2 id=&quot;基于区域的方法&quot;&gt;&lt;a href=&quot;#基于区域的方法&quot; class=&quot;headerlink&quot; title=&quot;基于区域的方法&quot;&gt;&lt;/a&gt;基于区域的方法&lt;/h2&gt;&lt;p&gt; 　　基于区域的方法的核心猜想就是一个区域的相邻像素具有相同的值。最常用的方法就是比较一个像素点与周围像素点。&lt;br&gt; 　　一种区域增长法是种子区域生长法。这种方法是一组代表不同生长区域的种子像素开始，接下来将种子像素邻域里符合条件的像素合并到种子像素所代表的生长区域中，并将新添加的像素作为新的种子像素继续合并过程，直到找不到符合条件的新像素为止。该方法的关键是选择合适的初始种子像素以及合理的生长准则。&lt;br&gt; 　　另一种区域法是非种子区域增长方法。这种方法不需要直接种子，先选取一个种子，这个区域并不影响最终的结果。然后按照种子生长法找到最近邻，相似性如果小于阈值T，则加入区域$A_{i}$, 否则该点被认为不属于现在任何种子，将这个点作为新的种子。&lt;br&gt; 　　区域分裂合并法（Gonzalez，2002）的基本思想是首先将图像任意分成若干互不相交的区域，然后再按照相关准则对这些区域进行分裂或者合并从而完成分割任务，该方法既适用于灰度图像分割也适用于纹理图像分割。&lt;/p&gt;
&lt;h2 id=&quot;基于偏微分的方法&quot;&gt;&lt;a href=&quot;#基于偏微分的方法&quot; class=&quot;headerlink&quot; title=&quot;基于偏微分的方法&quot;&gt;&lt;/a&gt;基于偏微分的方法&lt;/h2&gt;&lt;p&gt;　　所谓的偏微分方程（PDE)的方法就是使用数值方法求解偏微分方程来实现对图像分割，中心思想就是求解根据具体任务定义的损失函数最小的初始曲线。曲线传播就是在这类方法中特别流行。广泛应用与对象的提取、目标跟踪。&lt;/p&gt;
&lt;h2 id=&quot;基于图论的分割方法&quot;&gt;&lt;a href=&quot;#基于图论的分割方法&quot; class=&quot;headerlink&quot; title=&quot;基于图论的分割方法&quot;&gt;&lt;/a&gt;基于图论的分割方法&lt;/h2&gt;&lt;p&gt;　　此类方法把图像分割问题与图的最小割（min cut）问题相关联。首先将图像映射为带权无向图G=&lt;v，e&gt;，图中每个节点N∈V对应于图像中的每个像素，每条边∈E连接着一对相邻的像素，边的权值表示了相邻像素之间在灰度、颜色或纹理方面的非负相似度。而对图像的一个分割s就是对图的一个剪切，被分割的每个区域C∈S对应着图中的一个子图。而分割的最优原则就是使划分后的子图在内部保持相似度最大，而子图之间的相似度保持最小。基于图论的分割方法的本质就是移除特定的边，将图划分为若干子图从而实现分割。目前所了解到的基于图论的方法有GraphCut，GrabCut和Random Walk等。&lt;br&gt;＃＃　基于能量泛函的分割方法&lt;br&gt;  该类方法主要指的是活动轮廓模型（active contour model）以及在其基础上发展出来的算法，其基本思想是使用连续曲线来表达目标边缘，并定义一个能量泛函使得其自变量包括边缘曲线，因此分割过程就转变为求解能量泛函的最小值的过程，一般可通过求解函数对应的欧拉(Euler．Lagrange)方程来实现，能量达到最小时的曲线位置就是目标的轮廓所在。按照模型中曲线表达形式的不同，活动轮廓模型可以分为两大类：参数活动轮廓模型（parametric active contour model）和几何活动轮廓模型（geometric active contour model）。&lt;br&gt;  参数活动轮廓模型是基于Lagrange框架，直接以曲线的参数化形式来表达曲线，最具代表性的是由Kasset a1(1987)所提出的Snake模型。该类模型在早期的生物图像分割领域得到了成功的应用，但其存在着分割结果受初始轮廓的设置影响较大以及难以处理曲线拓扑结构变化等缺点，此外其能量泛函只依赖于曲线参数的选择，与物体的几何形状无关，这也限制了其进一步的应用。&lt;br&gt;  几何活动轮廓模型的曲线运动过程是基于曲线的几何度量参数而非曲线的表达参数，因此可以较好地处理拓扑结构的变化，并可以解决参数活动轮廓模型难以解决的问题。而水平集（Level Set）方法（Osher，1988）的引入，则极大地推动了几何活动轮廓模型的发展，因此几何活动轮廓模型一般也可被称为水平集方法。&lt;/v，e&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zouxy09/article/details/8534954&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zouxy09/article/details/8534954&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Image_segmentation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;图像分割是什么东西？根据字面意思就是将图像中的某块区域分割出来。至于分割测程度可做什么样子的分割则要取决于问题，如何做分割则需要取决于图像的灰度、位置信息、边（线，曲线等）、颜色、纹理和形状等特征把图像划分成若干互不交迭的区域。更精确的说，图像分割就是将每一个像素点贴上标签，而相同标签的像素点具有共同的特征。这里先对图像分割方法做一个总体的介绍，后面再对某些算法做具体的学习和了解。&lt;br&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图像分割" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>codecraft失败者总结</title>
    <link href="http://yoursite.com/2016/04/11/codecraft%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/11/codecraft总结/</id>
    <published>2016-04-11T02:00:38.000Z</published>
    <updated>2016-04-13T10:30:51.527Z</updated>
    
    <content type="html">&lt;p&gt;3月中下旬的时候，听同学说有一个华为的比赛，叫codecraft。赛题是：&lt;/p&gt;
&lt;p&gt;未来网络·寻路&lt;br&gt;赛题源自“未来网络”业务发放中的路由计算问题。算路问题属于基础算法问题，在图论、网络、交通&lt;br&gt;等各个方面均有着广泛的研究与运用，里面不乏一些经典的算法，例如最短路中的广度优先搜索，Dijkstra算法等。网络算路问题的更优算法实现对于网络资源高效配置具有重要价值。&lt;br&gt;技术领域：c、c++、JAVA&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;当时听到这个消息，听心动的，三月下旬找了一个c++比较牛的队友，决定做这个比赛。一开始商量对策，我们两个人的算法功底都不行，面对面商量的时候没有商量出什么好的对策出来，再加上我c++功底很差，长时间没有使用，很多基础的东西都忘记了，也暴露出我的基础还比较薄弱。&lt;br&gt;后来我用python将算法写出来了，使用的是最短路径，从startpoint开始计算到下一个keypoint的最短路径，按照一定的概率选择下一个去的点，重复直到到达end点。重复多次，选取路径最短的路。借鉴的是随机森林的想法，建立多条随机路径，选择最优的那个。后来想想，这个算法太××了，节点少还好，节点多了完全没有办法找到最优路径，而且时间复杂度还很大。&lt;br&gt;当时写完算法，还没有意识到，就将算法给了那位同学，准备用boost graph library库，结果他不怎么会用，就悲催了，他一直在试探，好几天都没有处理（他比较忙这个也是一个客观因素）。最后智能自己上手，慢慢摸索，找到了boost graph library求最短路径的方法使用，结果快要到截止日期了（总共就没花几个晚上）。意识到时间复杂度跟效率太低，这个时候代码已经编写到一半了，现在改算法已经来不及了。。。。&lt;br&gt;总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做程序员基础的数据结构跟算法的功底一定要强，这个方面我一定要加强&lt;/li&gt;
&lt;li&gt;程序员就像工匠，编程语言就是工匠手中的工具，想法再好，算法再厉害，不会用工具将这些算法实现处理，也是白瞎。&lt;/li&gt;
&lt;li&gt;想到一个算法之后，一定要在纸上演算一遍，计算时间和空间复杂度，否则实现代码的成本太大，等意识到算法效率跟复杂度达不到要求，就白费功夫了&lt;/li&gt;
&lt;li&gt;再次强调，算法一定要在纸上验算一下，写下伪代码，然后再具体编写代码，这样各种开销会小很多！！！！！&lt;/li&gt;
&lt;li&gt;关于专注力，我并没有将这个比赛放在心上，所以并没有花费太多时间在这件事上，因此也就导致最后的结果并不好，这是在意料之中的，但是如果不想做一件事，那么就不要接下来，接下来了就要全心全意的完成他！！！！将一件事做的完美这个才是最重要的。&lt;/li&gt;
&lt;li&gt;关于团队合作，除了第一天交流算法，后面十几天完全没有太多的交流，这个是十分的错误！！！最好两天或者三天就交流一次！！！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然算法比较烂，还是附上，以后可能还有用，10000个小时法则，重点就在这10000个小时的积累。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;196&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;197&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;198&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;199&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;201&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;202&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;203&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;204&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;205&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;206&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;207&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;208&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;209&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;210&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;212&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;213&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;214&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;215&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;216&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;217&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;218&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;219&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;220&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;221&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;222&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;223&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;224&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;225&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;226&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;227&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;228&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;229&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;230&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;231&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;232&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;233&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;235&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;236&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;237&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;238&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;239&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Created on Wed Mar 30 20:20:51 2016&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@author: wq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Created on Fri Mar 25 08:01:56 2016&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@author: wq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import networkx as nx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import random  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#绘图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def draw(DG, subsub_set , subset, start, end):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pos=nx.spring_layout(DG) # positions for all nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_nodes(DG,pos,nodelist =subsub_set,  node_size=500)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_nodes(DG,pos,nodelist =subset,  node_size=500, node_color=&amp;apos;b&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_nodes(DG,pos,nodelist =[start],  node_size=500, node_color=&amp;apos;g&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_nodes(DG,pos,nodelist =[end],  node_size=500, node_color=&amp;apos;y&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # edges&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_edges(DG,pos)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # labels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nx.draw_networkx_labels(DG,pos,font_size=20,font_family=&amp;apos;sans-serif&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.axis(&amp;apos;off&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#    plt.savefig(&amp;quot;weighted_graph.png&amp;quot;) # save as png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.show() # display&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#按照某一个概率抽取，如some_list = [1,2,3] probabilities = [0.2, 0.3, 0.5] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def randomPick(some_list, probabilities):  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = random.uniform(0,1)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cumulative_probability = 0.0  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for item, item_probability in zip(some_list, probabilities):  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cumulative_probability += item_probability  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if x &amp;lt; cumulative_probability:break  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return item  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#获得路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def getRoute(G, subset, start):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;apos;&amp;apos;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    G不包括终点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    G1与G一样，但是在函数体中不被操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    G为networkx图模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subset为关键子集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start为起始点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    route为返回的路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    score为权值得分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    该程序采用递归随机贪心算法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;apos;&amp;apos;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start_point = start #运算的起点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subset_buf = subset[:] #子集的备份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    score = 0 #权值得分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    route = [start] #路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    G1 = G.copy() #图的复本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #subset_weight = [] #start_point到邻居权值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    has_go_subset = [start]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next_route = &amp;#123;&amp;#125;#某一节点不可达的节点list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #print start_point, subset_buf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next_route[start_point] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for i in subset:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_route[i] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #print &amp;apos;start&amp;apos;, G.nodes(), subset, start&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for deep in xrange(len(subset)*len(subset)/4):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset_buf&amp;apos;, subset_buf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset_no_next = next_route[start_point]     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset_buf_next = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset_weight = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for i in subset_buf:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if i in subset_no_next:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    #判断这条路是不是走不通了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    subset_weight.append(nx.shortest_path_length(G1, source = start_point, target = i , weight = &amp;apos;weight&amp;apos;))           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    subset_buf_next.append(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            except:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                next_route[start_point].append(i)#如果不可达，则加入该节点不可达List中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                #subset_weight.append(10000)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #将路径的权值转换为概率，例如subset = [x1, x2, x3] subset_weight = [w1, w2, w3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #subset_probability = [(1/x1)/(1/x1+1/x2+1/x3), (1/x2)/(1/x1+1/x2+1/x3), (1/x3)/(1/x1+1/x2+1/x3)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #求概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset no next&amp;apos;, subset_no_next&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset weight&amp;apos;, subset_weight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset next&amp;apos;, subset_buf_next&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if len(subset_buf_next) == 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                start_point = has_go_subset.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            except:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return route, 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            route = route[:route.index(start_point)+1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            G1 = G.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            G1.remove_nodes_from(route[:route.index(start_point)])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            subset_buf = [x for x in subset if x not in route]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        accu_buf = reduce(lambda x, y:x*y, subset_weight)    #权值求和&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum_buf = reduce(lambda x, y: x + accu_buf/y, subset_weight)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset_probability = map(lambda x:accu_buf/(x*sum_buf), subset_weight)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset_probability&amp;apos;, subset_probability&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #按照subset_probability中的概率抽取next_point，将start到next_point的路径加入到route中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;subset_buf_next&amp;apos;, subset_buf_next        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_point = randomPick(subset_buf_next, subset_probability)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #print next_route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #print &amp;apos;find&amp;apos;, G1.nodes(), start_point, next_point, route, subset_buf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            route_buf = nx.shortest_path(G1, start_point, next_point, weight = &amp;apos;weight&amp;apos;)  #如果本次没有找到next_point的路径，回退一下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;next point&amp;apos;, next_point&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;route_buf&amp;apos;, route_buf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        except nx.exception.NetworkXNoPath:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           # print G1.nodes(), start_point, next_point&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #print &amp;apos;NoPath&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if len(has_go_subset) == 0 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return route, 100000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                next_route[start_point].append(next_point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                start_point = has_go_subset.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                route = route[:route.index(start_point)+1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                G1 = G.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                G1.remove_nodes_from(route[:-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                subset_buf = [x for x in subset if x not in route]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                #print &amp;apos;ba&amp;apos;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #except KeyError:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #print &amp;apos;keyerror&amp;apos;, G1.nodes(),route,  start_point, next_point&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        G1.remove_nodes_from(route_buf[:-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       # print &amp;apos;route&amp;apos;, route, &amp;apos;route_buf&amp;apos;, route_buf        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        route = route + route_buf[1:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print &amp;apos;after route&amp;apos;, route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #计算总得分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        score = score + subset_weight[subset_buf_next.index(next_point)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #将路径中已经有的点从subset中去除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset_buf = [x for x in subset if x not in route]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        has_go_subset.append(next_point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        start_point = route[-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       # print &amp;apos;start_point&amp;apos;, start_point&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #如果subset为空，则返回route, score&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if len(subset_buf) == 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           # print &amp;apos;get&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return route, score&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #print next_route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return route, score&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ ==&amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result_route=[]    #最终结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result_weight = 100000   #最终得分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for j in xrange(10):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #打开文件，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result_route=[]    #最终结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result_weight = 100000   #最终得分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        topo_file = open(&amp;apos;case/case&amp;apos; + str(j) + &amp;apos;/topo.csv&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        demand_file = open(&amp;apos;case/case&amp;apos; + str(j) + &amp;apos;/demand.csv&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        demand = demand_file.read().split(&amp;apos;,&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        start_point = int(demand[0])#开始点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end_point = int(demand[1])#结束点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subset = [int(x) for x in demand[2].split(&amp;apos;|&amp;apos;)]#关键点子集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #构建图模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SG = nx.DiGraph()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SG.add_nodes_from(subset)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        graph = [line.strip().split(&amp;apos;,&amp;apos;)[1:4] for line in topo_file]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        graph_int = [tuple([int(x), int(y), float(z)]) for (x, y, z) in graph]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DG = nx.DiGraph()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DG.add_weighted_edges_from(graph_int)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #全集减去子集，这里是未来方便图的可视化表示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subsub_set = [x[0] for x in graph_int if( x[0] not in subset)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #draw(DG, subsub_set, subset, start_point, end_point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #print nx.shortest_path(DG, source = 2, target = 19)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #构建去除end_point的图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        G1 = DG.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        G1.remove_node(end_point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #循环4×length of subset次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for i in xrange(40):    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #print i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #获得路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            route, weight = getRoute(G1, subset, start = start_point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #except:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                #print &amp;apos;2&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                #continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #找route中的最后一个点到end_point的路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            G3 = DG.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if weight == 10000:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result_weight = 10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #构建将route中除最后一个node外的点全部删除的图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            G3.remove_nodes_from(route[:-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #寻找最短路径和最短路径的权值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            try:           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result = nx.shortest_path(G3, route[-1], end_point, weight = &amp;apos;weight&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                weight = weight + nx.shortest_path_length(G3, route[-1], end_point, weight = &amp;apos;weight&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #本次路径        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                route=route + result[1:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            except:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #如果本次路径权值最短，输出为最终路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if result_weight &amp;gt; weight:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result_weight = weight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result_route = route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if result_weight &amp;gt;= 10000:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print &amp;apos;case&amp;apos; + str(j) + &amp;apos;不可达&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print &amp;apos;case&amp;apos;,i, &amp;apos;  &amp;apos;,start_point, &amp;apos; - &amp;apos;, end_point&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print &amp;apos;case&amp;apos; + str(j), result_weight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print &amp;apos;case&amp;apos; + str(j) +&amp;apos;  route is&amp;apos;, result_route&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;3月中下旬的时候，听同学说有一个华为的比赛，叫codecraft。赛题是：&lt;/p&gt;
&lt;p&gt;未来网络·寻路&lt;br&gt;赛题源自“未来网络”业务发放中的路由计算问题。算路问题属于基础算法问题，在图论、网络、交通&lt;br&gt;等各个方面均有着广泛的研究与运用，里面不乏一些经典的算法，例如最短路中的广度优先搜索，Dijkstra算法等。网络算路问题的更优算法实现对于网络资源高效配置具有重要价值。&lt;br&gt;技术领域：c、c++、JAVA&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn中的逻辑回归</title>
    <link href="http://yoursite.com/2016/04/09/scikit-learn%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-%E4%B8%80/"/>
    <id>http://yoursite.com/2016/04/09/scikit-learn中的逻辑回归-一/</id>
    <published>2016-04-09T04:30:28.000Z</published>
    <updated>2016-04-13T14:00:43.804Z</updated>
    
    <content type="html">&lt;p&gt;scikit-learn是python的十分优秀的机器学习库，是数据挖掘和数据分析简单和有效的工具。官方链接为：&lt;a href=&quot;http://scikit-learn.org/stable/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://scikit-learn.org/stable/index.html&lt;/a&gt;&lt;br&gt;一直以来都在看数据挖掘跟机器学习，都比较零散，并且只限于理论部分，现在重新系统完整的学习一下相关的算法，并使用博客记录下来，通过理论、实现和scikit-learning的应用三维一体。本节主要介绍scikit-learn中逻辑归回的接口。&lt;br&gt;逻辑回归，尽管它的名字有“回归”两个字，但是这是一个线性分类器，而不是回归。Logistic回归载文献中也被称为Logit回归，对数线性分类器或最大熵分类器。关于最大熵分类器，将Logistic模型写成似然函数的时候，就转换成立求解最大熵了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’, verbose=0, warm_start=False, n_jobs=1)&lt;/p&gt;
&lt;p&gt;参数见官方网站&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LogisticRegression网站&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;正则项&quot;&gt;&lt;a href=&quot;#正则项&quot; class=&quot;headerlink&quot; title=&quot;正则项&quot;&gt;&lt;/a&gt;正则项&lt;/h1&gt;&lt;p&gt;分类问题的时候可以使用L2或L1正则化，正则化为了让模型具有更佳的泛化能力，降低模型的复杂度。&lt;br&gt;二分类L2正则化损失函数如下：&lt;br&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/96fe247fe9465d26af15706141dc22e598ac7826.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;同样的，L1正则化损失函数如下：&lt;br&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/3fb9bab302e67df4a9f00b8df259d326e01837fd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;优化求解&quot;&gt;&lt;a href=&quot;#优化求解&quot; class=&quot;headerlink&quot; title=&quot;优化求解&quot;&gt;&lt;/a&gt;优化求解&lt;/h1&gt;&lt;p&gt;求解Logistic回归，这里面有四种方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“LibLinear”:Liblinear则是国立台湾大学的chih-JenLin博士创建的，主要是应对large-scale的data classification，因为linear分类器的训练比非线性分类器的训练计算复杂度要低很多，时间也少很多，而且在large scale data上的性能和非线性的分类器性能相当，所以Liblinear是针对大数据而生的。这位博士创建的另一个十分有名的库就是Libsvm。&lt;/li&gt;
&lt;li&gt;“newton-cg”:这是yi&lt;/li&gt;
&lt;li&gt;“lbfgs”:LBFGS算法比较适合载大规模的数值计算中，具备牛顿法收敛速度快的它的，但不需要牛顿法那样存储Hesse矩阵，因此节省了大量的空间以及计算资源。参考[1]、[2]&lt;/li&gt;
&lt;li&gt;“SAG”:Stochastic Average Gradient descent随机平均梯度下降[3]。这是一种优化有限个平滑凸函数相加的和。与随机梯度下降（SG）方法相似，SAG方法的方法开销与函数的数量独立。时间复杂度从$O(1/\sqrt{2})$降低到$O(1/k)$.不能处理多分类问题，只限于L2惩罚函数，比其他的大数据（样本和特征数量比较多）解决方案要快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“lbfgs”和”newton-cg”只支持L2乘法，对高维数据来说收敛更快。L1惩罚预测的权值更加离散。&lt;br&gt;“liblinear”是基于Liblinear中的坐标下降的方法。但是坐标下降载liblinear的实现不能学习多源模型。&lt;/p&gt;
&lt;p&gt;如何选择优化方法呢？且看下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;训练集&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;solver&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;小数据集或L1惩罚性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;“liblinear”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多项损失&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;“lbfgs”或”newton-cg”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;大数据&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;”sag”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;大量数据集，也可以考虑使用SGDClassifier中’log’损失。&lt;/p&gt;
&lt;p&gt;下面代码是L1惩罚项下参数变化路径：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Author: Alexandre Gramfort &amp;lt;alexandre.gramfort@inria.fr&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# License: BSD 3 clause&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Path with L1- Logistic Regression&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; datetime &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datetime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sklearn &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; linear_model&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sklearn &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datasets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sklearn.svm &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; l1_min_c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iris = datasets.load_iris()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = iris.data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = iris.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = X[y != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = y[y != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X -= np.mean(X, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#####################################################&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Demo path functions&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cs = l1_min_c(X, y, loss=&lt;span class=&quot;string&quot;&gt;&#39;log&#39;&lt;/span&gt;) * np.logspace(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;Computing regularization path ...&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start = datetime.now()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clf = linear_model.LogisticRegression(C=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, penalty=&lt;span class=&quot;string&quot;&gt;&#39;l1&#39;&lt;/span&gt;, tol=&lt;span class=&quot;number&quot;&gt;1e-6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;coefs_ = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; cs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clf.set_params(C=c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clf.fit(X, y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    coefs_.append(clf.coef_.ravel().copy())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#如果预测就用clf.predict(X)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;This took &quot;&lt;/span&gt;, datetime.now() - start)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;coefs_ = np.array(coefs_)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.plot(np.log10(cs), coefs_)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ymin, ymax = plt.ylim()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;log(C)&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;Coefficients&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.title(&lt;span class=&quot;string&quot;&gt;&#39;Logistic Regression Path&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.axis(&lt;span class=&quot;string&quot;&gt;&#39;tight&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;[1] &lt;a href=&quot;http://blog.sina.com.cn/s/blog_eb3aea990101gflj.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_eb3aea990101gflj.html&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://blog.csdn.net/zhirom/article/details/38332111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zhirom/article/details/38332111&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;https://hal.inria.fr/hal-00860051/PDF/sag_journal.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;随机平均梯度下降&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;scikit-learn是python的十分优秀的机器学习库，是数据挖掘和数据分析简单和有效的工具。官方链接为：&lt;a href=&quot;http://scikit-learn.org/stable/index.html&quot;&gt;http://scikit-learn.org/stable/index.html&lt;/a&gt;&lt;br&gt;一直以来都在看数据挖掘跟机器学习，都比较零散，并且只限于理论部分，现在重新系统完整的学习一下相关的算法，并使用博客记录下来，通过理论、实现和scikit-learning的应用三维一体。本节主要介绍scikit-learn中逻辑归回的接口。&lt;br&gt;逻辑回归，尽管它的名字有“回归”两个字，但是这是一个线性分类器，而不是回归。Logistic回归载文献中也被称为Logit回归，对数线性分类器或最大熵分类器。关于最大熵分类器，将Logistic模型写成似然函数的时候，就转换成立求解最大熵了。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="scikit-learning" scheme="http://yoursite.com/tags/scikit-learning/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归的实现</title>
    <link href="http://yoursite.com/2016/04/09/logistic%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/04/09/logistic实现/</id>
    <published>2016-04-09T03:55:59.000Z</published>
    <updated>2016-04-13T14:01:03.776Z</updated>
    
    <content type="html">&lt;p&gt;前面讲了logistic的理论部分，这里我参照《机器学习实战》写了logistic的实现部分。如果对logistic不清楚，请看&lt;a href=&quot;/2016/04/08/逻辑斯蒂（Logistic-回归/&quot;&gt;逻辑回归&lt;/a&gt;。&lt;br&gt;logistic算法全部过程。&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/0ddf886f38c92b17.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;我建立了一个逻辑回归的类，类中包含三个主要函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fit:拟合模型.&lt;/li&gt;
&lt;li&gt;predict：进行预测&lt;/li&gt;
&lt;li&gt;score：求错误率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据我使用预测患有疝病的马的存活问题。这里面的数据包含368个样本和28个特征。下面是详细代码，我的github上面有数据和代码:&lt;a href=&quot;https://github.com/allensummer/machineLearning/tree/master/logistic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;logistic regression&lt;/a&gt;&lt;br&gt;下面是具体代码，如果知道logistic原理，下面的代码并不难理解&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Created on Fri Apr  8 23:59:45 2016&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@author: wq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;逻辑回归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;  *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LogisticRegression&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    二项逻辑回归模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, alpha=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        初始化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ---------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alpha,梯度下降迭代步长&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.alpha = alpha&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.weights = []     &lt;span class=&quot;comment&quot;&gt;#模型权值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sigmoid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, inX)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#print inX&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+sum(exp(-inX)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, dataMatrix, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;根据训练数据拟合模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataMatrix:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            训练样本属性矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            类型：array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classLabels：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            训练样本标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            类型：list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        row,col = dataMatrix.shape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(self.weights) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weights = ones(col)   &lt;span class=&quot;comment&quot;&gt;#初始化权值矩阵2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weights = self.weights&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        diff = weights      &lt;span class=&quot;comment&quot;&gt;#权值变化矩阵，初始化为权值矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#迭代次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(abs(max(diff))&amp;gt;&lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;):     &lt;span class=&quot;comment&quot;&gt;#当权值变化很小的时停止迭代。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dataIndex = range(row)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(row):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alpha = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;/(self.alpha+i)+&lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#alpha随着每次迭代，下降。参数趋于稳定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                randIndex = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,len(dataIndex)))&lt;span class=&quot;comment&quot;&gt;#随机选取训练对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                h = self.sigmoid(sum(dataMatrix[randIndex]*weights))&lt;span class=&quot;comment&quot;&gt;#sigmoid求值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                error = classLabels[randIndex] - h      &lt;span class=&quot;comment&quot;&gt;#误差项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                diff = weights      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                weights = weights + alpha * error * dataMatrix[randIndex]&lt;span class=&quot;comment&quot;&gt;#权值更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                diff = weights - diff                &lt;span class=&quot;comment&quot;&gt;#权值差异&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(dataIndex[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.weights = weights&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#print weights&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,dataList)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        训练的二项逻辑回归预测&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        --------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataList：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            待预测样本属性,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            类型：list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(self.weights) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; KeyError,(&lt;span class=&quot;string&quot;&gt;&quot;没有进行模型训练&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#如果没有进行fit预测，抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prob = self.sigmoid(sum(dataList*self.weights))&lt;span class=&quot;comment&quot;&gt;#概率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; prob &amp;gt; &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,dataMatrix, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        评价模型性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataMatrix:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            测试样本属性举证&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            属性：array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classLabels:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            测试样本类别，这里只有1、0两类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            属性：list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ---------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorRate：错误率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numData = len(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#行数记录，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataMatrix:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#print &#39;预测结果&#39;,self.predict(line)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#print &#39;样本标签&#39;,classLabels[j]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; int(self.predict(line)) != int(classLabels[j]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#print errorCount&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorRate = (float(errorCount)/numData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the error rate of this test is: %f&quot;&lt;/span&gt; % errorRate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; errorRate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__==&lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frTrain = open(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTraining.txt&#39;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frTest = open(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTest.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#读取训练集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingSet = []; trainingLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; frTrain.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainingSet.append(map(float, line)[:&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainingLabels.append(float(line[&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#读取测试集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testSet = [];testLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; frTest:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        testSet.append(map(float, line)[:&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        testLabels.append(line[&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#实例化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clf = LogisticRegression(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#迭代10次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clf.fit(array(trainingSet), trainingLabels)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clf.score(array(testSet), testLabels)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;《机器学习实战》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲了logistic的理论部分，这里我参照《机器学习实战》写了logistic的实现部分。如果对logistic不清楚，请看&lt;a href=&quot;/2016/04/08/逻辑斯蒂（Logistic-回归/&quot;&gt;逻辑回归&lt;/a&gt;。&lt;br&gt;logistic算法全部过程。&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/0ddf886f38c92b17.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="logistic实现" scheme="http://yoursite.com/tags/logistic%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>LDA浅显理解</title>
    <link href="http://yoursite.com/2016/04/08/LDA%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/08/LDA浅显理解/</id>
    <published>2016-04-08T13:52:25.000Z</published>
    <updated>2016-04-08T13:57:35.991Z</updated>
    
    <content type="html">&lt;p&gt;这一段时间在看LDA主题模型，这里说一下我对LDA的理解，抛开复杂的数学、概率论、机器机器学习算法，只说思路，其他内容以后再更加详细的写。&lt;br&gt;假设有一个机器人，他想写一篇文章,每篇文章包含N个词，那么他怎么写呢？？？&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151224215521383&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Unigram-model&quot;&gt;&lt;a href=&quot;#Unigram-model&quot; class=&quot;headerlink&quot; title=&quot;Unigram model&quot;&gt;&lt;/a&gt;Unigram model&lt;/h1&gt;&lt;p&gt;科学家A一开始这么设计，先给机器人读大量的文章，这样这个机器人的大脑中会有S个词，这些词组成了词向量$W=[w_1, w_2, w_3 …… w_S]$，每一个词都有相对应的概率$P=[p(w_1), p(w_2), p(w_3) …… p(w_S)$  。&lt;br&gt;算法如下：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;for i = 1 to N:&lt;br&gt; 　　choose a word $w_i～ p(W)$ &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示即：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;$p(w) = ∏ p(w n )$&lt;br&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201209/03/1346652013_8454.PNG&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Mixture-of-unigrams&quot;&gt;&lt;a href=&quot;#Mixture-of-unigrams&quot; class=&quot;headerlink&quot; title=&quot;Mixture of unigrams&quot;&gt;&lt;/a&gt;Mixture of unigrams&lt;/h1&gt;&lt;p&gt;科学家B觉得不应该这样，他认为机器人读的这些文章分成不同的主题$Z=[z_1, z_2 …… z_t]$，每个主题的概率为$P(Z)=[p(z_1), p(z_2), …… p(z_t))]$,第i主题下又有S个高频词向量$W=[w_1, w_2, w_3 …… w_S]$，每一个词都有相对应的概率$P=[p(w_1|z_i), p(w_2|z_i), p(w_3|z_i) …… p(w_S|z_i)$。&lt;br&gt;算法描述如下：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;choose a topic $z_i～p(Z);  &lt;/p&gt;
&lt;p&gt;for i = 1 to N&lt;br&gt;　　choose a word $w_i～ p(W|z_i)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示为：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;$p(w) = ∑ p(z) ∏ p(w n | z)&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230194155151&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;也就是说按照学习到的概率选择一个Topic,按照这个Topic下词的概率选择N个词。&lt;/p&gt;
&lt;h1 id=&quot;Probabilistic-lantent-semantic-indexinal-pLSI&quot;&gt;&lt;a href=&quot;#Probabilistic-lantent-semantic-indexinal-pLSI&quot; class=&quot;headerlink&quot; title=&quot;Probabilistic lantent semantic indexinal(pLSI)&quot;&gt;&lt;/a&gt;Probabilistic lantent semantic indexinal(pLSI)&lt;/h1&gt;&lt;p&gt;科学家C（Hoffman）认为应该一篇文档可以由多个主题（topic $Z=[z_1, z_2 …… z_t]$）混合而成，每个主题的概率为$P(Z)=[p(z_1), p(z_2), …… p(z_t))]$，而每个Topic都是词汇上的概率分布$P=[p(w_1|z_i), p(w_2|z_i), p(w_3|z_i) …… p(w_S|z_i)]$，文章中的每一个词都有固定的topic。&lt;br&gt;算法描述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Choose parameter θ ～ p(θ)             #θ为选择出来的主题向量&lt;br&gt;for i = 1 to N&lt;br&gt;　　choose a topic $z_j ～ p(z|θ)$&lt;br&gt; 　　choose a word $w_k ～ p(w|z_j)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示即：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230193416158&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230194255120&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230200824920&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Lanton-Dirichlet-Allocation-LDA&quot;&gt;&lt;a href=&quot;#Lanton-Dirichlet-Allocation-LDA&quot; class=&quot;headerlink&quot; title=&quot;Lanton Dirichlet Allocation(LDA)&quot;&gt;&lt;/a&gt;Lanton Dirichlet Allocation(LDA)&lt;/h1&gt;&lt;p&gt;科学家D（David M. Blei）认为这个主题的概率分布、词汇的概率分布并不是固定的（与pLSA相比），应该是符合某一个分布，选取主题或词汇的时候，这个概率是动态变化的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;initialize $φ_{ni}^0$  := 1/k for all i and n&lt;br&gt;initialize $γ_i := α&lt;em&gt;i + N/k$ for all i and n&lt;br&gt;repeat&lt;br&gt;　for n = 1 to N&lt;br&gt;　　for i = 1 to k&lt;br&gt;　　　 $φ^{t+1}&lt;/em&gt;{ni} = β_{iw_n}exp(Ψ(γ_i^t ))$&lt;br&gt;　　normalize $φ&lt;em&gt;n^{t+1}$ to sum to 1.&lt;br&gt;　$γ&lt;/em&gt;{t+1} = α + ∑^N_{n=1} φ_n^{t+1}$&lt;br&gt;until convergence&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学公式如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201004940&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201044552&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201221551&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;上述是我理解的LDA，一个机器人想要写一篇文章，那么先按照Dirichlet分布选择出主题向量，载这个主题向量的基础上，生成词汇。&lt;br&gt;使用LDA模型进行推断的时候，是倒过来的，由文档的词汇生成主题。因此LDA常常也用来做&lt;strong&gt;降维工具&lt;/strong&gt;。使用在语义分析，图像、文本分类等等&lt;/p&gt;
&lt;h1 id=&quot;pLSA与LDA对比&quot;&gt;&lt;a href=&quot;#pLSA与LDA对比&quot; class=&quot;headerlink&quot; title=&quot;pLSA与LDA对比&quot;&gt;&lt;/a&gt;pLSA与LDA对比&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;LDA&lt;/strong&gt;：假定语料库中共有M篇文章，每篇文章下的Topic的主题分布是一个从参数为的Dirichlet先验分布中采样得到的Multinomial分布，每个Topic下的词分布是一个从参数为的Dirichlet先验分布中采样得到的Multinomial分布。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201221551&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pLSA&lt;/strong&gt;：对于某篇文章中的第n个词，首先从该文章中出现的每个主题的Multinomial分布（主题分布）中选择或采样一个主题，然后再在这个主题对应的词的Multinomial分布（词分布）中选择或采样一个词。不断重复这个随机生成过程，直到M篇文章全部生成完成。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230200824920&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;相关知识点&quot;&gt;&lt;a href=&quot;#相关知识点&quot; class=&quot;headerlink&quot; title=&quot;相关知识点&quot;&gt;&lt;/a&gt;相关知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;gamma函数&lt;/li&gt;
&lt;li&gt;Dirichlet分布&lt;/li&gt;
&lt;li&gt;共轭先验和贝叶斯框架&lt;/li&gt;
&lt;li&gt;EM模型&lt;/li&gt;
&lt;li&gt;MCMC、Gibbs采样&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;训练和推断&quot;&gt;&lt;a href=&quot;#训练和推断&quot; class=&quot;headerlink&quot; title=&quot;训练和推断&quot;&gt;&lt;/a&gt;训练和推断&lt;/h1&gt;&lt;p&gt;对于LDA模型，有两个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;估计模型中的语料库中的主题Dirichlet分布和每个主题下的词汇的Dirichlet分布&lt;/li&gt;
&lt;li&gt;对于一篇新的文档，计算这篇文档的topic分布&lt;br&gt;训练过程：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230202705096&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;推断过程：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230202758668&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;###参考资料&lt;br&gt;1、Blei, David M.; Ng, Andrew Y.; Jordan, Michael I. Latent Dirichlet allocation（LDA原始论文）：&lt;a href=&quot;http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf&lt;/a&gt;&lt;br&gt;2、rickjin的LDA数学八卦（力荐，本文部分图片和公式来自于此文档）&lt;br&gt;网页版：&lt;a href=&quot;http://www.flickering.cn/tag/lda/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.flickering.cn/tag/lda/&lt;/a&gt;&lt;br&gt;PDF：&lt;a href=&quot;http://emma.memect.com/t/9756da9a47744de993d8df13a26e04e38286c9bc1c5a0d2b259c4564c6613298/LDA；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://emma.memect.com/t/9756da9a47744de993d8df13a26e04e38286c9bc1c5a0d2b259c4564c6613298/LDA；&lt;/a&gt;&lt;br&gt;3、搜索背后的奥秘——浅谈语义主题计算：&lt;a href=&quot;http://www.semgle.com/search-engine-algorithms-mystery-behind-search-on-the-calculation-of-semantic-topic；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.semgle.com/search-engine-algorithms-mystery-behind-search-on-the-calculation-of-semantic-topic；&lt;/a&gt;&lt;br&gt;4、LDA的相关论文、工具库：&lt;a href=&quot;http://site.douban.com/204776/widget/notes/12599608/note/287085506/；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://site.douban.com/204776/widget/notes/12599608/note/287085506/；&lt;/a&gt;&lt;br&gt;5、LDA实现 &lt;a href=&quot;http://www.cs.princeton.edu/~blei/topicmodeling.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cs.princeton.edu/~blei/topicmodeling.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这一段时间在看LDA主题模型，这里说一下我对LDA的理解，抛开复杂的数学、概率论、机器机器学习算法，只说思路，其他内容以后再更加详细的写。&lt;br&gt;假设有一个机器人，他想写一篇文章,每篇文章包含N个词，那么他怎么写呢？？？&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151224215521383&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="LDA" scheme="http://yoursite.com/tags/LDA/"/>
    
  </entry>
  
  <entry>
    <title>大话逻辑回归</title>
    <link href="http://yoursite.com/2016/04/08/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%EF%BC%88Logistic-%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2016/04/08/逻辑斯蒂（Logistic-回归/</id>
    <published>2016-04-08T03:49:37.000Z</published>
    <updated>2016-04-09T04:22:08.532Z</updated>
    
    <content type="html">&lt;p&gt;在Machine Learning中，逻辑斯蒂回归（Logistic Regression）是十分经典的方法,简称LR，虽然名字叫回归，但是这是线性分类模型而不是回归模型。这里面涉及到一些知识点，包括极大似然估计，损失函数，梯度下降，正则化等&lt;!--逻辑斯特回归是对条件概率密度$P(x|C/_K)$建模的，也就是后验概率$P(C/_k)$,使用它们通过贝叶斯理论来计算后验概率$P(C/_k|x).--&gt;&lt;br&gt;这篇文章的主要目的，就是通过理论与实践相结合的方式讲解LR模型，在讲解的过程中，加深对LR的理解、相关概念的梳理和应用。这篇文章中需要一些基础的数学知识，如果我没有讲到的请自行百度。这篇文章以《统计学习方法》和AndrewNg的视频为基础，加上《PR&amp;amp;MR》以及网上的资料、论文整理而成。本人能力有限，细节处理上难免有不严谨的地方或者叙述不清的地方，请留言或者发邮件wang_qian010@163.com&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;逻辑斯蒂（logistic-函数&quot;&gt;&lt;a href=&quot;#逻辑斯蒂（logistic-函数&quot; class=&quot;headerlink&quot; title=&quot;逻辑斯蒂（logistic)函数&quot;&gt;&lt;/a&gt;逻辑斯蒂（logistic)函数&lt;/h1&gt;&lt;h2 id=&quot;逻辑斯蒂函数&quot;&gt;&lt;a href=&quot;#逻辑斯蒂函数&quot; class=&quot;headerlink&quot; title=&quot;逻辑斯蒂函数&quot;&gt;&lt;/a&gt;逻辑斯蒂函数&lt;/h2&gt;&lt;p&gt;在数学界有各种各样的分布，比如Gamma分布，二项分布，高斯分布等。利用这些分布的性质，可以解决很多的问题。这里将介绍一种函数，叫逻辑斯蒂函数或逻辑斯蒂曲线，这是一种是一种S型曲线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;  设$X$是连续随机变量，$X$服从逻辑斯蒂分布是指$X$具有下列分布函数和密度函数&lt;br&gt;$$F(x) = P(X\leq x) = \frac{1}{1+e^{-(x-u）/\gamma)} }$$&lt;br&gt;$$f(x) = F’(x) = \frac{e^{-(x-u)/\gamma}}{\gamma(1+e^{-(x-u)}/\gamma)^{2}}$$&lt;br&gt;式中，$\mu$为位置参数，$\gamma$为形状参数。看到这是不是想到，高斯、二项等其他分布。均值控制位置，方差控制形状。&lt;br&gt;逻辑斯蒂分布的密度函数$f(x)和分布函数$F(x)$的图形如下图&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6cbb8645gw1ewjejmez18j20jw08dq3g.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看了逻辑斯蒂分布，我有两个疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个分布是怎么发现？&lt;/li&gt;
&lt;li&gt;在机器学习中什么用？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上网查了一下，并没有找到这个分布是怎么发现的。最早的记录是1833年，菲尔许尔斯特使用逻辑斯蒂曲线描述了人口增长速度与人口密度的关系，把数学方法引入生态学。我大一的时候参加一个数学建模入门赛的时候，就是拟合了逻辑斯特函数，模型太简单，所以就很傻很天真的看着别人载比赛喽。&lt;br&gt;到了十九世纪末，法国的社会学家塔尔德观察到，一种新思想（就比如和谐社会）的采纳率随着时间的变化遵循一种S型曲线，也有人说塔尔德实际是提出了经济增长的S型曲线。&lt;br&gt;随后的一段时间，S曲线在各个行业都大杀四方，从物种迁移数量增长到工程进展，从城市化进程到经济学的前景理论等等。&lt;br&gt;随后可能有一位天才，正在研究分类问题，猛然看到了S曲线，突然想到，咦，这个曲线(如上右图）左边随着x的变小F(x)趋近于0，右边随着想的增大F(x)趋近与一个定值，不是正好可以用来做做二分类嘛。（仅供娱乐，如有雷同纯属巧合）&lt;/p&gt;
&lt;h1 id=&quot;二项逻辑斯蒂回归模型&quot;&gt;&lt;a href=&quot;#二项逻辑斯蒂回归模型&quot; class=&quot;headerlink&quot; title=&quot;二项逻辑斯蒂回归模型&quot;&gt;&lt;/a&gt;二项逻辑斯蒂回归模型&lt;/h1&gt;&lt;p&gt;现在我们仅仅考虑二分类问题。就拿AndrewNG的讲义里面的例子，如下图所示，x表示数据点的特征——肿瘤的大小，Y为观测值——是否是恶性肿瘤。通过构建线性回归模型，如h θ (x)所示，构建线性回归模型后，即可以根据肿瘤大小，预测是否为恶性肿瘤h θ (x)≥.05为恶性，h θ (x)&amp;lt;0.5为良性。&lt;br&gt;&lt;img src=&quot;http://52opencourse.com/?qa=blob&amp;amp;qa_blobid=28151414763210940&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果上述问题使用线性分类器，效果并不好（如上图），分类效果可以用差来形容。然后你再看着这个图，是不是感觉观测值类似第一幅图？&lt;br&gt;在解决上诉问题之前，接下来我们先看看逻辑回归模型：&lt;br&gt;将逻辑回归模型定义为：&lt;br&gt;$$log\frac{\pi(X)}{1-\pi(X)}=w_1x_1+…+w_nx_p+b$$&lt;br&gt;$$=X^t\beta$$&lt;br&gt;这里&lt;br&gt;$$W=(w^1, w^2, …, w^n, b)$$&lt;/p&gt;
&lt;p&gt;$$X=(x^1, x^2, …, x^n, 1)$$&lt;/p&gt;
&lt;p&gt;$$P(Y=1|X)=\pi(X）这里的$\pi(X)%是逻辑回归中的标准表示.$$&lt;/p&gt;
&lt;p&gt;逻辑回归可以这么理解，考虑对输入X进行分类的线性函数$WX$,其至于为实数域，通过逻辑斯蒂函数，可以将线性函数$WX$转换为概率。&lt;br&gt;换一个角度，逻辑斯蒂回归模型的特点就是已经事情的发生概率是指该只见发生的概率与该事件不发生的概率的比值。一个事件的几率是p，那么该事件发生的几率是$\frac{p}{1-p}$,该事件可以理解为该事件的对数几率或logit函数是&lt;/p&gt;
&lt;p&gt;$$logit(p)=log(\frac{p}{1-p})$$&lt;/p&gt;
&lt;p&gt;经过简单推导，就可以得到标准的逻辑回归模型。&lt;br&gt;&lt;strong&gt;定义（逻辑斯蒂回归模型）&lt;/strong&gt;  二项逻辑斯蒂回归模型是如下的条件概率分布：&lt;/p&gt;
&lt;p&gt;$$P(Y=1|X) = \frac{exp(WX)}{1+exp(WX)}$$&lt;/p&gt;
&lt;p&gt;$$P(Y=0|X) = \frac{1}{1+exp(WX)}$$&lt;/p&gt;
&lt;p&gt;逻辑斯特回归模型也可以说是建立在条件概率密度$p(x|C_k)$和先验概率$P(C_k)$的基础上，使用贝叶斯理论计算后验概率密度$P(C_k|x)的模型。利用贝叶斯后验概率求解该问题，则&lt;/p&gt;
&lt;p&gt;$$P(Y=1|x) = \frac{P(x|Y=1)P(Y=1)}{p(x|Y=1)P(Y=1)+P(x|Y=0)P(Y=0)}$$&lt;br&gt;$$=\frac{1}{1+e^{ln(\frac{P(x|Y=0)P(Y=0))}{P(x|Y=1)P(Y=1)}}}$$ &lt;/p&gt;
&lt;p&gt;到这里是不是感觉后验概率$P(Y=1|x)$与逻辑斯蒂函数很像？其实从（1）式可以推导到逻辑斯蒂函数的，《PR&amp;amp;ML》这本书中借助高斯分布有一点介绍，这里就不说了。&lt;/p&gt;
&lt;h1 id=&quot;模型参数估计&quot;&gt;&lt;a href=&quot;#模型参数估计&quot; class=&quot;headerlink&quot; title=&quot;模型参数估计&quot;&gt;&lt;/a&gt;模型参数估计&lt;/h1&gt;&lt;p&gt;对于上面患病问题，对给定的数据集$T={(x^1, y^1), (x^2, y^2), .., x^N, y^N)}$$，可以应用极大私人估计模型参数，从而得到逻辑回归模型。&lt;br&gt;这里使用极大似然估计求解，极大似然估计的理解是根据现有数据，选择使模型得到现有训练集可能性最大的参数。参数估计我就直接贴出《统计学习方法》中的原文。&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/0d6d163d711f0ca0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面列出了将逻辑回归问题通过极大似然的方法转换成了最优化的问题，最优化问题有多种解决方案，这里给出使用梯度下降的完整的逻辑回归算法如下，关于最优化问题的求解请链接到&lt;a href=&quot;&quot;&gt;最优化问题(待更新）)&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/0ddf886f38c92b17.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;正则化&quot;&gt;&lt;a href=&quot;#正则化&quot; class=&quot;headerlink&quot; title=&quot;正则化&quot;&gt;&lt;/a&gt;正则化&lt;/h1&gt;&lt;p&gt;在模型参数估计这，已经将问题变为目标函数的最优化问题。为了让降低模型的复杂度，更好的泛化，可以在使用梯度下降的时候，添加一个正则项。二分类问题的L2乘法回归最小化如下（正则化链接-等待更新）：&lt;br&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/96fe247fe9465d26af15706141dc22e598ac7826.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;同样，L1正则化逻辑回归解决的优化问题如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/3fb9bab302e67df4a9f00b8df259d326e01837fd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;多分类问题&quot;&gt;&lt;a href=&quot;#多分类问题&quot; class=&quot;headerlink&quot; title=&quot;多分类问题&quot;&gt;&lt;/a&gt;多分类问题&lt;/h1&gt;&lt;p&gt;在实际应用中，我们常常碰见多分类问题，我们如何将逻辑回归应用到上面呢？其实这里可以这样想，N分类问题，对于每一类都可以将他转换为二分类问题：是该类和非该类，每一类的逻辑模型是：&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/f83cad9cfe6687fc.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在进行分类的时候，对每一个输入的特征向量求的该类的该类，取概率最大的分类。&lt;/p&gt;
&lt;h1 id=&quot;逻辑回归实现&quot;&gt;&lt;a href=&quot;#逻辑回归实现&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归实现&quot;&gt;&lt;/a&gt;逻辑回归实现&lt;/h1&gt;&lt;p&gt;请看&lt;a href=&quot;/2016/04/09/logistic实现/&quot;&gt;逻辑回归实现&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;[1]《统计学习方法》&lt;br&gt;[2] AngrewNG 《机器学习》&lt;br&gt;[3] Christopher M. Bishop: Pattern Recognition and Machine Learning, chapter4.3&lt;br&gt;[4] &lt;a href=&quot;https://www.douban.com/note/323644915/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;听课笔记（第十讲）： 逻辑斯蒂回归 (台大机器学习）&lt;/a&gt;&lt;br&gt;[5] &lt;a href=&quot;http://www.tuicool.com/articles/auQFju&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逻辑回归模型(Logistic Regression, LR)基础&lt;/a&gt;&lt;br&gt;[6] &lt;a href=&quot;http://www.eas-journal.org/articles/eas/pdf/2014/02/eas1466008.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;logistic regression&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Machine Learning中，逻辑斯蒂回归（Logistic Regression）是十分经典的方法,简称LR，虽然名字叫回归，但是这是线性分类模型而不是回归模型。这里面涉及到一些知识点，包括极大似然估计，损失函数，梯度下降，正则化等&lt;!--逻辑斯特回归是对条件概率密度$P(x|C/_K)$建模的，也就是后验概率$P(C/_k)$,使用它们通过贝叶斯理论来计算后验概率$P(C/_k|x).--&gt;&lt;br&gt;这篇文章的主要目的，就是通过理论与实践相结合的方式讲解LR模型，在讲解的过程中，加深对LR的理解、相关概念的梳理和应用。这篇文章中需要一些基础的数学知识，如果我没有讲到的请自行百度。这篇文章以《统计学习方法》和AndrewNg的视频为基础，加上《PR&amp;amp;MR》以及网上的资料、论文整理而成。本人能力有限，细节处理上难免有不严谨的地方或者叙述不清的地方，请留言或者发邮件wang_qian010@163.com&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="逻辑斯蒂回退" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E9%80%80/"/>
    
      <category term="Logistic regression" scheme="http://yoursite.com/tags/Logistic-regression/"/>
    
  </entry>
  
  <entry>
    <title>c++ 迭代器</title>
    <link href="http://yoursite.com/2016/04/08/c-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/08/c-迭代器/</id>
    <published>2016-04-07T16:54:36.000Z</published>
    <updated>2016-04-07T16:59:35.238Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到c++中的迭代器，跟python中的迭代器的概念好学差不多。&lt;/p&gt;
&lt;p&gt;迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都支持递增运算的迭代器。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;迭代器-iterator-是一中检查容器内元素并遍历元素的数据类型。&quot;&gt;&lt;a href=&quot;#迭代器-iterator-是一中检查容器内元素并遍历元素的数据类型。&quot; class=&quot;headerlink&quot; title=&quot;迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。&quot;&gt;&lt;/a&gt;迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。&lt;/h1&gt;&lt;p&gt;(1) 每种容器类型都定义了自己的迭代器类型，如vector:&lt;br&gt;vector&lt;int&gt;::iterator iter;这条语句定义了一个名为iter的变量，它的数据类型是由vector&lt;int&gt;定义的iterator类型。&lt;br&gt;(2) 使用迭代器读取vector中的每一个元素：&lt;br&gt;vector&lt;int&gt; ivec(10,1);&lt;br&gt;for(vector&lt;int&gt;::iterator iter=ivec.begin();iter!=ivec.end();++iter)&lt;br&gt;{&lt;br&gt;&lt;em&gt;iter=2; //使用 &lt;/em&gt; 访问迭代器所指向的元素&lt;br&gt;}&lt;br&gt;const_iterator:&lt;br&gt;只能读取容器中的元素，而不能修改。&lt;br&gt;for(vector&lt;int&gt;::const_iterator citer=ivec.begin();citer!=ivec.end();citer++)&lt;br&gt;{&lt;br&gt;cout&amp;lt;&amp;lt;&lt;em&gt;citer;&lt;br&gt;//&lt;/em&gt;citer=3; error&lt;br&gt;}&lt;br&gt;vector&lt;int&gt;::const_iterator 和 const vector&lt;int&gt;::iterator的区别&lt;br&gt;const vector&lt;int&gt;::iterator newiter=ivec.begin();&lt;br&gt;&lt;em&gt;newiter=11; //可以修改指向容器的元素&lt;br&gt;//newiter++; //迭代器本身不能被修改&lt;br&gt;(3) iterator的算术操作：&lt;br&gt;iterator除了进行++,–操作，可以将iter+n,iter-n赋给一个新的iteraor对象。还可以使用一个iterator减去另外一个iterator.&lt;br&gt;const vector&lt;int&gt;::iterator newiter=ivec.begin();&lt;br&gt;vector&lt;int&gt;::iterator newiter2=ivec.end();&lt;br&gt;cout&amp;lt;&amp;lt;”\n”&amp;lt;&lt;newiter2-newiter; 1=&quot;&quot; 一個很典型使用vector的stl程式:=&quot;&quot; #include=&quot;&quot; &lt;vector=&quot;&quot;&gt;&lt;br&gt;2 #include &lt;iostream&gt;&lt;br&gt;3&lt;br&gt;4 using namespace std;&lt;br&gt;5&lt;br&gt;6 int main() {&lt;br&gt;7 vector&lt;int&gt; ivec;&lt;br&gt;8 ivec.push_back(1);&lt;br&gt;9 ivec.push_back(2);&lt;br&gt;10 ivec.push_back(3);&lt;br&gt;11 ivec.push_back(4);&lt;br&gt;12&lt;br&gt;13 for(vector&lt;int&gt;::iterator iter = ivec.begin();1. iter != ivec.end(); ++iter)&lt;br&gt;14 cout &amp;lt;&amp;lt; &lt;/int&gt;&lt;/int&gt;&lt;/iostream&gt;&lt;/newiter2-newiter;&gt;&lt;/int&gt;&lt;/int&gt;&lt;/em&gt;iter &amp;lt;&amp;lt; endl;&lt;br&gt;15 }&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Iterator（迭代器）模式&lt;br&gt;一、概述&lt;br&gt; Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。&lt;br&gt; 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。&lt;br&gt; 根据STL中的分类，iterator包括：&lt;br&gt;Input Iterator：只能单步向前迭代元素，不允许修改由该类迭代器引用的元素。&lt;br&gt;Output Iterator：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。&lt;br&gt;Forward Iterator：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。&lt;br&gt;Bidirectional Iterator：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。&lt;br&gt;Random Access Iterator：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。&lt;br&gt; 这五类迭代器的从属关系，如下图所示，其中箭头A→B表示，A是B的强化类型，这也说明了如果一个算法要求B，那么A也可以应用于其中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;input output&lt;br&gt;      \ /&lt;br&gt;forward&lt;br&gt;       |&lt;br&gt;bidirectional&lt;br&gt;       |&lt;br&gt;random access&lt;br&gt; 图1、五种迭代器之间的关系&lt;br&gt;    vector 和deque提供的是RandomAccessIterator，list提供的是BidirectionalIterator，set和map提供的 iterators是 ForwardIterator，关于STL中iterator迭代器的操作如下：&lt;br&gt;说明：每种迭代器均可进行包括表中前一种迭代器可进行的操作。&lt;br&gt;迭代器操作                      说明&lt;br&gt;(1)所有迭代器&lt;br&gt;p++                              后置自增迭代器&lt;br&gt;++p                              前置自增迭代器&lt;br&gt;(2)输入迭代器&lt;br&gt;&lt;em&gt;p                                 复引用迭代器，作为右值&lt;br&gt;p=p1                             将一个迭代器赋给另一个迭代器&lt;br&gt;p==p1                           比较迭代器的相等性&lt;br&gt;p!=p1                            比较迭代器的不等性&lt;br&gt;(3)输出迭代器
&lt;/em&gt;p                                 复引用迭代器，作为左值&lt;br&gt;p=p1                             将一个迭代器赋给另一个迭代器&lt;br&gt;(4)正向迭代器&lt;br&gt;提供输入输出迭代器的所有功能&lt;br&gt;(5)双向迭代器&lt;br&gt;–p                                前置自减迭代器&lt;br&gt;p–                                后置自减迭代器&lt;br&gt;(6)随机迭代器&lt;br&gt;p+=i                              将迭代器递增i位&lt;br&gt;p-=i                               将迭代器递减i位&lt;br&gt;p+i                                在p位加i位后的迭代器&lt;br&gt;p-i                                 在p位减i位后的迭代器&lt;br&gt;p[i]                                返回p位元素偏离i位的元素引用&lt;br&gt;p&lt;p1 如果迭代器p的位置在p1前，返回true，否则返回false=&quot;&quot; p&lt;=&quot;p1&quot; p的位置在p1的前面或同一位置时返回true，否则返回false=&quot;&quot; p=&quot;&quot;&gt;p1                             如果迭代器p的位置在p1后，返回true，否则返回false&lt;br&gt;p&amp;gt;=p1                           p的位置在p1的后面或同一位置时返回true，否则返回false&lt;br&gt;    只有顺序容器和关联容器支持迭代器遍历，各容器支持的迭代器的类别如下：&lt;br&gt;容器                 支持的迭代器类别            容器               支持的迭代器类别            容器                 支持的迭代器类别&lt;br&gt;vector              随机访问                      deque              随机访问                       list                   双向&lt;br&gt;set                   双向                            multiset            双向                           map                 双向&lt;br&gt;multimap          双向                             stack                不支持                        queue              不支持&lt;br&gt;priority_queue   不支持&lt;br&gt;二、结构&lt;br&gt;Iterator模式的结构如下图所示：&lt;/p1&gt;&lt;/p&gt;
&lt;p&gt;图2、Iterator模式类图示意&lt;br&gt;三、应用&lt;br&gt;    Iterator模式有三个重要的作用：&lt;br&gt;1）它支持以不同的方式遍历一个聚合.复杂的聚合可用多种方式进行遍历，如二叉树的遍历，可以采用前序、中序或后序遍历。迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可，你也可以自己定义迭代器的子类以支持新的遍历，或者可以在遍历中增加一些逻辑，如有条件的遍历等。&lt;br&gt;2）迭代器简化了聚合的接口. 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了，这样就简化了聚合的接口。&lt;br&gt;3）在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历。&lt;br&gt;4）此外，Iterator模式可以为遍历不同的聚合结构（需拥有相同的基类）提供一个统一的接口，即支持多态迭代。&lt;br&gt;    简单说来，迭代器模式也是Delegate原则的一个应用，它将对集合进行遍历的功能封装成独立的Iterator，不但简化了集合的接口，也使得修改、增 加遍历方式变得简单。从这一点讲，该模式与Bridge模式、Strategy模式有一定的相似性，但Iterator模式所讨论的问题与集合密切相关， 造成在Iterator在实现上具有一定的特殊性，具体将在示例部分进行讨论。&lt;br&gt;四、优缺点&lt;br&gt;     正如前面所说，与集合密切相关，限制了 Iterator模式的广泛使用，就个人而言，我不大认同将Iterator作为模式提出的观点，但它又确实符合模式“经常出现的特定问题的解决方案”的 特质，以至于我又不得不承认它是个模式。在一般的底层集合支持类中，我们往往不愿“避轻就重”将集合设计成集合 + Iterator 的形式，而是将遍历的功能直接交由集合完成，以免犯了“过度设计”的诟病，但是，如果我们的集合类确实需要支持多种遍历方式（仅此一点仍不一定需要考虑 Iterator模式，直接交由集合完成往往更方便），或者，为了与系统提供或使用的其它机制，如STL算法，保持一致时，Iterator模式才值得考 虑。&lt;br&gt;五、举例&lt;br&gt;    可以考虑使用两种方式来实现Iterator模式：内嵌类或者友元类。通常迭代类需访问集合类中的内部数据结构，为此，可在集合类中设置迭代类为friend class，但这不利于添加新的迭代类，因为需要修改集合类，添加friend class语句。也可以在抽象迭代类中定义protected型的存取集合类内部数据的函数，这样迭代子类就可以访问集合类数据了，这种方式比较容易添加新的迭代方式，但这种方式也存在明显的缺点：这些函数只能用于特定聚合类，并且，不可避免造成代码更加复杂。&lt;br&gt;    STL的list::iterator、deque::iterator、rbtree::iterator等采用的都是外部Iterator类的形式，虽然STL的集合类的iterator分散在各个集合类中，但由于各Iterator类具有相同的基类，保持了相同的对外的接口（包括一些traits及tags等，感兴趣者请认真阅读参考1、2），从而使得它们看起来仍然像一个整体，同时也使得应用algorithm成为可能。我们如果要扩展STL的iterator，也需要注意这一点，否则，我们扩展的iterator将可能无法应用于各algorithm。&lt;br&gt;以下是一个遍历二叉树的Iterator的例子，为了方便支持多种遍历方式，并便于遍历方式的扩展，其中还使用了Strategy模式（见笔记21）：&lt;br&gt;（注：1、虽然下面这个示例是本系列所有示例中花费我时间最多的一个，但我不得不承认，它非常不完善，感兴趣的朋友，可以考虑参考下面的参考材料将其补充完善，或提出宝贵改进意见。2、 我本想考虑将其封装成与STL风格一致的形式，使得我们遍历二叉树必须通过Iterator来进行，但由于二叉树在结构上较线性存储结构复杂，使访问必须 通过Iterator来进行，但这不可避免使得BinaryTree的访问变得异常麻烦，在具体应用中还需要认真考虑。3、以下只提供了Inorder&amp;lt;中序&amp;gt;遍历iterator的实现。）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到c++中的迭代器，跟python中的迭代器的概念好学差不多。&lt;/p&gt;
&lt;p&gt;迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都支持递增运算的迭代器。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="迭代器" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vector用法总结</title>
    <link href="http://yoursite.com/2016/04/08/vector%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/08/vector用法总结/</id>
    <published>2016-04-07T16:36:35.000Z</published>
    <updated>2016-04-07T16:38:51.418Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的vector类的时候，其中的很多方法与python中list很类似。&lt;br&gt; vector(向量): C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;     用法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.文件包含:     

 首先在程序开头处加上#include&amp;lt;vector&amp;gt;以包含所需要的类文件vector

还有一定要加上using namespace std;



2.变量声明:

     2.1 例:声明一个int向量以替代一维的数组:vector &amp;lt;int&amp;gt; a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。

     2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector &amp;lt;int *&amp;gt; a.同理想用向量代替三维数组也是一样,vector &amp;lt;int**&amp;gt;a;再往上面依此类推.



3.具体的用法以及函数调用:

3.1 如何得到向量中的元素?其用法和数组一样:

例如:

vector &amp;lt;int *&amp;gt; a

int b = 5;

a.push_back(b);//该函数下面有详解

cout&amp;lt;&amp;lt;a[0];       //输出结果为5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.push_back   在数组的最后添加一个数据&lt;br&gt;2.pop_back    去掉数组的最后一个数据&lt;br&gt;3.at                得到编号位置的数据&lt;br&gt;4.begin           得到数组头的指针&lt;br&gt;5.end             得到数组的最后一个单元+1的指针&lt;br&gt;6．front        得到数组头的引用&lt;br&gt;7.back            得到数组的最后一个单元的引用&lt;br&gt;8.max_size     得到vector最大可以是多大&lt;br&gt;9.capacity       当前vector分配的大小&lt;br&gt;10.size           当前使用数据的大小&lt;br&gt;11.resize         改变当前使用数据的大小，如果它比当前使用的大，者填充默认值&lt;br&gt;12.reserve      改变当前vecotr所分配空间的大小&lt;br&gt;13.erase         删除指针指向的数据项&lt;br&gt;14.clear          清空当前的vector&lt;br&gt;15.rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)&lt;br&gt;16.rend          将vector反转构的结束指针返回(其实就是原来的begin-1)&lt;br&gt;17.empty        判断vector是否为空&lt;br&gt;18.swap         与另一个vector交换数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   3.2  详细的函数实现功能：其中vector&amp;lt;int&amp;gt; c.

                       c.clear()         移除容器中所有数据。

                       c.empty()         判断容器是否为空。

                       c.erase(pos)        删除pos位置的数据

                       c.erase(beg,end) 删除[beg,end)区间的数据

                       c.front()         传回第一个数据。

                       c.insert(pos,elem)  在pos位置插入一个elem拷贝

                       c.pop_back()     删除最后一个数据。

                       c.push_back(elem) 在尾部加入一个数据。

                       c.resize(num)     重新设置该容器的大小

                       c.size()         回容器中实际数据的个数。

                       c.begin()           返回指向容器第一个元素的迭代器

                       c.end()             返回指向容器最后一个元素的迭代器


         4.内存管理与效率

1》使用reserve()函数提前设定容量大小，避免多次容量扩充操作导致效率低下。

  关于STL容器，最令人称赞的特性之一就是是只要不超过它们的最大大小，它们就可以自动增长到足以容纳你放进去的数据。（要知道这个最大值，只要调用名叫max_size的成员函数。）对于vector和string，如果需要更多空间，就以类似realloc的思想来增长大小。vector容器支持随机访问，因此为了提高效率，它内部使用动态数组的方式实现的。在通过 reserve() 来申请特定大小的时候总是按指数边界来增大其内部缓冲区。当进行insert或push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态的重新分配当前大小的1.5~2倍的新内存区，再把原数组的内容复制过去。所以，在一般情况下，其访问速度同一般数组，只有在重新分配发生时，其性能才会下降。正如上面的代码告诉你的那样。而进行pop_back操作时，capacity并不会因为vector容器里的元素减少而有所下降，还会维持操作之前的大小。对于vector容器来说，如果有大量的数据需要进行push_back，应当使用reserve()函数提前设定其容量大小，否则会出现许多次容量扩充操作，导致效率低下。

reserve成员函数允许你最小化必须进行的重新分配的次数，因而可以避免真分配的开销和迭代器/指针/引用失效。但在我解释reserve为什么可以那么做之前，让我简要介绍有时候令人困惑的四个相关成员函数。在标准容器中，只有vector和string提供了所有这些函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1) size()告诉你容器中有多少元素。它没有告诉你容器为它容纳的元素分配了多少内存。&lt;br&gt;(2) capacity()告诉你容器在它已经分配的内存中可以容纳多少元素。那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果你想知道一个vector或string中有多少没有被占用的内存，你必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新分配步骤。&lt;br&gt;(3) resize(Container::size_type n)强制把容器改为容纳n个元素。调用resize之后，size将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会发生重新分配。&lt;br&gt;(4) reserve(Container::size_type n)强制容器把它的容量改为至少n，提供的n不小于当前大小。这一般强迫进行一次重新分配，因为容量需要增加。（如果n小于当前容量，vector忽略它，这个调用什么都不做，string可能把它的容量减少为size()和n中大的数，但string的大小没有改变。在我的经验中，使用reserve来从一个string中修整多余容量一般不如使用“交换技巧”，那是条款17的主题。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个简介表示了只要有元素需要插入而且容器的容量不足时就会发生重新分配（包括它们维护的原始内存分配和回收，对象的拷贝和析构和迭代器、指针和引用的失效）。所以，避免重新分配的关键是使用reserve尽快把容器的容量设置为足够大，最好在容器被构造之后立刻进行。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，假定你想建立一个容纳1-1000值的vector&lt;int&gt;。没有使用reserve，你可以像这样来做：&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;vector&lt;int&gt; v;&lt;br&gt;for (int i = 1; i &amp;lt;= 1000; ++i) v.push_back(i);&lt;br&gt;在大多数STL实现中，这段代码在循环过程中将会导致2到10次重新分配。（10这个数没什么奇怪的。记住vector在重新分配发生时一般把容量翻倍，而1000约等于210。）&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;把代码改为使用reserve，我们得到这个：&lt;/p&gt;
&lt;p&gt;vector&lt;int&gt; v;&lt;br&gt;v.reserve(1000);&lt;br&gt;for (int i = 1; i &amp;lt;= 1000; ++i) v.push_back(i);&lt;br&gt;这在循环中不会发生重新分配。&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;在大小和容量之间的关系让我们可以预言什么时候插入将引起vector或string执行重新分配，而且，可以预言什么时候插入会使指向容器中的迭代器、指针和引用失效。例如，给出这段代码，&lt;/p&gt;
&lt;p&gt;string s;&lt;br&gt;…&lt;br&gt;if (s.size() &amp;lt; s.capacity()) {&lt;br&gt;s.push_back(‘x’);&lt;br&gt;}&lt;br&gt;push_back的调用不会使指向这个string中的迭代器、指针或引用失效，因为string的容量保证大于它的大小。如果不是执行push_back，代码在string的任意位置进行一个insert，我们仍然可以保证在插入期间没有发生重新分配，但是，与伴随string插入时迭代器失效的一般规则一致，所有从插入位置到string结尾的迭代器/指针/引用将失效。&lt;/p&gt;
&lt;p&gt;回到本条款的主旨，通常有两情况使用reserve来避免不必要的重新分配。第一个可用的情况是当你确切或者大约知道有多少元素将最后出现在容器中。那样的话，就像上面的vector代码，你只是提前reserve适当数量的空间。第二种情况是保留你可能需要的最大的空间，然后，一旦你添加完全部数据，修整掉任何多余的容量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2》使用“交换技巧”来修整vector过剩空间/内存

有一种方法来把它从曾经最大的容量减少到它现在需要的容量。这样减少容量的方法常常被称为“收缩到合适（shrink to fit）”。该方法只需一条语句：vector&amp;lt;int&amp;gt;(ivec).swap(ivec);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表达式vector&lt;int&gt;(ivec)建立一个临时vector，它是ivec的一份拷贝：vector的拷贝构造函数做了这个工作。但是，vector的拷贝构造函数只分配拷贝的元素需要的内存，所以这个临时vector没有多余的容量。然后我们让临时vector和ivec交换数据，这时我们完成了，ivec只有临时变量的修整过的容量，而这个临时变量则持有了曾经在ivec中的没用到的过剩容量。在这里（这个语句结尾），临时vector被销毁，因此释放了以前ivec使用的内存，收缩到合适。&lt;/int&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3》用swap方法强行释放STL Vector所占内存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;template &amp;lt; class T&amp;gt; void ClearVector( vector&lt;t&gt;&amp;amp; v )&lt;br&gt;{&lt;br&gt;    vector&lt;t&gt;vtTemp;&lt;br&gt;    vtTemp.swap( v );&lt;br&gt;}&lt;br&gt;如&lt;br&gt;    vector&lt;int&gt; v ;&lt;br&gt;    nums.push_back(1);&lt;br&gt;    nums.push_back(3);&lt;br&gt;    nums.push_back(2);&lt;br&gt;    nums.push_back(4);&lt;br&gt;    vector&lt;int&gt;().swap(v);&lt;/int&gt;&lt;/int&gt;&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 或者v.swap(vector&lt;int&gt;()); &lt;/int&gt;&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;或者{ std::vector&lt;int&gt; tmp = v;   v.swap(tmp);   }; //加大括号{ }是让tmp退出{ }时自动析构&lt;/int&gt;&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;5.Vector 内存管理成员函数的行为测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C++ STL的vector使用非常广泛，但是对其内存的管理模型一直有多种猜测，下面用实例代码测试来了解其内存管理方式，测试代码如下：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;
&lt;p&gt;#include &lt;vector&gt;&lt;br&gt;using namespace std;&lt;/vector&gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;br&gt;{&lt;br&gt;vector&lt;int&gt; iVec;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //1个元素， 容器容量为1&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;iVec.push_back(1);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //2个元素， 容器容量为2&lt;/p&gt;
&lt;p&gt;iVec.push_back(2);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //3个元素， 容器容量为4&lt;/p&gt;
&lt;p&gt;iVec.push_back(3);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //4个元素， 容器容量为4&lt;/p&gt;
&lt;p&gt;iVec.push_back(4);&lt;br&gt;iVec.push_back(5);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //5个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(6);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //6个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(7);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //7个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(8);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //8个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(9);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //9个元素， 容器容量为16&lt;br&gt;/&lt;em&gt; vs2005/8 容量增长不是翻倍的，如&lt;br&gt;    9个元素   容量9&lt;br&gt;    10个元素 容量13 &lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试effective stl中的特殊的交换 swap() &lt;/em&gt;/&lt;br&gt;cout &amp;lt;&amp;lt; “当前vector 的大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “当前vector 的容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl;&lt;br&gt;vector&lt;int&gt;(iVec).swap(iVec);&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;cout &amp;lt;&amp;lt; “临时的vector&lt;int&gt;对象 的大小为: “ &amp;lt;&amp;lt; (vector&lt;int&gt;(iVec)).size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “临时的vector&lt;int&gt;对象 的容量为: “ &amp;lt;&amp;lt; (vector&lt;int&gt;(iVec)).capacity() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “交换后，当前vector 的大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “交换后，当前vector 的容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;return 0;&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;6.vector的其他成员函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c.assign(beg,end)：将[beg; end)区间中的数据赋值给c。
c.assign(n,elem)：将n个elem的拷贝赋值给c。 
c.at(idx)：传回索引idx所指的数据，如果idx越界，抛出out_of_range。 
c.back()：传回最后一个数据，不检查这个数据是否存在。
c.front()：传回地一个数据。 
get_allocator：使用构造函数返回一个拷贝。 
c.rbegin()：传回一个逆向队列的第一个数据。 
c.rend()：传回一个逆向队列的最后一个数据的下一个位置。 
c.~ vector &amp;lt;Elem&amp;gt;()：销毁所有数据，释放内存。    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.备注:在用vector的过程中的一些问题,特此列出讨论:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1)

     vector &amp;lt;int &amp;gt; a;

     int  b = 5;

     a.push_back(b);

     此时若对b另外赋值时不会影响a[0]的值

 2)

     vector &amp;lt;int*&amp;gt; a;
      int *b;
      b= new int[4];
      b[0]=0;
      b[1]=1;
      b[2]=2;
      a.push_back(b);
      delete b;          //释放b的地址空间
      for(int i=0 ; i &amp;lt;3 ; i++)
      {
            cout&amp;lt;&amp;lt;a[0][i]&amp;lt;&amp;lt;endl;
      }

      此时输出的值并不是一开始b数组初始化的值,而是一些无法预计的值.

     分析:根据1) 2)的结果,可以想到,在1)中,  往a向量中压入的是b的值,即a[0]=b,此时a[0]和b是存储在两个不同的地址中的.因此改变b的值不会影响a[0];而在2)中,因为是把一个地址(指针)压入向量a,即a[0]=b,因此释放了b的地址也就释放了a[0]的地址,因此a[0]数组中存放的数值也就不得而知了.   
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的vector类的时候，其中的很多方法与python中list很类似。&lt;br&gt; vector(向量): C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>c++ string类的用法总结</title>
    <link href="http://yoursite.com/2016/04/08/c-string%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/08/c-string类的用法总结/</id>
    <published>2016-04-07T16:14:15.000Z</published>
    <updated>2016-04-07T16:33:10.118Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的string类的时候，其中的很多方法与python中list很类似。&lt;br&gt;要想使用标准C++中string类，必须要包含&lt;/p&gt;
&lt;p&gt;#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件&lt;/string.h&gt;&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;
&lt;p&gt;using  std::string;&lt;/p&gt;
&lt;p&gt;using  std::wstring;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;或&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。&lt;/p&gt;
&lt;p&gt;string和wstring的用法是一样的，以下只用string作介绍：&lt;/p&gt;
&lt;h1 id=&quot;string类的构造函数：&quot;&gt;&lt;a href=&quot;#string类的构造函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的构造函数：&quot;&gt;&lt;/a&gt;string类的构造函数：&lt;/h1&gt;&lt;p&gt;string(const char *s);    //用c字符串s初始化&lt;br&gt;string(int n,char c);     //用n个字符c初始化&lt;br&gt;此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；&lt;/p&gt;
&lt;h1 id=&quot;string类的字符操作：&quot;&gt;&lt;a href=&quot;#string类的字符操作：&quot; class=&quot;headerlink&quot; title=&quot;string类的字符操作：&quot;&gt;&lt;/a&gt;string类的字符操作：&lt;/h1&gt;&lt;p&gt;const char &amp;amp;operator&lt;a href=&quot;int n&quot;&gt;&lt;/a&gt;const;&lt;br&gt;const char &amp;amp;at(int n)const;&lt;br&gt;char &amp;amp;operator&lt;a href=&quot;int n&quot;&gt;&lt;/a&gt;;&lt;br&gt;char &amp;amp;at(int n);&lt;br&gt;operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。&lt;br&gt;const char &lt;em&gt;data()const;//返回一个非null终止的c字符数组&lt;br&gt;const char &lt;/em&gt;c_str()const;//返回一个以null终止的c字符串&lt;br&gt;int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目&lt;/p&gt;
&lt;h1 id=&quot;string的特性描述&quot;&gt;&lt;a href=&quot;#string的特性描述&quot; class=&quot;headerlink&quot; title=&quot;string的特性描述:&quot;&gt;&lt;/a&gt;string的特性描述:&lt;/h1&gt;&lt;p&gt;int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）&lt;br&gt;int max_size()const;    //返回string对象中可存放的最大字符串的长度&lt;br&gt;int size()const;        //返回当前字符串的大小&lt;br&gt;int length()const;       //返回当前字符串的长度&lt;br&gt;bool empty()const;        //当前字符串是否为空&lt;br&gt;void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分&lt;/p&gt;
&lt;h1 id=&quot;string类的输入输出操作&quot;&gt;&lt;a href=&quot;#string类的输入输出操作&quot; class=&quot;headerlink&quot; title=&quot;string类的输入输出操作:&quot;&gt;&lt;/a&gt;string类的输入输出操作:&lt;/h1&gt;&lt;p&gt;string类重载运算符operator&amp;gt;&amp;gt;用于输入，同样重载运算符operator&amp;lt;&amp;lt;用于输出操作。&lt;br&gt;函数getline(istream &amp;amp;in,string &amp;amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。&lt;/p&gt;
&lt;h1 id=&quot;string的赋值：&quot;&gt;&lt;a href=&quot;#string的赋值：&quot; class=&quot;headerlink&quot; title=&quot;string的赋值：&quot;&gt;&lt;/a&gt;string的赋值：&lt;/h1&gt;&lt;p&gt;string &amp;amp;operator=(const string &amp;amp;s);//把字符串s赋给当前字符串&lt;br&gt;string &amp;amp;assign(const char &lt;em&gt;s);//用c类型字符串s赋值&lt;br&gt;string &amp;amp;assign(const char &lt;/em&gt;s,int n);//用c字符串s开始的n个字符赋值&lt;br&gt;string &amp;amp;assign(const string &amp;amp;s);//把字符串s赋给当前字符串&lt;br&gt;string &amp;amp;assign(int n,char c);//用n个字符c赋值给当前字符串&lt;br&gt;string &amp;amp;assign(const string &amp;amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串&lt;br&gt;string &amp;amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串&lt;/p&gt;
&lt;h1 id=&quot;string的连接：&quot;&gt;&lt;a href=&quot;#string的连接：&quot; class=&quot;headerlink&quot; title=&quot;string的连接：&quot;&gt;&lt;/a&gt;string的连接：&lt;/h1&gt;&lt;p&gt;string &amp;amp;operator+=(const string &amp;amp;s);//把字符串s连接到当前字符串的结尾&lt;br&gt;string &amp;amp;append(const char &lt;em&gt;s);            //把c类型字符串s连接到当前字符串结尾&lt;br&gt;string &amp;amp;append(const char &lt;/em&gt;s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾&lt;br&gt;string &amp;amp;append(const string &amp;amp;s);    //同operator+=()&lt;br&gt;string &amp;amp;append(const string &amp;amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾&lt;br&gt;string &amp;amp;append(int n,char c);        //在当前字符串结尾添加n个字符c&lt;br&gt;string &amp;amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾&lt;/p&gt;
&lt;h1 id=&quot;string的比较：&quot;&gt;&lt;a href=&quot;#string的比较：&quot; class=&quot;headerlink&quot; title=&quot;string的比较：&quot;&gt;&lt;/a&gt;string的比较：&lt;/h1&gt;&lt;p&gt;bool operator==(const string &amp;amp;s1,const string &amp;amp;s2)const;//比较两个字符串是否相等&lt;br&gt;运算符”&amp;gt;”,”&amp;lt;”,”&amp;gt;=”,”&amp;lt;=”,”!=”均被重载用于字符串的比较；&lt;br&gt;int compare(const string &amp;amp;s) const;//比较当前字符串和s的大小&lt;br&gt;int compare(int pos, int n,const string &amp;amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小&lt;br&gt;int compare(int pos, int n,const string &amp;amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//pos2开始的n2个字符组成的字符串的大小&lt;br&gt;int compare(const char &lt;em&gt;s) const;&lt;br&gt;int compare(int pos, int n,const char &lt;/em&gt;s) const;&lt;br&gt;int compare(int pos, int n,const char *s, int pos2) const;&lt;br&gt;compare函数在&amp;gt;时返回1，&amp;lt;时返回-1，==时返回0  &lt;/p&gt;
&lt;h1 id=&quot;string的子串：&quot;&gt;&lt;a href=&quot;#string的子串：&quot; class=&quot;headerlink&quot; title=&quot;string的子串：&quot;&gt;&lt;/a&gt;string的子串：&lt;/h1&gt;&lt;p&gt;string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串&lt;/p&gt;
&lt;h1 id=&quot;string的交换：&quot;&gt;&lt;a href=&quot;#string的交换：&quot; class=&quot;headerlink&quot; title=&quot;string的交换：&quot;&gt;&lt;/a&gt;string的交换：&lt;/h1&gt;&lt;p&gt;void swap(string &amp;amp;s2);    //交换当前字符串与s2的值&lt;/p&gt;
&lt;h1 id=&quot;string类的查找函数：&quot;&gt;&lt;a href=&quot;#string类的查找函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的查找函数：&quot;&gt;&lt;/a&gt;string类的查找函数：&lt;/h1&gt;&lt;p&gt;int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置&lt;br&gt;int find(const char &lt;em&gt;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置&lt;br&gt;int find(const char &lt;/em&gt;s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置&lt;br&gt;int find(const string &amp;amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置&lt;br&gt;//查找成功时返回所在位置，失败返回string::npos的值&lt;br&gt;int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置&lt;br&gt;int rfind(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int rfind(const char &lt;/em&gt;s, int pos, int n = npos) const;&lt;br&gt;int rfind(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值&lt;br&gt;int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置&lt;br&gt;int find_first_of(const char &lt;em&gt;s, int pos = 0) const;&lt;br&gt;int find_first_of(const char &lt;/em&gt;s, int pos, int n) const;&lt;br&gt;int find_first_of(const string &amp;amp;s,int pos = 0) const;&lt;br&gt;//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos&lt;br&gt;int find_first_not_of(char c, int pos = 0) const;&lt;br&gt;int find_first_not_of(const char &lt;em&gt;s, int pos = 0) const;&lt;br&gt;int find_first_not_of(const char &lt;/em&gt;s, int pos,int n) const;&lt;br&gt;int find_first_not_of(const string &amp;amp;s,int pos = 0) const;&lt;br&gt;//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos&lt;br&gt;int find_last_of(char c, int pos = npos) const;&lt;br&gt;int find_last_of(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int find_last_of(const char &lt;/em&gt;s, int pos, int n = npos) const;&lt;br&gt;int find_last_of(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;int find_last_not_of(char c, int pos = npos) const;&lt;br&gt;int find_last_not_of(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int find_last_not_of(const char &lt;/em&gt;s, int pos, int n) const;&lt;br&gt;int find_last_not_of(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找&lt;/p&gt;
&lt;h1 id=&quot;string类的替换函数：&quot;&gt;&lt;a href=&quot;#string类的替换函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的替换函数：&quot;&gt;&lt;/a&gt;string类的替换函数：&lt;/h1&gt;&lt;p&gt;string &amp;amp;replace(int p0, int n0,const char &lt;em&gt;s);//删除从p0开始的n0个字符，然后在p0处插入串s&lt;br&gt;string &amp;amp;replace(int p0, int n0,const char &lt;/em&gt;s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符&lt;br&gt;string &amp;amp;replace(int p0, int n0,const string &amp;amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s&lt;br&gt;string &amp;amp;replace(int p0, int n0,const string &amp;amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符&lt;br&gt;string &amp;amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const char &lt;em&gt;s);//把[first0，last0）之间的部分替换为字符串s&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const char &lt;/em&gt;s, int n);//把[first0，last0）之间的部分替换为s的前n个字符&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const string &amp;amp;s);//把[first0，last0）之间的部分替换为串s&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串&lt;/p&gt;
&lt;h1 id=&quot;string类的插入函数：&quot;&gt;&lt;a href=&quot;#string类的插入函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的插入函数：&quot;&gt;&lt;/a&gt;string类的插入函数：&lt;/h1&gt;&lt;p&gt;string &amp;amp;insert(int p0, const char &lt;em&gt;s);&lt;br&gt;string &amp;amp;insert(int p0, const char &lt;/em&gt;s, int n);&lt;br&gt;string &amp;amp;insert(int p0,const string &amp;amp;s);&lt;br&gt;string &amp;amp;insert(int p0,const string &amp;amp;s, int pos, int n);&lt;br&gt;//前4个函数在p0位置插入字符串s中pos开始的前n个字符&lt;br&gt;string &amp;amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c&lt;br&gt;iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置&lt;br&gt;void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符&lt;br&gt;void insert(iterator it, int n, char c);//在it处插入n个字符c&lt;/p&gt;
&lt;h1 id=&quot;string类的删除函数&quot;&gt;&lt;a href=&quot;#string类的删除函数&quot; class=&quot;headerlink&quot; title=&quot;string类的删除函数&quot;&gt;&lt;/a&gt;string类的删除函数&lt;/h1&gt;&lt;p&gt;iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置&lt;br&gt;iterator erase(it&lt;img src=&quot;http://&quot; alt=&quot;&quot;&gt;erator it);//删除it指向的字符，返回删除后迭代器的位置&lt;br&gt;string &amp;amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串&lt;/p&gt;
&lt;h1 id=&quot;string类的迭代器处理：&quot;&gt;&lt;a href=&quot;#string类的迭代器处理：&quot; class=&quot;headerlink&quot; title=&quot;string类的迭代器处理：&quot;&gt;&lt;/a&gt;string类的迭代器处理：&lt;/h1&gt;&lt;p&gt;string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。&lt;br&gt;用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：&lt;br&gt;const_iterator begin()const;&lt;br&gt;iterator begin();                //返回string的起始位置&lt;br&gt;const_iterator end()const;&lt;br&gt;iterator end();                    //返回string的最后一个字符后面的位置&lt;br&gt;const_iterator rbegin()const;&lt;br&gt;iterator rbegin();                //返回string的最后一个字符的位置&lt;br&gt;const_iterator rend()const;&lt;br&gt;iterator rend();                    //返回string第一个字符位置的前面&lt;br&gt;rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现&lt;/p&gt;
&lt;h1 id=&quot;字符串流处理：&quot;&gt;&lt;a href=&quot;#字符串流处理：&quot; class=&quot;headerlink&quot; title=&quot;字符串流处理：&quot;&gt;&lt;/a&gt;字符串流处理：&lt;/h1&gt;&lt;p&gt;通过定义ostringstream和istringstream变量实现，#include &lt;sstream&gt;头文件中&lt;br&gt;例如：&lt;br&gt;    string input(“hello,this is a test”);&lt;br&gt;    istringstream is(input);&lt;br&gt;    string s1,s2,s3,s4;&lt;br&gt;    is&amp;gt;&amp;gt;s1&amp;gt;&amp;gt;s2&amp;gt;&amp;gt;s3&amp;gt;&amp;gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”&lt;br&gt;    ostringstream os;&lt;br&gt;    os&amp;lt;&amp;lt;s1&amp;lt;&amp;lt;s2&amp;lt;&amp;lt;s3&amp;lt;&amp;lt;s4;&lt;br&gt;    cout&amp;lt;&amp;lt;os.str();&lt;/sstream&gt;&lt;/p&gt;
&lt;h1 id=&quot;处理string对象中的字符&quot;&gt;&lt;a href=&quot;#处理string对象中的字符&quot; class=&quot;headerlink&quot; title=&quot;处理string对象中的字符&quot;&gt;&lt;/a&gt;处理string对象中的字符&lt;/h1&gt;&lt;h2 id=&quot;字符测试&quot;&gt;&lt;a href=&quot;#字符测试&quot; class=&quot;headerlink&quot; title=&quot;字符测试&quot;&gt;&lt;/a&gt;字符测试&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/akof1314/EntryImages/20091001/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;字符映射&quot;&gt;&lt;a href=&quot;#字符映射&quot; class=&quot;headerlink&quot; title=&quot;字符映射&quot;&gt;&lt;/a&gt;字符映射&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/akof1314/EntryImages/20091001/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的string类的时候，其中的很多方法与python中list很类似。&lt;br&gt;要想使用标准C++中string类，必须要包含&lt;/p&gt;
&lt;p&gt;#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件&lt;/p&gt;
&lt;p&gt;using  std::string;&lt;/p&gt;
&lt;p&gt;using  std::wstring;&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的c/c++框架和库</title>
    <link href="http://yoursite.com/2016/04/07/%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%E7%9A%84c-c-%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93/"/>
    <id>http://yoursite.com/2016/04/07/值得推荐的c-c-框架和库/</id>
    <published>2016-04-07T15:57:57.000Z</published>
    <updated>2016-04-07T16:00:31.734Z</updated>
    
    <content type="html">&lt;p&gt;【本文系外部转贴，原文地址：&lt;a href=&quot;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&lt;/a&gt;&lt;br&gt;下次造轮子前先看看现有的轮子吧&lt;/p&gt;
&lt;h1 id=&quot;值得学习的C语言开源项目&quot;&gt;&lt;a href=&quot;#值得学习的C语言开源项目&quot; class=&quot;headerlink&quot; title=&quot;值得学习的C语言开源项目&quot;&gt;&lt;/a&gt;值得学习的C语言开源项目&lt;/h1&gt;&lt;h2 id=&quot;Webbench&quot;&gt;&lt;a href=&quot;#Webbench&quot; class=&quot;headerlink&quot; title=&quot;Webbench&quot;&gt;&lt;/a&gt;Webbench&lt;/h2&gt;&lt;p&gt;Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://home.tiscali.cz/~cz210552/webbench.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-Tinyhttpd&quot;&gt;&lt;a href=&quot;#2-Tinyhttpd&quot; class=&quot;headerlink&quot; title=&quot;2. Tinyhttpd&quot;&gt;&lt;/a&gt;2. Tinyhttpd&lt;/h2&gt;&lt;p&gt;tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://sourceforge.net/projects/tinyhttpd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/tinyhttpd/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-cJSON&quot;&gt;&lt;a href=&quot;#3-cJSON&quot; class=&quot;headerlink&quot; title=&quot;3. cJSON&quot;&gt;&lt;/a&gt;3. cJSON&lt;/h2&gt;&lt;p&gt;cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。&lt;/p&gt;
&lt;p&gt;cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。&lt;/p&gt;
&lt;p&gt;项目主页:&lt;a href=&quot;http://sourceforge.net/projects/cjson/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/cjson/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-CMockery&quot;&gt;&lt;a href=&quot;#4-CMockery&quot; class=&quot;headerlink&quot; title=&quot;4. CMockery&quot;&gt;&lt;/a&gt;4. CMockery&lt;/h2&gt;&lt;p&gt;cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。&lt;/p&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;p&gt;免费且开源，google提供技术支持；&lt;br&gt;轻量级的框架，使测试更加快速简单；&lt;br&gt;避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;&lt;br&gt;并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用&lt;br&gt;下载链接：&lt;a href=&quot;http://code.google.com/p/cmockery/downloads/list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://code.google.com/p/cmockery/downloads/list&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-Libev&quot;&gt;&lt;a href=&quot;#5-Libev&quot; class=&quot;headerlink&quot; title=&quot;5. Libev&quot;&gt;&lt;/a&gt;5. Libev&lt;/h2&gt;&lt;p&gt;libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://software.schmorp.de/pkg/libev.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://software.schmorp.de/pkg/libev.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-Memcached&quot;&gt;&lt;a href=&quot;#6-Memcached&quot; class=&quot;headerlink&quot; title=&quot;6. Memcached&quot;&gt;&lt;/a&gt;6. Memcached&lt;/h2&gt;&lt;p&gt;Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://memcached.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://memcached.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;7-Lua&quot;&gt;&lt;a href=&quot;#7-Lua&quot; class=&quot;headerlink&quot; title=&quot;7. Lua&quot;&gt;&lt;/a&gt;7. Lua&lt;/h2&gt;&lt;p&gt;Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。&lt;/p&gt;
&lt;p&gt;让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.lua.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.lua.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;8-SQLite&quot;&gt;&lt;a href=&quot;#8-SQLite&quot; class=&quot;headerlink&quot; title=&quot;8. SQLite&quot;&gt;&lt;/a&gt;8. SQLite&lt;/h2&gt;&lt;p&gt;SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.sqlite.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sqlite.org/&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;9-UNIX-v6&quot;&gt;&lt;a href=&quot;#9-UNIX-v6&quot; class=&quot;headerlink&quot; title=&quot;9. UNIX v6&quot;&gt;&lt;/a&gt;9. UNIX v6&lt;/h2&gt;&lt;p&gt;UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？&lt;/p&gt;
&lt;p&gt;另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;10-NETBSD&quot;&gt;&lt;a href=&quot;#10-NETBSD&quot; class=&quot;headerlink&quot; title=&quot;10. NETBSD&quot;&gt;&lt;/a&gt;10. NETBSD&lt;/h2&gt;&lt;p&gt;NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.netbsd.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.netbsd.org/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-资源大全&quot;&gt;&lt;a href=&quot;#C-资源大全&quot; class=&quot;headerlink&quot; title=&quot;C++ 资源大全&quot;&gt;&lt;/a&gt;C++ 资源大全&lt;/h1&gt;&lt;p&gt;关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。&lt;/p&gt;
&lt;p&gt;标准库&lt;/p&gt;
&lt;p&gt;C++标准库，包括了STL容器，算法和函数等。&lt;/p&gt;
&lt;p&gt;C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。&lt;br&gt;Standard Template Library：标准模板库&lt;br&gt;C POSIX library ： POSIX系统的C标准库规范&lt;br&gt;ISO C++ Standards Committee ：C++标准委员会&lt;/p&gt;
&lt;p&gt;框架&lt;/p&gt;
&lt;p&gt;C++通用框架和库&lt;/p&gt;
&lt;p&gt;Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合&lt;br&gt;ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。&lt;br&gt;Boost ：大量通用C++库的集合。&lt;br&gt;BDE ：来自于彭博资讯实验室的开发环境。&lt;br&gt;Cinder：提供专业品质创造性编码的开源开发社区。&lt;br&gt;Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。&lt;br&gt;Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。&lt;br&gt;EASTL ：EA-STL公共部分&lt;br&gt;ffead-cpp ：企业应用程序开发框架&lt;br&gt;Folly：由Facebook开发和使用的开源C++库&lt;br&gt;JUCE ：包罗万象的C++类库，用于开发跨平台软件&lt;br&gt;libPhenom：用于构建高性能和高度可扩展性系统的事件框架。&lt;br&gt;LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO&lt;br&gt;LibU ： C语言写的多平台工具库&lt;br&gt;Loki ：C++库的设计，包括常见的设计模式和习语的实现。&lt;br&gt;MiLi ：只含头文件的小型C++库&lt;br&gt;openFrameworks ：开发C++工具包，用于创意性编码。&lt;br&gt;Qt ：跨平台的应用程序和用户界面框架&lt;br&gt;Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。&lt;br&gt;ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。&lt;br&gt;STLport：是STL具有代表性的版本&lt;br&gt;STXXL：用于额外的大型数据集的标准模板库。&lt;br&gt;Ultimate++ ：C++跨平台快速应用程序开发框架&lt;br&gt;Windows Template Library：用于开发Windows应用程序和UI组件的C++库&lt;br&gt;Yomm11 ：C++11的开放multi-methods.&lt;/p&gt;
&lt;p&gt;人工智能&lt;/p&gt;
&lt;p&gt;btsk ：游戏行为树启动器工具&lt;br&gt;Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。&lt;br&gt;Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。&lt;/p&gt;
&lt;p&gt;异步事件循环&lt;/p&gt;
&lt;p&gt;Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。&lt;br&gt;libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。&lt;br&gt;libevent ：事件通知库&lt;br&gt;libuv ：跨平台异步I/O。&lt;/p&gt;
&lt;p&gt;音频&lt;/p&gt;
&lt;p&gt;音频，声音，音乐，数字化音乐库&lt;/p&gt;
&lt;p&gt;FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。&lt;br&gt;Maximilian ：C++音频和音乐数字信号处理库&lt;br&gt;OpenAL ：开源音频库—跨平台的音频API&lt;br&gt;Opus：一个完全开放的，免版税的，高度通用的音频编解码器&lt;br&gt;Speex：免费编解码器，为Opus所废弃&lt;br&gt;Tonic： C++易用和高效的音频合成&lt;br&gt;Vorbis： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。&lt;/p&gt;
&lt;p&gt;生态学&lt;/p&gt;
&lt;p&gt;生物信息，基因组学和生物技术&lt;/p&gt;
&lt;p&gt;libsequence：用于表示和分析群体遗传学数据的C++库。&lt;br&gt;SeqAn：专注于生物数据序列分析的算法和数据结构。&lt;br&gt;Vcflib ：用于解析和处理VCF文件的C++库&lt;br&gt;Wham：直接把联想测试应用到BAM文件的基因结构变异。&lt;/p&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;p&gt;压缩和归档库&lt;/p&gt;
&lt;p&gt;bzip2：一个完全免费，免费专利和高质量的数据压缩&lt;br&gt;doboz：能够快速解压缩的压缩库&lt;br&gt;PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。&lt;br&gt;KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。&lt;br&gt;LZ4 ：非常快速的压缩算法&lt;br&gt;LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。&lt;br&gt;LZMA ：7z格式默认和通用的压缩方法。&lt;br&gt;LZMAT ：及其快速的实时无损数据压缩库&lt;br&gt;miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。&lt;br&gt;Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。&lt;br&gt;Snappy ：快速压缩和解压缩&lt;br&gt;ZLib ：非常紧凑的数据流压缩库&lt;br&gt;ZZIPlib：提供ZIP归档的读权限。&lt;/p&gt;
&lt;p&gt;并发性&lt;/p&gt;
&lt;p&gt;并发执行和多线程&lt;/p&gt;
&lt;p&gt;Boost.Compute ：用于OpenCL的C++GPU计算库&lt;br&gt;Bolt ：针对GPU进行优化的C++模板库&lt;br&gt;C++React ：用于C++11的反应性编程库&lt;br&gt;Intel TBB ：Intel线程构件块&lt;br&gt;Libclsph：基于OpenCL的GPU加速SPH流体仿真库&lt;br&gt;OpenCL ：并行编程的异构系统的开放标准&lt;br&gt;OpenMP：OpenMP API&lt;br&gt;Thrust ：类似于C++标准模板库的并行算法库&lt;br&gt;HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统&lt;br&gt;VexCL ：用于OpenCL/CUDA 的C++向量表达式模板库。&lt;/p&gt;
&lt;p&gt;容器&lt;/p&gt;
&lt;p&gt;C++ B-tree ：基于B树数据结构，实现命令内存容器的模板库&lt;br&gt;Hashmaps： C++中开放寻址哈希表算法的实现&lt;/p&gt;
&lt;p&gt;密码学&lt;/p&gt;
&lt;p&gt;Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。&lt;br&gt;BeeCrypt：&lt;br&gt;Botan： C++加密库&lt;br&gt;Crypto++：一个有关加密方案的免费的C++库&lt;br&gt;GnuPG： OpenPGP标准的完整实现&lt;br&gt;GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库&lt;br&gt;Libgcrypt&lt;br&gt;libmcrypt&lt;br&gt;LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支&lt;br&gt;LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具&lt;br&gt;libsodium：基于NaCI的加密库，固执己见，容易使用&lt;br&gt;Nettle 底层的加密库&lt;br&gt;OpenSSL ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。&lt;br&gt;Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法&lt;/p&gt;
&lt;p&gt;数据库&lt;/p&gt;
&lt;p&gt;数据库，SQL服务器，ODBC驱动程序和工具&lt;/p&gt;
&lt;p&gt;hiberlite ：用于Sqlite3的C++对象关系映射&lt;br&gt;Hiredis： 用于Redis数据库的很简单的C客户端库&lt;br&gt;LevelDB： 快速键值存储库&lt;br&gt;LMDB：符合数据库四大基本元素的嵌入键值存储&lt;br&gt;MySQL++：封装了MySql的C API的C++ 包装器&lt;br&gt;RocksDB：来自Facebook的嵌入键值的快速存储&lt;br&gt;SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。&lt;/p&gt;
&lt;p&gt;调试&lt;/p&gt;
&lt;p&gt;调试库， 内存和资源泄露检测，单元测试&lt;/p&gt;
&lt;p&gt;Boost.Test：Boost测试库&lt;br&gt;Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。&lt;br&gt;CppUnit：由JUnit移植过来的C++测试框架&lt;br&gt;CTest：CMake测试驱动程序&lt;br&gt;googletest：谷歌C++测试框架&lt;br&gt;ig-debugheap：用于跟踪内存错误的多平台调试堆&lt;br&gt;libtap：用C语言编写测试&lt;br&gt;MemTrack —用于C++跟踪内存分配&lt;br&gt;microprofile- 跨平台的网络试图分析器&lt;br&gt;minUnit ：使用C写的迷你单元测试框架，只使用了两个宏&lt;br&gt;Remotery：用于web视图的单一C文件分析器&lt;br&gt;UnitTest++：轻量级的C++单元测试框架&lt;/p&gt;
&lt;p&gt;游戏引擎&lt;/p&gt;
&lt;p&gt;Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。&lt;br&gt;Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。&lt;br&gt;Irrlicht ：C++语言编写的开源高性能的实时#D引擎&lt;br&gt;Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。&lt;/p&gt;
&lt;p&gt;图形用户界面&lt;/p&gt;
&lt;p&gt;CEGUI ： 很灵活的跨平台GUI库&lt;br&gt;FLTK ：快速，轻量级的跨平台的C++GUI工具包。&lt;br&gt;GTK+： 用于创建图形用户界面的跨平台工具包&lt;br&gt;gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。&lt;br&gt;imgui：拥有最小依赖关系的立即模式图形用户界面&lt;br&gt;libRocket ：libRocket 是一个C++ HTML/CSS 游戏接口中间件&lt;br&gt;MyGUI ：快速，灵活，简单的GUI&lt;br&gt;Ncurses：终端用户界面&lt;br&gt;QCustomPlot ：没有更多依赖关系的Qt绘图控件&lt;br&gt;Qwt ：用户与技术应用的Qt 控件&lt;br&gt;QwtPlot3D ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件&lt;br&gt;OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案&lt;br&gt;PDCurses 包含源代码和预编译库的公共图形函数库&lt;br&gt;wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序&lt;/p&gt;
&lt;p&gt;图形&lt;/p&gt;
&lt;p&gt;bgfx：跨平台的渲染库&lt;br&gt;Cairo：支持多种输出设备的2D图形库&lt;br&gt;Horde3D 一个小型的3D渲染和动画引擎&lt;br&gt;magnum C++11和OpenGL 2D/3D 图形引擎&lt;br&gt;Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）&lt;br&gt;OpenSceneGraph 具有高性能的开源3D图形工具包&lt;br&gt;Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。&lt;br&gt;Skia 用于绘制文字，图形和图像的完整的2D图形库&lt;br&gt;urho3d 跨平台的渲染和游戏引擎。&lt;/p&gt;
&lt;p&gt;图像处理&lt;/p&gt;
&lt;p&gt;Boost.GIL：通用图像库&lt;br&gt;CImg ：用于图像处理的小型开源C++工具包&lt;br&gt;CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。&lt;br&gt;FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。&lt;br&gt;GDCM：Grassroots DICOM 库&lt;br&gt;ITK：跨平台的开源图像分析系统&lt;br&gt;Magick++：ImageMagick程序的C++接口&lt;br&gt;MagickWnd：ImageMagick程序的C++接口&lt;br&gt;OpenCV ： 开源计算机视觉类库&lt;br&gt;tesseract-ocr：OCR引擎&lt;br&gt;VIGRA ：用于图像分析通用C++计算机视觉库&lt;br&gt;VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。&lt;/p&gt;
&lt;p&gt;国际化&lt;/p&gt;
&lt;p&gt;gettext ：GNU `gettext’&lt;br&gt;IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库&lt;br&gt;libiconv ：用于不同字符编码之间的编码转换库&lt;/p&gt;
&lt;p&gt;Jason&lt;/p&gt;
&lt;p&gt;frozen ： C/C++的Jason解析生成器&lt;br&gt;Jansson ：进行编解码和处理Jason数据的C语言库&lt;br&gt;jbson ：C++14中构建和迭代BSON data,和Json 文档的库&lt;br&gt;JeayeSON：非常健全的C++ JSON库，只包含头文件&lt;br&gt;JSON++ ： C++ JSON 解析器&lt;br&gt;json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少&lt;br&gt;json11 ：一个迷你的C++11 JSON库&lt;br&gt;jute ：非常简单的C++ JSON解析器&lt;br&gt;ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。&lt;br&gt;libjson：轻量级的JSON库&lt;br&gt;PicoJSON：C++中JSON解析序列化，只包含头文件&lt;br&gt;qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类&lt;br&gt;QJson：将JSON数据映射到QVariant对象的基于Qt的库&lt;br&gt;RapidJSON： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API&lt;br&gt;YAJL ：C语言中快速流JSON解析库&lt;/p&gt;
&lt;p&gt;日志&lt;/p&gt;
&lt;p&gt;Boost.Log ：设计非常模块化，并且具有扩展性&lt;br&gt;easyloggingpp：C++日志库，只包含单一的头文件。&lt;br&gt;Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。&lt;br&gt;templog：轻量级C++库，可以添加日志到你的C++应用程序中&lt;/p&gt;
&lt;p&gt;机器学习&lt;/p&gt;
&lt;p&gt;Caffe ：快速的神经网络框架&lt;br&gt;CCV ：以C语言为核心的现代计算机视觉库&lt;br&gt;mlpack ：可扩展的C++机器学习库&lt;br&gt;OpenCV：开源计算机视觉库&lt;br&gt;Recommender：使用协同过滤进行产品推荐/建议的C语言库。&lt;br&gt;SHOGUN：Shogun 机器学习工具&lt;br&gt;sofia-ml ：用于机器学习的快速增量算法套件&lt;/p&gt;
&lt;p&gt;数学&lt;/p&gt;
&lt;p&gt;Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似&lt;br&gt;blaze：高性能的C++数学库，用于密集和稀疏算法。&lt;br&gt;ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。&lt;br&gt;CGal： 高效，可靠的集合算法集合&lt;br&gt;cml ：用于游戏和图形的免费C++数学库&lt;br&gt;Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。&lt;br&gt;GMTL：数学图形模板库是一组广泛实现基本图形的工具。&lt;br&gt;GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。&lt;/p&gt;
&lt;p&gt;多媒体&lt;/p&gt;
&lt;p&gt;GStreamer ：构建媒体处理组件图形的库&lt;br&gt;LIVE555 Streaming Media ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库&lt;br&gt;libVLC ：libVLC (VLC SDK)媒体框架&lt;br&gt;QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器&lt;br&gt;SDL ：简单直控媒体层&lt;br&gt;SFML ：快速，简单的多媒体库&lt;/p&gt;
&lt;p&gt;网络&lt;/p&gt;
&lt;p&gt;ACE：C++面向对象网络变成工具包&lt;br&gt;Boost.Asio：用于网络和底层I/O编程的跨平台的C++库&lt;br&gt;Casablanca：C++ REST SDK&lt;br&gt;cpp-netlib：高级网络编程的开源库集合&lt;br&gt;Dyad.c：C语言的异步网络&lt;br&gt;libcurl :多协议文件传输库&lt;br&gt;Mongoose：非常轻量级的网络服务器&lt;br&gt;Muduo ：用于Linux多线程服务器的C++非阻塞网络库&lt;br&gt;net_skeleton ：C/C++的TCP 客户端/服务器库&lt;br&gt;nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js&lt;br&gt;Onion :C语言HTTP服务器库，其设计为轻量级，易使用。&lt;br&gt;POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。&lt;br&gt;RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。&lt;br&gt;Tuf o ：用于Qt之上的C++构建的异步Web框架。&lt;br&gt;WebSocket++ ：基于C++/Boost Aiso的websocket 客户端/服务器库&lt;br&gt;ZeroMQ ：高速，模块化的异步通信库&lt;/p&gt;
&lt;p&gt;物理学&lt;/p&gt;
&lt;p&gt;动力学仿真引擎&lt;/p&gt;
&lt;p&gt;Box2D：2D的游戏物理引擎。&lt;br&gt;Bullet ：3D的游戏物理引擎。&lt;br&gt;Chipmunk ：快速，轻量级的2D游戏物理库&lt;br&gt;LiquidFun：2D的游戏物理引擎&lt;br&gt;ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。&lt;br&gt;ofxBox2d：Box2D开源框架包装器。&lt;br&gt;Simbody ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。&lt;/p&gt;
&lt;p&gt;机器人学&lt;/p&gt;
&lt;p&gt;MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。&lt;br&gt;MRPT：移动机器人编程工具包&lt;br&gt;PCL ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。&lt;br&gt;Robotics Library (RL)： 一个独立的C++库，包括机器人动力学，运动规划和控制。&lt;br&gt;RobWork：一组C++库的集合，用于机器人系统的仿真和控制。&lt;br&gt;ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。&lt;/p&gt;
&lt;p&gt;科学计算&lt;/p&gt;
&lt;p&gt;FFTW :用一维或者多维计算DFT的C语言库。&lt;br&gt;GSL：GNU科学库。&lt;/p&gt;
&lt;p&gt;脚本&lt;/p&gt;
&lt;p&gt;ChaiScript ：用于C++的易于使用的嵌入式脚本语言。&lt;br&gt;Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。&lt;br&gt;luacxx：用于创建Lua绑定的C++ 11 API&lt;br&gt;SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器&lt;br&gt;V7：嵌入式的JavaScript 引擎。&lt;br&gt;V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。&lt;/p&gt;
&lt;p&gt;序列化&lt;/p&gt;
&lt;p&gt;Cap’n Proto ：快速数据交换格式和RPC系统。&lt;br&gt;cereal ：C++11 序列化库&lt;br&gt;FlatBuffers ：内存高效的序列化库&lt;br&gt;MessagePack ：C/C++的高效二进制序列化库，例如 JSON&lt;br&gt;protobuf ：协议缓冲，谷歌的数据交换格式。&lt;br&gt;protobuf-c ：C语言的协议缓冲实现&lt;br&gt;SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。&lt;br&gt;Thrift ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。注：原文有误，应该是 facebook 在2007年开发的，现在是 Apache 在维护&lt;/p&gt;
&lt;p&gt;视频&lt;/p&gt;
&lt;p&gt;libvpx ：VP8/VP9编码解码SDK&lt;br&gt;FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。&lt;br&gt;libde265 ：开放的h.265视频编解码器的实现。&lt;br&gt;OpenH264：开源H.364 编解码器。&lt;br&gt;Theora ：免费开源的视频压缩格式。&lt;/p&gt;
&lt;p&gt;虚拟机&lt;/p&gt;
&lt;p&gt;CarpVM：C中有趣的VM，让我们一起来看看这个。&lt;br&gt;MicroPython ：旨在实现单片机上Python3.x的实现&lt;br&gt;TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。&lt;/p&gt;
&lt;p&gt;Web应用框架&lt;/p&gt;
&lt;p&gt;Civetweb ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。&lt;br&gt;CppCMS ：免费高性能的Web开发框架（不是 CMS）.&lt;br&gt;Crow ：一个C++微型web框架（灵感来自于Python Flask）&lt;br&gt;Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。&lt;br&gt;libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。&lt;br&gt;QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。&lt;br&gt;Wt ：开发Web应用的C++库。&lt;/p&gt;
&lt;p&gt;XML&lt;/p&gt;
&lt;p&gt;XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds&lt;/p&gt;
&lt;p&gt;Expat ：用C语言编写的xml解析库&lt;br&gt;Libxml2 ：Gnome的xml C解析器和工具包&lt;br&gt;libxml++ ：C++的xml解析器&lt;br&gt;PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。&lt;br&gt;RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。&lt;br&gt;TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。&lt;br&gt;TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。&lt;br&gt;TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。&lt;br&gt;Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。&lt;/p&gt;
&lt;p&gt;多项混杂&lt;/p&gt;
&lt;p&gt;一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。&lt;/p&gt;
&lt;p&gt;C++ Format ：C++的小型，安全和快速格式化库&lt;br&gt;casacore ：从aips++ 派生的一系列C++核心库&lt;br&gt;cxx-prettyprint：用于C++容器的打印库&lt;br&gt;DynaPDF ：易于使用的PDF生成库&lt;br&gt;gcc-poison ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。&lt;br&gt;googlemock：编写和使用C++模拟类的库&lt;br&gt;HTTP Parser ：C的http请求/响应解析器&lt;br&gt;libcpuid ：用于x86 CPU检测盒特征提取的小型C库&lt;br&gt;libevil ：许可证管理器&lt;br&gt;libusb：允许移动访问USB设备的通用USB库&lt;br&gt;PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。&lt;br&gt;Remote Call Framework ：C++的进程间通信框架。&lt;br&gt;Scintilla ：开源的代码编辑控件&lt;br&gt;Serial Communication Library ：C++语言编写的跨平台，串口库。&lt;br&gt;SDS：C的简单动态字符串库&lt;br&gt;SLDR ：超轻的DNS解析器&lt;br&gt;SLRE： 超轻的正则表达式库&lt;br&gt;Stage ：移动机器人模拟器&lt;br&gt;VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。&lt;br&gt;ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。&lt;br&gt;CppVerbalExpressions ：易于使用的C++正则表达式&lt;br&gt;QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库&lt;br&gt;PHP-CPP：使用C++来构建PHP扩展的库&lt;br&gt;Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。&lt;/p&gt;
&lt;p&gt;软件&lt;/p&gt;
&lt;p&gt;用于创建开发环境的软件&lt;/p&gt;
&lt;p&gt;编译器&lt;/p&gt;
&lt;p&gt;C/C++编译器列表&lt;/p&gt;
&lt;p&gt;Clang :由苹果公司开发的&lt;br&gt;GCC：GNU编译器集合&lt;br&gt;Intel C++ Compiler ：由英特尔公司开发&lt;br&gt;LLVM ：模块化和可重用编译器和工具链技术的集合&lt;br&gt;Microsoft Visual C++ ：MSVC，由微软公司开发&lt;br&gt;Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具&lt;br&gt;TCC ：轻量级的C语言编译器&lt;/p&gt;
&lt;p&gt;在线编译器&lt;/p&gt;
&lt;p&gt;在线C/C++编译器列表&lt;/p&gt;
&lt;p&gt;codepad ：在线编译器/解释器，一个简单的协作工具&lt;br&gt;CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果&lt;br&gt;coliru ：在线编译器/shell， 支持各种C++编译器&lt;br&gt;Compiler Explorer：交互式编译器，可以进行汇编输出&lt;br&gt;CompileOnline：Linux上在线编译和执行C++程序&lt;br&gt;Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。&lt;/p&gt;
&lt;p&gt;调试器&lt;/p&gt;
&lt;p&gt;C/C++调试器列表&lt;/p&gt;
&lt;p&gt;Comparison of debuggers ：来自维基百科的调试器列表&lt;br&gt;GDB ：GNU调试器&lt;br&gt;Valgrind：内存调试，内存泄露检测，性能分析工具。&lt;/p&gt;
&lt;p&gt;集成开发环境（IDE）&lt;/p&gt;
&lt;p&gt;C/C++集成开发环境列表&lt;/p&gt;
&lt;p&gt;AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境&lt;br&gt;CLion：来自JetBrains的跨平台的C/C++的集成开发环境&lt;br&gt;Code::Blocks ：免费C，C++和Fortran的集成开发环境&lt;br&gt;CodeLite ：另一个跨平台的免费的C/C++集成开发环境&lt;br&gt;Dev-C++：可移植的C/C++/C++11集成开发环境&lt;br&gt;Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境&lt;br&gt;Geany ：轻量级的快速，跨平台的集成开发环境。&lt;br&gt;IBM VisualAge ：来自IBM的家庭计算机集成开发环境。&lt;br&gt;Irony-mode：由libclang驱动的用于Emacs的C/C++微模式&lt;br&gt;KDevelop：免费开源集成开发环境&lt;br&gt;Microsoft Visual Studio ：来自微软的集成开发环境&lt;br&gt;NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。&lt;br&gt;Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。&lt;br&gt;rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成&lt;br&gt;Xcode ：由苹果公司开发&lt;br&gt;YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。&lt;/p&gt;
&lt;p&gt;构建系统&lt;/p&gt;
&lt;p&gt;Bear ：用于为clang工具生成编译数据库的工具&lt;br&gt;Biicode：基于文件的简单依赖管理器。&lt;br&gt;CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。&lt;br&gt;CPM：基于CMake和Git的C++包管理器&lt;br&gt;FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。&lt;br&gt;Ninja ：专注于速度的小型构建系统&lt;br&gt;Scons ：使用Python scipt 配置的软件构建工具&lt;br&gt;tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。&lt;br&gt;tup：基于文件的构建系统，用于后台监控变化的文件。&lt;/p&gt;
&lt;p&gt;静态代码分析&lt;/p&gt;
&lt;p&gt;提高质量，减少瑕疵的代码分析工具列表&lt;/p&gt;
&lt;p&gt;Cppcheck ：静态C/C++代码分析工具&lt;br&gt;include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。&lt;br&gt;OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。&lt;br&gt;Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具&lt;br&gt;List of tools for static code analysis ：来自维基百科的静态代码分析工具列表&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;【本文系外部转贴，原文地址：&lt;a href=&quot;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&quot;&gt;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&lt;/a&gt;&lt;br&gt;下次造轮子前先看看现有的轮子吧&lt;/p&gt;
&lt;h1 id=&quot;值得学习的C语言开源项目&quot;&gt;&lt;a href=&quot;#值得学习的C语言开源项目&quot; class=&quot;headerlink&quot; title=&quot;值得学习的C语言开源项目&quot;&gt;&lt;/a&gt;值得学习的C语言开源项目&lt;/h1&gt;&lt;h2 id=&quot;Webbench&quot;&gt;&lt;a href=&quot;#Webbench&quot; class=&quot;headerlink&quot; title=&quot;Webbench&quot;&gt;&lt;/a&gt;Webbench&lt;/h2&gt;&lt;p&gt;Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://home.tiscali.cz/~cz210552/webbench.html&quot;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="推荐框架和库" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>const用法总结</title>
    <link href="http://yoursite.com/2016/04/07/const%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/07/const用法总结/</id>
    <published>2016-04-07T15:21:41.000Z</published>
    <updated>2016-04-07T16:39:43.906Z</updated>
    
    <content type="html">&lt;p&gt;【原文&lt;a href=&quot;http://blog.csdn.net/Eric_Jo/article/details/4138548】&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/Eric_Jo/article/details/4138548】&lt;/a&gt;&lt;br&gt;C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。&lt;br&gt;Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。&lt;/p&gt;
&lt;h1 id=&quot;Const作用&quot;&gt;&lt;a href=&quot;#Const作用&quot; class=&quot;headerlink&quot; title=&quot;Const作用&quot;&gt;&lt;/a&gt;Const作用&lt;/h1&gt;&lt;p&gt;   如下图所示：&lt;br&gt;&lt;img src=&quot;http://v2.freep.cn/3tb_160407234443rs9v512293.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Const的使用&quot;&gt;&lt;a href=&quot;#Const的使用&quot; class=&quot;headerlink&quot; title=&quot;Const的使用&quot;&gt;&lt;/a&gt;Const的使用&lt;/h1&gt;&lt;h2 id=&quot;定义常量&quot;&gt;&lt;a href=&quot;#定义常量&quot; class=&quot;headerlink&quot; title=&quot;定义常量&quot;&gt;&lt;/a&gt;定义常量&lt;/h2&gt;&lt;p&gt;(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。&lt;/p&gt;
&lt;p&gt; TYPE const ValueName = value;&lt;br&gt;     const TYPE ValueName = value;&lt;/p&gt;
&lt;p&gt;(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extend const int ValueName = value;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;指针使用CONST&quot;&gt;&lt;a href=&quot;#指针使用CONST&quot; class=&quot;headerlink&quot; title=&quot;指针使用CONST&quot;&gt;&lt;/a&gt;指针使用CONST&lt;/h2&gt;&lt;p&gt;(1)指针本身是常量不可变&lt;br&gt;     (char&lt;em&gt;) const pContent;&lt;br&gt;     const (char&lt;/em&gt;) pContent; &lt;/p&gt;
&lt;p&gt;(2)指针所指向的内容是常量不可变&lt;br&gt;     const (char) &lt;em&gt;pContent;&lt;br&gt;     (char) const &lt;/em&gt;pContent; &lt;/p&gt;
&lt;p&gt;(3)两者都不可变&lt;br&gt;      const char* const pContent; &lt;/p&gt;
&lt;p&gt;(4)还有其中区别方法，沿着&lt;em&gt;号划一条线：&lt;br&gt;如果const位于&lt;/em&gt;的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；&lt;br&gt;如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。&lt;/p&gt;
&lt;h2 id=&quot;函数中使用CONST&quot;&gt;&lt;a href=&quot;#函数中使用CONST&quot; class=&quot;headerlink&quot; title=&quot;函数中使用CONST&quot;&gt;&lt;/a&gt;函数中使用CONST&lt;/h2&gt;&lt;p&gt;(1)const修饰函数参数&lt;br&gt;a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)&lt;/p&gt;
&lt;p&gt;void function(const int Var);&lt;/p&gt;
&lt;p&gt;b.参数指针所指内容为常量不可变&lt;/p&gt;
&lt;p&gt;void function(const char* Var);&lt;/p&gt;
&lt;p&gt;c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)&lt;/p&gt;
&lt;p&gt;void function(char* const Var);&lt;/p&gt;
&lt;p&gt;d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：&lt;/p&gt;
&lt;p&gt;void function(const Class&amp;amp; Var); //引用参数在函数内不可以改变&lt;/p&gt;
&lt;p&gt;void function(const TYPE&amp;amp; Var); //引用参数在函数内为常量不可变&lt;/p&gt;
&lt;p&gt;这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.&lt;/p&gt;
&lt;p&gt;(2)const 修饰函数返回值&lt;br&gt;    const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。&lt;br&gt;    a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。&lt;br&gt;    b. const int &lt;em&gt; fun2() //调用时 const int &lt;/em&gt;pValue = fun2();&lt;br&gt;                          //我们可以把fun2()看作成一个变量，即指针内容不可变。&lt;br&gt;    c.int&lt;em&gt; const fun3()   //调用时 int &lt;/em&gt; const pValue = fun2();&lt;br&gt;                          //我们可以把fun2()看作成一个变量，即指针本身不可变。&lt;/p&gt;
&lt;p&gt;一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp;amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。&lt;/p&gt;
&lt;h2 id=&quot;类相关CONST&quot;&gt;&lt;a href=&quot;#类相关CONST&quot; class=&quot;headerlink&quot; title=&quot;类相关CONST&quot;&gt;&lt;/a&gt;类相关CONST&lt;/h2&gt;&lt;p&gt;(1)const修饰成员变量&lt;br&gt;const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。&lt;br&gt;    class A&lt;br&gt;    {&lt;br&gt;        …&lt;br&gt;        const int nValue;         //成员常量不能被修改&lt;br&gt;        …&lt;br&gt;        A(int x): nValue(x) { } ; //只能在初始化列表中赋值&lt;br&gt;     } &lt;/p&gt;
&lt;p&gt;(2)const修饰成员函数&lt;br&gt;const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。&lt;br&gt;    class A&lt;br&gt;    {&lt;br&gt;        …&lt;br&gt;       void function()const; //常成员函数, 它不改变对象的成员变量.                        &lt;/p&gt;
&lt;p&gt;//也不能调用类中任何非const成员函数。&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。&lt;/p&gt;
&lt;p&gt;a. const成员函数不被允许修改它所在对象的任何一个数据成员。&lt;/p&gt;
&lt;p&gt;b. const成员函数能够访问对象的const成员，而其他成员函数不可以。&lt;/p&gt;
&lt;p&gt;(3)const修饰类对象/对象指针/对象引用&lt;/p&gt;
&lt;p&gt;·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。&lt;/p&gt;
&lt;p&gt;·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。&lt;br&gt;例如：&lt;br&gt;class AAA&lt;br&gt;{&lt;br&gt;    void func1();&lt;br&gt;void func2() const;&lt;br&gt;}&lt;br&gt;const AAA aObj;&lt;br&gt;aObj.func1(); ×&lt;br&gt;aObj.func2(); 正确&lt;/p&gt;
&lt;p&gt;const AAA* aObj = new AAA();&lt;br&gt;aObj-&amp;gt; func1(); ×&lt;br&gt;aObj-&amp;gt; func2(); 正确&lt;/p&gt;
&lt;h1 id=&quot;将Const类型转化为非Const类型的方法&quot;&gt;&lt;a href=&quot;#将Const类型转化为非Const类型的方法&quot; class=&quot;headerlink&quot; title=&quot;将Const类型转化为非Const类型的方法&quot;&gt;&lt;/a&gt;将Const类型转化为非Const类型的方法&lt;/h1&gt;&lt;p&gt;采用const_cast 进行转换。&lt;br&gt;用法：const_cast &lt;type_id&gt;  (expression)&lt;br&gt;该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。&lt;/type_id&gt;&lt;/p&gt;
&lt;p&gt;·             常量指针被转化成非常量指针，并且仍然指向原来的对象；&lt;/p&gt;
&lt;p&gt;·             常量引用被转换成非常量引用，并且仍然指向原来的对象；&lt;/p&gt;
&lt;p&gt;·             常量对象被转换成非常量对象。&lt;/p&gt;
&lt;h1 id=&quot;使用const的一些建议&quot;&gt;&lt;a href=&quot;#使用const的一些建议&quot; class=&quot;headerlink&quot; title=&quot;使用const的一些建议&quot;&gt;&lt;/a&gt;使用const的一些建议&lt;/h1&gt;&lt;p&gt;·             要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；&lt;br&gt;·             要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题；&lt;br&gt;·             在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；&lt;br&gt;·             const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；&lt;br&gt;·             不要轻易的将函数的返回值类型定为const;&lt;br&gt;·             除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;&lt;br&gt;·             任何不会修改数据成员的函数都应该声明为const 类型。&lt;/p&gt;
&lt;h1 id=&quot;补充重要说明&quot;&gt;&lt;a href=&quot;#补充重要说明&quot; class=&quot;headerlink&quot; title=&quot;补充重要说明&quot;&gt;&lt;/a&gt;补充重要说明&lt;/h1&gt;&lt;p&gt;·             类内部的常量限制：使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式&lt;/p&gt;
&lt;p&gt;初始化的整型或枚举类型，而且必须是static和const形式。&lt;/p&gt;
&lt;p&gt;·             如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如：&lt;/p&gt;
&lt;p&gt;class A { public: A() {} private: static const int i; file://注意必须是静态的！ }；&lt;/p&gt;
&lt;p&gt;const int A::i=3;另一个很常见的方法就是初始化列表： class A { public: A(int&lt;/p&gt;
&lt;p&gt;i=0):test(i) {} private: const int i; }； 还有一种方式就是在外部初始化，&lt;/p&gt;
&lt;p&gt;·             如果在非const成员函数中，this指针只是一个类类型的；如果在const成员函数中，&lt;/p&gt;
&lt;p&gt;this指针是一个const类类型的；如果在volatile成员函数中,this指针就是一个&lt;/p&gt;
&lt;p&gt;volatile类类型的。&lt;/p&gt;
&lt;p&gt;·             new返回的指针必须是const类型的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;【原文&lt;a href=&quot;http://blog.csdn.net/Eric_Jo/article/details/4138548】&quot;&gt;http://blog.csdn.net/Eric_Jo/article/details/4138548】&lt;/a&gt;&lt;br&gt;C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。&lt;br&gt;Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。&lt;/p&gt;
&lt;h1 id=&quot;Const作用&quot;&gt;&lt;a href=&quot;#Const作用&quot; class=&quot;headerlink&quot; title=&quot;Const作用&quot;&gt;&lt;/a&gt;Const作用&lt;/h1&gt;&lt;p&gt;   如下图所示：&lt;br&gt;&lt;img src=&quot;http://v2.freep.cn/3tb_160407234443rs9v512293.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="const" scheme="http://yoursite.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>c++资源汇总</title>
    <link href="http://yoursite.com/2016/04/01/c-%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/04/01/c-资源汇总/</id>
    <published>2016-04-01T13:48:14.000Z</published>
    <updated>2016-04-01T13:49:20.579Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhixing/archive/2013/06/04/3116814.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;c++ char&lt;em&gt;, const char&lt;/em&gt;, string 的相互转换&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhixing/archive/2013/06/04/3116814.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;c++ char&lt;em&gt;, const char&lt;/em&gt;, st
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>learn to detect partially overlapping instance笔记</title>
    <link href="http://yoursite.com/2016/03/31/learn-to-detect-partially-overlapping-instance%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/31/learn-to-detect-partially-overlapping-instance笔记/</id>
    <published>2016-03-31T02:28:03.000Z</published>
    <updated>2016-03-31T08:15:35.291Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：本文的工作就是找到一副图片中某一类（细胞或人类）的所有实例。这些实例可能部分重叠或聚在一起，目前来说这对传统算法很困难，传统的方法主要是找到单个实例。&lt;br&gt;&lt;strong&gt;方法&lt;/strong&gt;：找到候选区域，然后优化全局的分类得分来找到这个选择区域，使这个选择区域满足非重叠的约束。本文新贡献是通过引入对象的元组单独的类到检测过程来扩展标准的对象检测。例如我们的检测器可以挑选含有两个或三个对象实例的区域中，而分配这样的区域适当标签。本文表明，使用结构化输出的SVM框架可以找到这个实例的区域。并且使用数构造区域图上的动态规划完成这个模型的推断。此外，这个学习只需要一个弱创新——每个实例用点表示。&lt;br&gt;&lt;strong&gt;数据&lt;/strong&gt;：荧光显微镜图像和UCSD行人。&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;大多数计算机视觉方法有两个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一类是基于独立物体识别。这类识别主要基于滑动窗口和Hough变换。这些方法有：&lt;ul&gt;
&lt;li&gt;近似非最大值抑制[3,8,14]&lt;/li&gt;
&lt;li&gt;随机匹配感兴趣部分或对象模型[9,10,24]&lt;/li&gt;
&lt;li&gt;基于区域检测[2,18,19]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二类不是检测独立实例，而是基于局部或全局上下文分析和外观描述。这些方法有：&lt;ul&gt;
&lt;li&gt;图片中物体的总体实值计数[5,12,16,22]&lt;/li&gt;
&lt;li&gt;推测每一个感兴趣区域的局部物体的真实密度[11,15]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;低重叠上述方法可以，但是高密度图像性能表现就会差很多。低密度与高密度共存的情况上述两种方法的性能并不好。这就促使我们在这里提出的方法。这个方法是简历载我们区域探测方法的基础之上的[2]。这主要方法的创新点在于能够分析输入图像，检测不同尺寸的对象（大小为1的“群”是一个特殊的情况）。通过对一组弱注释的训练图像进行训练，所提出的方法根据对象木渎的不痛那个学习不同组的大小。因此，与局部密度估计想死，这样可避免试图当它们成簇一起辨别各个对象。又不像局部密度评估，但是，该方法能够判断每个簇的中对象的数量。&lt;br&gt;与我们最初的方法[2]一样，解析过程是根据有效且精确的推理过程，这个过程检测提供一个最大的解析功能的一组非重叠的极值的区域的。学习是在一个结构化的框架，SVM执行和优化（凸上界）计数的损失。我们观察到这样的学习产生了理想的偏向喜欢最详细的解释，例如，选择最小尺寸的群体，只要对象是明显的，因为这种策略往往会提供最高的计算精度。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：本文的工作就是找到一副图片中某一类（细胞或人类）的所有实例。这些实例可能部分重叠或聚在一起，目前来说
    
    </summary>
    
      <category term="论文笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="overlapping" scheme="http://yoursite.com/tags/overlapping/"/>
    
  </entry>
  
  <entry>
    <title>部分优化算法对比</title>
    <link href="http://yoursite.com/2016/03/29/%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2016/03/29/部分优化算法对比/</id>
    <published>2016-03-29T14:46:13.000Z</published>
    <updated>2016-03-29T14:49:32.398Z</updated>
    
    <content type="html">&lt;p&gt;#部分优化算法对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度下降法，基于目标函数梯度的，算法的收敛速度是线性的，并且当问题是病态时或者问题规模较大时，收敛速度尤其慢（几乎不适用）；&lt;/li&gt;
&lt;li&gt;坐标下降法，虽然不用计算目标函数的梯度，但是其收敛速度依然很慢，因此它的适用范围也有局限；&lt;/li&gt;
&lt;li&gt;牛顿法，基于目标函数的二次阶导数（海森矩阵，二阶导数矩阵）的，其收敛速度较快，迭代次数较少，尤其是在最优值附件时，收敛速度是二次的。&lt;strong&gt;问题&lt;/strong&gt;在于当海森矩阵稠密时，每次迭代的计算量比较大时，不仅计算量大（有时大到不可计算）而且需要的存储空间也多，因此牛顿法载面对海量数据时由于每一步迭代的开销巨大而变得不适用。牛顿法在每次迭代时不恩能够综述保证海森矩阵是正定的，一旦海森矩阵不是正定，优化方向就会“跑偏”，从而使得牛顿法失效，也说明了牛顿法的鲁班性较差&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;拟牛顿法，在牛顿法的基础上引入了海森矩阵的近似矩阵，避免每次迭代都要计算海森矩阵的逆，逆牛顿法的收敛速度介于梯度下降法和牛顿法之间，是超线性的。拟牛顿法的问题也是当问题规模很大时，近似矩阵变得&lt;strong&gt;很稠密&lt;/strong&gt;，在计算和存储上也有很大的开销，因此变得不适用。用海森矩阵的逆矩阵来替代还是票矩阵，虽然每次迭代不能保证是最优的优化方向，但是近似矩阵始终是正定的，因此算法总是朝着最优值的方向载搜索。&lt;/li&gt;
&lt;li&gt;L-BFGS算法是对牛顿算法的一个改进，适合实际工程中解决大规模优化问题，L-BFGS算法的基本思想是：算法只保存并利用最近m次迭代的曲率信息来构造海森矩阵的近似距离。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#部分优化算法对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度下降法，基于目标函数梯度的，算法的收敛速度是线性的，并且当问题是病态时或者问题规模较大时，收敛速度尤其慢（几乎不适用）；&lt;/li&gt;
&lt;li&gt;坐标下降法，虽然不用计算目标函数的梯度，但是其收敛速度依然很慢，因此它的适用范围也有局限；&lt;/li&gt;
&lt;li&gt;牛顿法，基于目标函数的二次阶导数（海森矩阵，二阶导数矩阵）的，其收敛速度较快，迭代次数较少，尤其是在最优值附件时，收敛速度是二次的。&lt;strong&gt;问题&lt;/strong&gt;在于当海森矩阵稠密时，每次迭代的计算量比较大时，不仅计算量大（有时大到不可计算）而且需要的存储空间也多，因此牛顿法载面对海量数据时由于每一步迭代的开销巨大而变得不适用。牛顿法在每次迭代时不恩能够综述保证海森矩阵是正定的，一旦海森矩阵不是正定，优化方向就会“跑偏”，从而使得牛顿法失效，也说明了牛顿法的鲁班性较差
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="优化算法" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
