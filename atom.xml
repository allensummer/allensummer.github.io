<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王谦的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-08T13:59:10.751Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王谦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是机器学习</title>
    <link href="http://yoursite.com/2016/08/01/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/08/01/什么是机器学习/</id>
    <published>2016-08-01T00:00:00.000Z</published>
    <updated>2016-04-08T13:59:10.751Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　在介绍机器学习之前，我想先列几个关于机器学习的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾邮件检测：根据邮箱中的邮件，识别哪些是垃圾邮件，哪些不是。这样的模型，可以程序帮助归类垃圾邮件和非垃圾邮件。这个例子，我们应该都不陌生。&lt;/li&gt;
&lt;li&gt;信用卡欺诈检测：根据用户一个月内的信用卡交易，识别哪些交易是该用户操作的，哪些不是。这样的决策模型，可以帮助程序退还那些欺诈交易。&lt;/li&gt;
&lt;li&gt;数字识别：根据信封上手写的邮编，识别出每一个手写字符所代表的数字。这样的模型，可以帮助程序阅读和理解手写邮编，并根据地利位置分类信件。&lt;/li&gt;
&lt;li&gt;语音识别：从一个用户的话语，确定用户提出的具体要求。这样的模型，可以帮助程序能够并尝试自动填充用户需求。带有Siri系统的iPhone就有这种功能。&lt;/li&gt;
&lt;li&gt;人脸识别：根据相册中的众多数码照片，识别出那些包含某一个人的照片。这样的决策模型，可以帮助程序根据人脸管理照片。某些相机或软件，如iPhoto，就有这种功能。&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7cc829d3gw1eebxsvbwnhj20hc0d2jt6.jpg&quot; alt=&quot;人脸识别&quot;&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;产品推荐：根据一个用户的购物记录和冗长的收藏清单，识别出这其中哪些是该用户真正感兴趣，并且愿意购买的产品。这样的决策模型，可以帮助程序为客户提供建议并鼓励产品消费。登录Facebook或GooglePlus，它们就会推荐可能有关联的用户给你。&lt;/li&gt;
&lt;li&gt;医学分析：根据病人的症状和一个匿名的病人资料数据库，预测该病人可能患了什么病。这样的决策模型，可以程序为专业医疗人士提供支持。&lt;/li&gt;
&lt;li&gt;股票交易：根据一支股票现有的和以往的价格波动，判断这支股票是该建仓、持仓还是减仓。这样的决策模型，可以帮助程序为金融分析提供支持。&lt;/li&gt;
&lt;li&gt;客户细分：根据用户在试用期的的行为模式和所有用户过去的行为，识别出哪些用户会转变成该产品的付款用户，哪些不会。这样的决策模型，可以帮助程序进行用户干预，以说服用户早些付款使用或更好的参与产品试用。&lt;/li&gt;
&lt;li&gt;形状鉴定：根据用户在触摸屏幕上的手绘和一个已知的形状资料库，判断用户想描绘的形状。这样的决策模型，可以帮助程序显示该形状的理想版本，以绘制清晰的图像。iPhone应用Instaviz就能做到这样。[1]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;机器学习(Machine Learning, ML)&lt;/strong&gt;是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，主要使用&lt;strong&gt;归纳、综合而不是演绎&lt;/strong&gt;[2]&lt;/p&gt;
&lt;p&gt;关于机器学习的定义有很多，一种经常被引用的英文定义是：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.[3]&lt;/p&gt;
&lt;p&gt;上面的这个定义如何理解呢？想象一下有一个邮箱过滤程序接受到一封邮件，该程序如何判断这封邮件是不是垃圾邮件呢？首先这封邮件先观察你之前标记过是不是垃圾邮件的邮件，基于这个学习到的经验，该过滤程序为你过滤掉垃圾邮件了。在这个任务中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断邮件是不是垃圾邮件,这个&lt;strong&gt;任务T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;观察到你之前标记过是不是垃圾邮件的邮件，这个是&lt;strong&gt;经验E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正确分类垃圾邮件与非垃圾邮件的数量，这个是&lt;strong&gt;性能P&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2012/0515/151727_DtZB_260935.jpg&quot; alt=&quot;163邮箱&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;机器学习分类&quot;&gt;&lt;a href=&quot;#机器学习分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习分类&quot;&gt;&lt;/a&gt;机器学习分类&lt;/h1&gt;&lt;p&gt;从最广义的讲，任何涉及机器学习所用的方法，只要它利用了训练样本的信息，都可以认为运用了学习。实践中和有意义的机器学习都是如此困难，以至于根本无法实现猜测出一个最佳的分类判决。因此大部分的时间都运用与研究学习问题。实现一个机器学习算法设计：给定一般的模型或分类器的形式，利用训练样本去学习或评估模型的未知参数。这里的学习指用某种算法来降低训练样本的分类误差。一大类基于梯度下降的算法，能够调节分类器的参数，使它朝着能够降低误差的方向前进，目前已成为机器学习领域的主流学习算法。[4]&lt;br&gt;在一个机器学习的应用中，根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。[5]&lt;/p&gt;
&lt;h2 id=&quot;监督式学习&quot;&gt;&lt;a href=&quot;#监督式学习&quot; class=&quot;headerlink&quot; title=&quot;监督式学习&quot;&gt;&lt;/a&gt;监督式学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/7cc829d3gw1ekoj9ozt1xj208c06nq31.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常见的算法有：逻辑回归，感知机，SVM支持向量机。&lt;/p&gt;
&lt;h2 id=&quot;非监督学习&quot;&gt;&lt;a href=&quot;#非监督学习&quot; class=&quot;headerlink&quot; title=&quot;非监督学习&quot;&gt;&lt;/a&gt;非监督学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7cc829d3gw1ekoj9pp0wxj208c069mxc.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括：Apriori算法以及k-Means算法。&lt;/p&gt;
&lt;h2 id=&quot;半监督学习&quot;&gt;&lt;a href=&quot;#半监督学习&quot; class=&quot;headerlink&quot; title=&quot;半监督学习&quot;&gt;&lt;/a&gt;半监督学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/7cc829d3gw1ekoj9qcia3j208c05kq3b.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。&lt;/p&gt;
&lt;h2 id=&quot;强化学习&quot;&gt;&lt;a href=&quot;#强化学习&quot; class=&quot;headerlink&quot; title=&quot;强化学习&quot;&gt;&lt;/a&gt;强化学习&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7cc829d3gw1ekoj9r0xldj208c04wgls.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;p&gt;在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）&lt;/p&gt;
&lt;h1 id=&quot;机器学习框架&quot;&gt;&lt;a href=&quot;#机器学习框架&quot; class=&quot;headerlink&quot; title=&quot;机器学习框架&quot;&gt;&lt;/a&gt;机器学习框架&lt;/h1&gt;&lt;p&gt;在机器学习领域有很&lt;a href=&quot;http://&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;多的框架、库以及软件。比较出名的有：C++的opencv, shark等，java中weka、hadoop的mahout、spark的mllib，matlab中的LibSVM、caffe，python的scikit-learn、NLTK、theano、brain、caffe等。&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习框架、库与软件列表&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;目录（持续更新）&quot;&gt;&lt;a href=&quot;#目录（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;目录（持续更新）&quot;&gt;&lt;/a&gt;目录（持续更新）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基础知识  &lt;!--* 概率论
  * 模型评估与选择
  * 维灾难
  * 决策论
  * 信息论--&gt;&lt;/li&gt;
&lt;li&gt;概率分布  &lt;!--* 二项式分布
  * 多项式分布
  * 高斯分布
  * 指数分布族
  * 非常数分布--&gt;&lt;/li&gt;
&lt;li&gt;回归&lt;/li&gt;
&lt;li&gt;分类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/earl211/article/details/48974865&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;感知机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/08/逻辑斯蒂（Logistic-回归/#more&quot;&gt;逻辑回归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聚类&lt;/li&gt;
&lt;li&gt;时间序列&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/03/29/test/&quot;&gt;时间序列完全教程（R）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降维&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2016/04/08/LDA浅显理解/&quot;&gt;LDA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#参考资料&lt;br&gt;[1] &lt;a href=&quot;http://blog.jobbole.com/62334&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习十个实例&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://baike.baidu.com/link?url=yeJM3HqBaKfzroNnRkaFt2Uya85p822Ct2Ke6DSQQtono8-JJdfB9iBiiz3uc35WfwuN5vT2FwQgFga4eP6onq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度百科&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;https://www.coursera.org/learn/machine-learning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习&lt;/a&gt;&lt;br&gt;[4] 模式分类&lt;br&gt;[5] &lt;a href=&quot;http://blog.jobbole.com/77620/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;机器学习常见分类&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　在介绍机器学习之前，我想先列几个关于机器学习的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾邮件检测：根据邮箱中的邮件，识别哪些是垃圾邮件，哪些不是。这样的模型，可以程序帮助归类垃圾邮件和非垃圾邮件。这个例子，我们应该都不陌生。&lt;/li&gt;
&lt;li&gt;信用卡欺诈检测：根据用户一个月内的信用卡交易，识别哪些交易是该用户操作的，哪些不是。这样的决策模型，可以帮助程序退还那些欺诈交易。&lt;/li&gt;
&lt;li&gt;数字识别：根据信封上手写的邮编，识别出每一个手写字符所代表的数字。这样的模型，可以帮助程序阅读和理解手写邮编，并根据地利位置分类信件。&lt;/li&gt;
&lt;li&gt;语音识别：从一个用户的话语，确定用户提出的具体要求。这样的模型，可以帮助程序能够并尝试自动填充用户需求。带有Siri系统的iPhone就有这种功能。&lt;/li&gt;
&lt;li&gt;人脸识别：根据相册中的众多数码照片，识别出那些包含某一个人的照片。这样的决策模型，可以帮助程序根据人脸管理照片。某些相机或软件，如iPhoto，就有这种功能。&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7cc829d3gw1eebxsvbwnhj20hc0d2jt6.jpg&quot; alt=&quot;人脸识别&quot;&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LDA浅显理解</title>
    <link href="http://yoursite.com/2016/04/08/LDA%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/08/LDA浅显理解/</id>
    <published>2016-04-08T13:52:25.000Z</published>
    <updated>2016-04-08T13:57:35.991Z</updated>
    
    <content type="html">&lt;p&gt;这一段时间在看LDA主题模型，这里说一下我对LDA的理解，抛开复杂的数学、概率论、机器机器学习算法，只说思路，其他内容以后再更加详细的写。&lt;br&gt;假设有一个机器人，他想写一篇文章,每篇文章包含N个词，那么他怎么写呢？？？&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151224215521383&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Unigram-model&quot;&gt;&lt;a href=&quot;#Unigram-model&quot; class=&quot;headerlink&quot; title=&quot;Unigram model&quot;&gt;&lt;/a&gt;Unigram model&lt;/h1&gt;&lt;p&gt;科学家A一开始这么设计，先给机器人读大量的文章，这样这个机器人的大脑中会有S个词，这些词组成了词向量$W=[w_1, w_2, w_3 …… w_S]$，每一个词都有相对应的概率$P=[p(w_1), p(w_2), p(w_3) …… p(w_S)$  。&lt;br&gt;算法如下：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;for i = 1 to N:&lt;br&gt; 　　choose a word $w_i～ p(W)$ &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示即：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;$p(w) = ∏ p(w n )$&lt;br&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201209/03/1346652013_8454.PNG&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Mixture-of-unigrams&quot;&gt;&lt;a href=&quot;#Mixture-of-unigrams&quot; class=&quot;headerlink&quot; title=&quot;Mixture of unigrams&quot;&gt;&lt;/a&gt;Mixture of unigrams&lt;/h1&gt;&lt;p&gt;科学家B觉得不应该这样，他认为机器人读的这些文章分成不同的主题$Z=[z_1, z_2 …… z_t]$，每个主题的概率为$P(Z)=[p(z_1), p(z_2), …… p(z_t))]$,第i主题下又有S个高频词向量$W=[w_1, w_2, w_3 …… w_S]$，每一个词都有相对应的概率$P=[p(w_1|z_i), p(w_2|z_i), p(w_3|z_i) …… p(w_S|z_i)$。&lt;br&gt;算法描述如下：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;choose a topic $z_i～p(Z);  &lt;/p&gt;
&lt;p&gt;for i = 1 to N&lt;br&gt;　　choose a word $w_i～ p(W|z_i)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示为：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;$p(w) = ∑ p(z) ∏ p(w n | z)&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230194155151&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;也就是说按照学习到的概率选择一个Topic,按照这个Topic下词的概率选择N个词。&lt;/p&gt;
&lt;h1 id=&quot;Probabilistic-lantent-semantic-indexinal-pLSI&quot;&gt;&lt;a href=&quot;#Probabilistic-lantent-semantic-indexinal-pLSI&quot; class=&quot;headerlink&quot; title=&quot;Probabilistic lantent semantic indexinal(pLSI)&quot;&gt;&lt;/a&gt;Probabilistic lantent semantic indexinal(pLSI)&lt;/h1&gt;&lt;p&gt;科学家C（Hoffman）认为应该一篇文档可以由多个主题（topic $Z=[z_1, z_2 …… z_t]$）混合而成，每个主题的概率为$P(Z)=[p(z_1), p(z_2), …… p(z_t))]$，而每个Topic都是词汇上的概率分布$P=[p(w_1|z_i), p(w_2|z_i), p(w_3|z_i) …… p(w_S|z_i)]$，文章中的每一个词都有固定的topic。&lt;br&gt;算法描述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Choose parameter θ ～ p(θ)             #θ为选择出来的主题向量&lt;br&gt;for i = 1 to N&lt;br&gt;　　choose a topic $z_j ～ p(z|θ)$&lt;br&gt; 　　choose a word $w_k ～ p(w|z_j)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学表示即：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230193416158&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230194255120&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230200824920&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Lanton-Dirichlet-Allocation-LDA&quot;&gt;&lt;a href=&quot;#Lanton-Dirichlet-Allocation-LDA&quot; class=&quot;headerlink&quot; title=&quot;Lanton Dirichlet Allocation(LDA)&quot;&gt;&lt;/a&gt;Lanton Dirichlet Allocation(LDA)&lt;/h1&gt;&lt;p&gt;科学家D（David M. Blei）认为这个主题的概率分布、词汇的概率分布并不是固定的（与pLSA相比），应该是符合某一个分布，选取主题或词汇的时候，这个概率是动态变化的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;initialize $φ_{ni}^0$  := 1/k for all i and n&lt;br&gt;initialize $γ_i := α&lt;em&gt;i + N/k$ for all i and n&lt;br&gt;repeat&lt;br&gt;　for n = 1 to N&lt;br&gt;　　for i = 1 to k&lt;br&gt;　　　 $φ^{t+1}&lt;/em&gt;{ni} = β_{iw_n}exp(Ψ(γ_i^t ))$&lt;br&gt;　　normalize $φ&lt;em&gt;n^{t+1}$ to sum to 1.&lt;br&gt;　$γ&lt;/em&gt;{t+1} = α + ∑^N_{n=1} φ_n^{t+1}$&lt;br&gt;until convergence&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;数学公式如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201004940&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201044552&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201221551&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;上述是我理解的LDA，一个机器人想要写一篇文章，那么先按照Dirichlet分布选择出主题向量，载这个主题向量的基础上，生成词汇。&lt;br&gt;使用LDA模型进行推断的时候，是倒过来的，由文档的词汇生成主题。因此LDA常常也用来做&lt;strong&gt;降维工具&lt;/strong&gt;。使用在语义分析，图像、文本分类等等&lt;/p&gt;
&lt;h1 id=&quot;pLSA与LDA对比&quot;&gt;&lt;a href=&quot;#pLSA与LDA对比&quot; class=&quot;headerlink&quot; title=&quot;pLSA与LDA对比&quot;&gt;&lt;/a&gt;pLSA与LDA对比&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;LDA&lt;/strong&gt;：假定语料库中共有M篇文章，每篇文章下的Topic的主题分布是一个从参数为的Dirichlet先验分布中采样得到的Multinomial分布，每个Topic下的词分布是一个从参数为的Dirichlet先验分布中采样得到的Multinomial分布。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230201221551&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pLSA&lt;/strong&gt;：对于某篇文章中的第n个词，首先从该文章中出现的每个主题的Multinomial分布（主题分布）中选择或采样一个主题，然后再在这个主题对应的词的Multinomial分布（词分布）中选择或采样一个词。不断重复这个随机生成过程，直到M篇文章全部生成完成。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230200824920&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;相关知识点&quot;&gt;&lt;a href=&quot;#相关知识点&quot; class=&quot;headerlink&quot; title=&quot;相关知识点&quot;&gt;&lt;/a&gt;相关知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;gamma函数&lt;/li&gt;
&lt;li&gt;Dirichlet分布&lt;/li&gt;
&lt;li&gt;共轭先验和贝叶斯框架&lt;/li&gt;
&lt;li&gt;EM模型&lt;/li&gt;
&lt;li&gt;MCMC、Gibbs采样&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;训练和推断&quot;&gt;&lt;a href=&quot;#训练和推断&quot; class=&quot;headerlink&quot; title=&quot;训练和推断&quot;&gt;&lt;/a&gt;训练和推断&lt;/h1&gt;&lt;p&gt;对于LDA模型，有两个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;估计模型中的语料库中的主题Dirichlet分布和每个主题下的词汇的Dirichlet分布&lt;/li&gt;
&lt;li&gt;对于一篇新的文档，计算这篇文档的topic分布&lt;br&gt;训练过程：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230202705096&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;推断过程：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151230202758668&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;###参考资料&lt;br&gt;1、Blei, David M.; Ng, Andrew Y.; Jordan, Michael I. Latent Dirichlet allocation（LDA原始论文）：&lt;a href=&quot;http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf&lt;/a&gt;&lt;br&gt;2、rickjin的LDA数学八卦（力荐，本文部分图片和公式来自于此文档）&lt;br&gt;网页版：&lt;a href=&quot;http://www.flickering.cn/tag/lda/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.flickering.cn/tag/lda/&lt;/a&gt;&lt;br&gt;PDF：&lt;a href=&quot;http://emma.memect.com/t/9756da9a47744de993d8df13a26e04e38286c9bc1c5a0d2b259c4564c6613298/LDA；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://emma.memect.com/t/9756da9a47744de993d8df13a26e04e38286c9bc1c5a0d2b259c4564c6613298/LDA；&lt;/a&gt;&lt;br&gt;3、搜索背后的奥秘——浅谈语义主题计算：&lt;a href=&quot;http://www.semgle.com/search-engine-algorithms-mystery-behind-search-on-the-calculation-of-semantic-topic；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.semgle.com/search-engine-algorithms-mystery-behind-search-on-the-calculation-of-semantic-topic；&lt;/a&gt;&lt;br&gt;4、LDA的相关论文、工具库：&lt;a href=&quot;http://site.douban.com/204776/widget/notes/12599608/note/287085506/；&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://site.douban.com/204776/widget/notes/12599608/note/287085506/；&lt;/a&gt;&lt;br&gt;5、LDA实现 &lt;a href=&quot;http://www.cs.princeton.edu/~blei/topicmodeling.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cs.princeton.edu/~blei/topicmodeling.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这一段时间在看LDA主题模型，这里说一下我对LDA的理解，抛开复杂的数学、概率论、机器机器学习算法，只说思路，其他内容以后再更加详细的写。&lt;br&gt;假设有一个机器人，他想写一篇文章,每篇文章包含N个词，那么他怎么写呢？？？&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151224215521383&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="LDA" scheme="http://yoursite.com/tags/LDA/"/>
    
  </entry>
  
  <entry>
    <title>大话逻辑回归</title>
    <link href="http://yoursite.com/2016/04/08/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%EF%BC%88Logistic-%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2016/04/08/逻辑斯蒂（Logistic-回归/</id>
    <published>2016-04-08T03:49:37.000Z</published>
    <updated>2016-04-08T14:53:37.267Z</updated>
    
    <content type="html">&lt;p&gt;在Machine Learning中，逻辑斯蒂回归（Logistic Regression）是十分经典的方法,简称LR，虽然名字叫回归，但是这是线性分类模型而不是回归模型。这里面涉及到一些知识点，包括极大似然估计，损失函数，梯度下降，正则化等&lt;!--逻辑斯特回归是对条件概率密度$P(x|C/_K)$建模的，也就是后验概率$P(C/_k)$,使用它们通过贝叶斯理论来计算后验概率$P(C/_k|x).--&gt;&lt;br&gt;这篇文章的主要目的，就是通过理论与实践相结合的方式讲解LR模型，在讲解的过程中，加深对LR的理解、相关概念的梳理和应用。这篇文章中需要一些基础的数学知识，如果我没有讲到的请自行百度。这篇文章以《统计学习方法》和AndrewNg的视频为基础，加上《PR&amp;amp;MR》以及网上的资料、论文整理而成。本人能力有限，细节处理上难免有不严谨的地方或者叙述不清的地方，请留言或者发邮件wang_qian010@163.com&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;逻辑斯蒂（logistic-函数&quot;&gt;&lt;a href=&quot;#逻辑斯蒂（logistic-函数&quot; class=&quot;headerlink&quot; title=&quot;逻辑斯蒂（logistic)函数&quot;&gt;&lt;/a&gt;逻辑斯蒂（logistic)函数&lt;/h1&gt;&lt;h2 id=&quot;逻辑斯蒂函数&quot;&gt;&lt;a href=&quot;#逻辑斯蒂函数&quot; class=&quot;headerlink&quot; title=&quot;逻辑斯蒂函数&quot;&gt;&lt;/a&gt;逻辑斯蒂函数&lt;/h2&gt;&lt;p&gt;在数学界有各种各样的分布，比如Gamma分布，二项分布，高斯分布等。利用这些分布的性质，可以解决很多的问题。这里将介绍一种函数，叫逻辑斯蒂函数或逻辑斯蒂曲线，这是一种是一种S型曲线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;  设$X$是连续随机变量，$X$服从逻辑斯蒂分布是指$X$具有下列分布函数和密度函数&lt;br&gt;$$F(x) = P(X\leq x) = \frac{1}{1+e^{-(x-u）/\gamma)} }$$&lt;br&gt;$$f(x) = F’(x) = \frac{e^{-(x-u)/\gamma}}{\gamma(1+e^{-(x-u)}/\gamma)^{2}}$$&lt;br&gt;式中，$\mu$为位置参数，$\gamma$为形状参数。看到这是不是想到，高斯、二项等其他分布。均值控制位置，方差控制形状。&lt;br&gt;逻辑斯蒂分布的密度函数$f(x)和分布函数$F(x)$的图形如下图&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6cbb8645gw1ewjejmez18j20jw08dq3g.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看了逻辑斯蒂分布，我有两个疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个分布是怎么发现？&lt;/li&gt;
&lt;li&gt;在机器学习中什么用？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上网查了一下，并没有找到这个分布是怎么发现的。最早的记录是1833年，菲尔许尔斯特使用逻辑斯蒂曲线描述了人口增长速度与人口密度的关系，把数学方法引入生态学。我大一的时候参加一个数学建模入门赛的时候，就是拟合了逻辑斯特函数，模型太简单，所以就很傻很天真的看着别人载比赛喽。&lt;br&gt;到了十九世纪末，法国的社会学家塔尔德观察到，一种新思想（就比如和谐社会）的采纳率随着时间的变化遵循一种S型曲线，也有人说塔尔德实际是提出了经济增长的S型曲线。&lt;br&gt;随后的一段时间，S曲线在各个行业都大杀四方，从物种迁移数量增长到工程进展，从城市化进程到经济学的前景理论等等。&lt;br&gt;随后可能有一位天才，正在研究分类问题，猛然看到了S曲线，突然想到，咦，这个曲线(如上右图）左边随着x的变小F(x)趋近于0，右边随着想的增大F(x)趋近与一个定值，不是正好可以用来做做二分类嘛。（仅供娱乐，如有雷同纯属巧合）&lt;/p&gt;
&lt;h1 id=&quot;二项逻辑斯蒂回归模型&quot;&gt;&lt;a href=&quot;#二项逻辑斯蒂回归模型&quot; class=&quot;headerlink&quot; title=&quot;二项逻辑斯蒂回归模型&quot;&gt;&lt;/a&gt;二项逻辑斯蒂回归模型&lt;/h1&gt;&lt;p&gt;现在我们仅仅考虑二分类问题。就拿AndrewNG的讲义里面的例子，如下图所示，x表示数据点的特征——肿瘤的大小，Y为观测值——是否是恶性肿瘤。通过构建线性回归模型，如h θ (x)所示，构建线性回归模型后，即可以根据肿瘤大小，预测是否为恶性肿瘤h θ (x)≥.05为恶性，h θ (x)&amp;lt;0.5为良性。&lt;br&gt;&lt;img src=&quot;http://52opencourse.com/?qa=blob&amp;amp;qa_blobid=28151414763210940&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果上述问题使用线性分类器，效果并不好（如上图），分类效果可以用差来形容。然后你再看着这个图，是不是感觉观测值类似第一幅图？&lt;br&gt;在解决上诉问题之前，接下来我们先看看逻辑回归模型：&lt;br&gt;将逻辑回归模型定义为：&lt;br&gt;$$log\frac{\pi(X)}{1-\pi(X)}=w_1x_1+…+w_nx_p+b$$&lt;br&gt;$$=X^t\beta$$&lt;br&gt;这里&lt;br&gt;$$W=(w^1, w^2, …, w^n, b)$$&lt;/p&gt;
&lt;p&gt;$$X=(x^1, x^2, …, x^n, 1)$$&lt;/p&gt;
&lt;p&gt;$$P(Y=1|X)=\pi(X）这里的$\pi(X)%是逻辑回归中的标准表示.$$&lt;/p&gt;
&lt;p&gt;逻辑回归可以这么理解，考虑对输入X进行分类的线性函数$WX$,其至于为实数域，通过逻辑斯蒂函数，可以将线性函数$WX$转换为概率。&lt;br&gt;换一个角度，逻辑斯蒂回归模型的特点就是已经事情的发生概率是指该只见发生的概率与该事件不发生的概率的比值。一个事件的几率是p，那么该事件发生的几率是$\frac{p}{1-p}$,该事件可以理解为该事件的对数几率或logit函数是&lt;/p&gt;
&lt;p&gt;$$logit(p)=log(\frac{p}{1-p})$$&lt;/p&gt;
&lt;p&gt;经过简单推导，就可以得到标准的逻辑回归模型。&lt;br&gt;&lt;strong&gt;定义（逻辑斯蒂回归模型）&lt;/strong&gt;  二项逻辑斯蒂回归模型是如下的条件概率分布：&lt;/p&gt;
&lt;p&gt;$$P(Y=1|X) = \frac{exp(WX)}{1+exp(WX)}$$&lt;/p&gt;
&lt;p&gt;$$P(Y=0|X) = \frac{1}{1+exp(WX)}$$&lt;/p&gt;
&lt;p&gt;逻辑斯特回归模型也可以说是建立在条件概率密度$p(x|C_k)$和先验概率$P(C_k)$的基础上，使用贝叶斯理论计算后验概率密度$P(C_k|x)的模型。利用贝叶斯后验概率求解该问题，则&lt;/p&gt;
&lt;p&gt;$$P(Y=1|x) = \frac{P(x|Y=1)P(Y=1)}{p(x|Y=1)P(Y=1)+P(x|Y=0)P(Y=0)}$$&lt;br&gt;$$=\frac{1}{1+e^{ln(\frac{P(x|Y=0)P(Y=0))}{P(x|Y=1)P(Y=1)}}}$$ &lt;/p&gt;
&lt;p&gt;到这里是不是感觉后验概率$P(Y=1|x)$与逻辑斯蒂函数很像？其实从（1）式可以推导到逻辑斯蒂函数的，《PR&amp;amp;ML》这本书中借助高斯分布有一点介绍，这里就不说了。&lt;/p&gt;
&lt;h1 id=&quot;模型参数估计&quot;&gt;&lt;a href=&quot;#模型参数估计&quot; class=&quot;headerlink&quot; title=&quot;模型参数估计&quot;&gt;&lt;/a&gt;模型参数估计&lt;/h1&gt;&lt;p&gt;对于上面患病问题，对给定的数据集$T={(x^1, y^1), (x^2, y^2), .., x^N, y^N)}$$，可以应用极大私人估计模型参数，从而得到逻辑回归模型。&lt;br&gt;这里使用极大似然估计求解，极大似然估计的理解是根据现有数据，选择使模型得到现有训练集可能性最大的参数。参数估计我就直接贴出《统计学习方法》中的原文。&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/0d6d163d711f0ca0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面列出了将逻辑回归问题通过极大似然的方法转换成了最优化的问题，最优化问题有多种解决方案，这里给出使用梯度下降的完整的逻辑回归算法如下，关于最优化问题的求解请链接到&lt;a href=&quot;&quot;&gt;最优化问题(待更新）)&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://i3.piimg.com/0ddf886f38c92b17.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;正则化&quot;&gt;&lt;a href=&quot;#正则化&quot; class=&quot;headerlink&quot; title=&quot;正则化&quot;&gt;&lt;/a&gt;正则化&lt;/h1&gt;&lt;p&gt;在模型参数估计这，已经将问题变为目标函数的最优化问题。为了让降低模型的复杂度，更好的泛化，可以在使用梯度下降的时候，添加一个正则项。二分类问题的L2乘法回归最小化如下（正则化链接-等待更新）：&lt;br&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/96fe247fe9465d26af15706141dc22e598ac7826.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;同样，L1正则化逻辑回归解决的优化问题如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://scikit-learn.org/stable/_images/math/3fb9bab302e67df4a9f00b8df259d326e01837fd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;多分类问题&quot;&gt;&lt;a href=&quot;#多分类问题&quot; class=&quot;headerlink&quot; title=&quot;多分类问题&quot;&gt;&lt;/a&gt;多分类问题&lt;/h1&gt;&lt;p&gt;在实际应用中，我们常常碰见多分类问题，我们如何将逻辑回归应用到上面呢？其实这里可以这样想，N分类问题，对于每一类都可以将他转换为二分类问题：是该类和非该类，每一类的逻辑模型是：&lt;br&gt;&lt;img src=&quot;http://i4.piimg.com/f83cad9cfe6687fc.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在进行分类的时候，对每一个输入的特征向量求的该类的该类，取概率最大的分类。&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;[1]《统计学习方法》&lt;br&gt;[2] AngrewNG 《机器学习》&lt;br&gt;[3] Christopher M. Bishop: Pattern Recognition and Machine Learning, chapter4.3&lt;br&gt;[4] &lt;a href=&quot;https://www.douban.com/note/323644915/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;听课笔记（第十讲）： 逻辑斯蒂回归 (台大机器学习）&lt;/a&gt;&lt;br&gt;[5] &lt;a href=&quot;http://www.tuicool.com/articles/auQFju&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逻辑回归模型(Logistic Regression, LR)基础&lt;/a&gt;&lt;br&gt;[6] &lt;a href=&quot;http://www.eas-journal.org/articles/eas/pdf/2014/02/eas1466008.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;logistic regression&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Machine Learning中，逻辑斯蒂回归（Logistic Regression）是十分经典的方法,简称LR，虽然名字叫回归，但是这是线性分类模型而不是回归模型。这里面涉及到一些知识点，包括极大似然估计，损失函数，梯度下降，正则化等&lt;!--逻辑斯特回归是对条件概率密度$P(x|C/_K)$建模的，也就是后验概率$P(C/_k)$,使用它们通过贝叶斯理论来计算后验概率$P(C/_k|x).--&gt;&lt;br&gt;这篇文章的主要目的，就是通过理论与实践相结合的方式讲解LR模型，在讲解的过程中，加深对LR的理解、相关概念的梳理和应用。这篇文章中需要一些基础的数学知识，如果我没有讲到的请自行百度。这篇文章以《统计学习方法》和AndrewNg的视频为基础，加上《PR&amp;amp;MR》以及网上的资料、论文整理而成。本人能力有限，细节处理上难免有不严谨的地方或者叙述不清的地方，请留言或者发邮件wang_qian010@163.com&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="逻辑斯蒂回退" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E5%9B%9E%E9%80%80/"/>
    
      <category term="Logistic regression" scheme="http://yoursite.com/tags/Logistic-regression/"/>
    
  </entry>
  
  <entry>
    <title>c++ 迭代器</title>
    <link href="http://yoursite.com/2016/04/08/c-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2016/04/08/c-迭代器/</id>
    <published>2016-04-07T16:54:36.000Z</published>
    <updated>2016-04-07T16:59:35.238Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到c++中的迭代器，跟python中的迭代器的概念好学差不多。&lt;/p&gt;
&lt;p&gt;迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都支持递增运算的迭代器。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;迭代器-iterator-是一中检查容器内元素并遍历元素的数据类型。&quot;&gt;&lt;a href=&quot;#迭代器-iterator-是一中检查容器内元素并遍历元素的数据类型。&quot; class=&quot;headerlink&quot; title=&quot;迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。&quot;&gt;&lt;/a&gt;迭代器(iterator)是一中检查容器内元素并遍历元素的数据类型。&lt;/h1&gt;&lt;p&gt;(1) 每种容器类型都定义了自己的迭代器类型，如vector:&lt;br&gt;vector&lt;int&gt;::iterator iter;这条语句定义了一个名为iter的变量，它的数据类型是由vector&lt;int&gt;定义的iterator类型。&lt;br&gt;(2) 使用迭代器读取vector中的每一个元素：&lt;br&gt;vector&lt;int&gt; ivec(10,1);&lt;br&gt;for(vector&lt;int&gt;::iterator iter=ivec.begin();iter!=ivec.end();++iter)&lt;br&gt;{&lt;br&gt;&lt;em&gt;iter=2; //使用 &lt;/em&gt; 访问迭代器所指向的元素&lt;br&gt;}&lt;br&gt;const_iterator:&lt;br&gt;只能读取容器中的元素，而不能修改。&lt;br&gt;for(vector&lt;int&gt;::const_iterator citer=ivec.begin();citer!=ivec.end();citer++)&lt;br&gt;{&lt;br&gt;cout&amp;lt;&amp;lt;&lt;em&gt;citer;&lt;br&gt;//&lt;/em&gt;citer=3; error&lt;br&gt;}&lt;br&gt;vector&lt;int&gt;::const_iterator 和 const vector&lt;int&gt;::iterator的区别&lt;br&gt;const vector&lt;int&gt;::iterator newiter=ivec.begin();&lt;br&gt;&lt;em&gt;newiter=11; //可以修改指向容器的元素&lt;br&gt;//newiter++; //迭代器本身不能被修改&lt;br&gt;(3) iterator的算术操作：&lt;br&gt;iterator除了进行++,–操作，可以将iter+n,iter-n赋给一个新的iteraor对象。还可以使用一个iterator减去另外一个iterator.&lt;br&gt;const vector&lt;int&gt;::iterator newiter=ivec.begin();&lt;br&gt;vector&lt;int&gt;::iterator newiter2=ivec.end();&lt;br&gt;cout&amp;lt;&amp;lt;”\n”&amp;lt;&lt;newiter2-newiter; 1=&quot;&quot; 一個很典型使用vector的stl程式:=&quot;&quot; #include=&quot;&quot; &lt;vector=&quot;&quot;&gt;&lt;br&gt;2 #include &lt;iostream&gt;&lt;br&gt;3&lt;br&gt;4 using namespace std;&lt;br&gt;5&lt;br&gt;6 int main() {&lt;br&gt;7 vector&lt;int&gt; ivec;&lt;br&gt;8 ivec.push_back(1);&lt;br&gt;9 ivec.push_back(2);&lt;br&gt;10 ivec.push_back(3);&lt;br&gt;11 ivec.push_back(4);&lt;br&gt;12&lt;br&gt;13 for(vector&lt;int&gt;::iterator iter = ivec.begin();1. iter != ivec.end(); ++iter)&lt;br&gt;14 cout &amp;lt;&amp;lt; &lt;/int&gt;&lt;/int&gt;&lt;/iostream&gt;&lt;/newiter2-newiter;&gt;&lt;/int&gt;&lt;/int&gt;&lt;/em&gt;iter &amp;lt;&amp;lt; endl;&lt;br&gt;15 }&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Iterator（迭代器）模式&lt;br&gt;一、概述&lt;br&gt; Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。&lt;br&gt; 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。&lt;br&gt; 根据STL中的分类，iterator包括：&lt;br&gt;Input Iterator：只能单步向前迭代元素，不允许修改由该类迭代器引用的元素。&lt;br&gt;Output Iterator：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。&lt;br&gt;Forward Iterator：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。&lt;br&gt;Bidirectional Iterator：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。&lt;br&gt;Random Access Iterator：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。&lt;br&gt; 这五类迭代器的从属关系，如下图所示，其中箭头A→B表示，A是B的强化类型，这也说明了如果一个算法要求B，那么A也可以应用于其中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;input output&lt;br&gt;      \ /&lt;br&gt;forward&lt;br&gt;       |&lt;br&gt;bidirectional&lt;br&gt;       |&lt;br&gt;random access&lt;br&gt; 图1、五种迭代器之间的关系&lt;br&gt;    vector 和deque提供的是RandomAccessIterator，list提供的是BidirectionalIterator，set和map提供的 iterators是 ForwardIterator，关于STL中iterator迭代器的操作如下：&lt;br&gt;说明：每种迭代器均可进行包括表中前一种迭代器可进行的操作。&lt;br&gt;迭代器操作                      说明&lt;br&gt;(1)所有迭代器&lt;br&gt;p++                              后置自增迭代器&lt;br&gt;++p                              前置自增迭代器&lt;br&gt;(2)输入迭代器&lt;br&gt;&lt;em&gt;p                                 复引用迭代器，作为右值&lt;br&gt;p=p1                             将一个迭代器赋给另一个迭代器&lt;br&gt;p==p1                           比较迭代器的相等性&lt;br&gt;p!=p1                            比较迭代器的不等性&lt;br&gt;(3)输出迭代器
&lt;/em&gt;p                                 复引用迭代器，作为左值&lt;br&gt;p=p1                             将一个迭代器赋给另一个迭代器&lt;br&gt;(4)正向迭代器&lt;br&gt;提供输入输出迭代器的所有功能&lt;br&gt;(5)双向迭代器&lt;br&gt;–p                                前置自减迭代器&lt;br&gt;p–                                后置自减迭代器&lt;br&gt;(6)随机迭代器&lt;br&gt;p+=i                              将迭代器递增i位&lt;br&gt;p-=i                               将迭代器递减i位&lt;br&gt;p+i                                在p位加i位后的迭代器&lt;br&gt;p-i                                 在p位减i位后的迭代器&lt;br&gt;p[i]                                返回p位元素偏离i位的元素引用&lt;br&gt;p&lt;p1 如果迭代器p的位置在p1前，返回true，否则返回false=&quot;&quot; p&lt;=&quot;p1&quot; p的位置在p1的前面或同一位置时返回true，否则返回false=&quot;&quot; p=&quot;&quot;&gt;p1                             如果迭代器p的位置在p1后，返回true，否则返回false&lt;br&gt;p&amp;gt;=p1                           p的位置在p1的后面或同一位置时返回true，否则返回false&lt;br&gt;    只有顺序容器和关联容器支持迭代器遍历，各容器支持的迭代器的类别如下：&lt;br&gt;容器                 支持的迭代器类别            容器               支持的迭代器类别            容器                 支持的迭代器类别&lt;br&gt;vector              随机访问                      deque              随机访问                       list                   双向&lt;br&gt;set                   双向                            multiset            双向                           map                 双向&lt;br&gt;multimap          双向                             stack                不支持                        queue              不支持&lt;br&gt;priority_queue   不支持&lt;br&gt;二、结构&lt;br&gt;Iterator模式的结构如下图所示：&lt;/p1&gt;&lt;/p&gt;
&lt;p&gt;图2、Iterator模式类图示意&lt;br&gt;三、应用&lt;br&gt;    Iterator模式有三个重要的作用：&lt;br&gt;1）它支持以不同的方式遍历一个聚合.复杂的聚合可用多种方式进行遍历，如二叉树的遍历，可以采用前序、中序或后序遍历。迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可，你也可以自己定义迭代器的子类以支持新的遍历，或者可以在遍历中增加一些逻辑，如有条件的遍历等。&lt;br&gt;2）迭代器简化了聚合的接口. 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了，这样就简化了聚合的接口。&lt;br&gt;3）在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历。&lt;br&gt;4）此外，Iterator模式可以为遍历不同的聚合结构（需拥有相同的基类）提供一个统一的接口，即支持多态迭代。&lt;br&gt;    简单说来，迭代器模式也是Delegate原则的一个应用，它将对集合进行遍历的功能封装成独立的Iterator，不但简化了集合的接口，也使得修改、增 加遍历方式变得简单。从这一点讲，该模式与Bridge模式、Strategy模式有一定的相似性，但Iterator模式所讨论的问题与集合密切相关， 造成在Iterator在实现上具有一定的特殊性，具体将在示例部分进行讨论。&lt;br&gt;四、优缺点&lt;br&gt;     正如前面所说，与集合密切相关，限制了 Iterator模式的广泛使用，就个人而言，我不大认同将Iterator作为模式提出的观点，但它又确实符合模式“经常出现的特定问题的解决方案”的 特质，以至于我又不得不承认它是个模式。在一般的底层集合支持类中，我们往往不愿“避轻就重”将集合设计成集合 + Iterator 的形式，而是将遍历的功能直接交由集合完成，以免犯了“过度设计”的诟病，但是，如果我们的集合类确实需要支持多种遍历方式（仅此一点仍不一定需要考虑 Iterator模式，直接交由集合完成往往更方便），或者，为了与系统提供或使用的其它机制，如STL算法，保持一致时，Iterator模式才值得考 虑。&lt;br&gt;五、举例&lt;br&gt;    可以考虑使用两种方式来实现Iterator模式：内嵌类或者友元类。通常迭代类需访问集合类中的内部数据结构，为此，可在集合类中设置迭代类为friend class，但这不利于添加新的迭代类，因为需要修改集合类，添加friend class语句。也可以在抽象迭代类中定义protected型的存取集合类内部数据的函数，这样迭代子类就可以访问集合类数据了，这种方式比较容易添加新的迭代方式，但这种方式也存在明显的缺点：这些函数只能用于特定聚合类，并且，不可避免造成代码更加复杂。&lt;br&gt;    STL的list::iterator、deque::iterator、rbtree::iterator等采用的都是外部Iterator类的形式，虽然STL的集合类的iterator分散在各个集合类中，但由于各Iterator类具有相同的基类，保持了相同的对外的接口（包括一些traits及tags等，感兴趣者请认真阅读参考1、2），从而使得它们看起来仍然像一个整体，同时也使得应用algorithm成为可能。我们如果要扩展STL的iterator，也需要注意这一点，否则，我们扩展的iterator将可能无法应用于各algorithm。&lt;br&gt;以下是一个遍历二叉树的Iterator的例子，为了方便支持多种遍历方式，并便于遍历方式的扩展，其中还使用了Strategy模式（见笔记21）：&lt;br&gt;（注：1、虽然下面这个示例是本系列所有示例中花费我时间最多的一个，但我不得不承认，它非常不完善，感兴趣的朋友，可以考虑参考下面的参考材料将其补充完善，或提出宝贵改进意见。2、 我本想考虑将其封装成与STL风格一致的形式，使得我们遍历二叉树必须通过Iterator来进行，但由于二叉树在结构上较线性存储结构复杂，使访问必须 通过Iterator来进行，但这不可避免使得BinaryTree的访问变得异常麻烦，在具体应用中还需要认真考虑。3、以下只提供了Inorder&amp;lt;中序&amp;gt;遍历iterator的实现。）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到c++中的迭代器，跟python中的迭代器的概念好学差不多。&lt;/p&gt;
&lt;p&gt;迭代器的递增运算令迭代器每次移动一个元素，所有的标准库容器都支持递增运算的迭代器。&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="迭代器" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vector用法总结</title>
    <link href="http://yoursite.com/2016/04/08/vector%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/08/vector用法总结/</id>
    <published>2016-04-07T16:36:35.000Z</published>
    <updated>2016-04-07T16:38:51.418Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的vector类的时候，其中的很多方法与python中list很类似。&lt;br&gt; vector(向量): C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;     用法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.文件包含:     

 首先在程序开头处加上#include&amp;lt;vector&amp;gt;以包含所需要的类文件vector

还有一定要加上using namespace std;



2.变量声明:

     2.1 例:声明一个int向量以替代一维的数组:vector &amp;lt;int&amp;gt; a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。

     2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector &amp;lt;int *&amp;gt; a.同理想用向量代替三维数组也是一样,vector &amp;lt;int**&amp;gt;a;再往上面依此类推.



3.具体的用法以及函数调用:

3.1 如何得到向量中的元素?其用法和数组一样:

例如:

vector &amp;lt;int *&amp;gt; a

int b = 5;

a.push_back(b);//该函数下面有详解

cout&amp;lt;&amp;lt;a[0];       //输出结果为5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.push_back   在数组的最后添加一个数据&lt;br&gt;2.pop_back    去掉数组的最后一个数据&lt;br&gt;3.at                得到编号位置的数据&lt;br&gt;4.begin           得到数组头的指针&lt;br&gt;5.end             得到数组的最后一个单元+1的指针&lt;br&gt;6．front        得到数组头的引用&lt;br&gt;7.back            得到数组的最后一个单元的引用&lt;br&gt;8.max_size     得到vector最大可以是多大&lt;br&gt;9.capacity       当前vector分配的大小&lt;br&gt;10.size           当前使用数据的大小&lt;br&gt;11.resize         改变当前使用数据的大小，如果它比当前使用的大，者填充默认值&lt;br&gt;12.reserve      改变当前vecotr所分配空间的大小&lt;br&gt;13.erase         删除指针指向的数据项&lt;br&gt;14.clear          清空当前的vector&lt;br&gt;15.rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)&lt;br&gt;16.rend          将vector反转构的结束指针返回(其实就是原来的begin-1)&lt;br&gt;17.empty        判断vector是否为空&lt;br&gt;18.swap         与另一个vector交换数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   3.2  详细的函数实现功能：其中vector&amp;lt;int&amp;gt; c.

                       c.clear()         移除容器中所有数据。

                       c.empty()         判断容器是否为空。

                       c.erase(pos)        删除pos位置的数据

                       c.erase(beg,end) 删除[beg,end)区间的数据

                       c.front()         传回第一个数据。

                       c.insert(pos,elem)  在pos位置插入一个elem拷贝

                       c.pop_back()     删除最后一个数据。

                       c.push_back(elem) 在尾部加入一个数据。

                       c.resize(num)     重新设置该容器的大小

                       c.size()         回容器中实际数据的个数。

                       c.begin()           返回指向容器第一个元素的迭代器

                       c.end()             返回指向容器最后一个元素的迭代器


         4.内存管理与效率

1》使用reserve()函数提前设定容量大小，避免多次容量扩充操作导致效率低下。

  关于STL容器，最令人称赞的特性之一就是是只要不超过它们的最大大小，它们就可以自动增长到足以容纳你放进去的数据。（要知道这个最大值，只要调用名叫max_size的成员函数。）对于vector和string，如果需要更多空间，就以类似realloc的思想来增长大小。vector容器支持随机访问，因此为了提高效率，它内部使用动态数组的方式实现的。在通过 reserve() 来申请特定大小的时候总是按指数边界来增大其内部缓冲区。当进行insert或push_back等增加元素的操作时，如果此时动态数组的内存不够用，就要动态的重新分配当前大小的1.5~2倍的新内存区，再把原数组的内容复制过去。所以，在一般情况下，其访问速度同一般数组，只有在重新分配发生时，其性能才会下降。正如上面的代码告诉你的那样。而进行pop_back操作时，capacity并不会因为vector容器里的元素减少而有所下降，还会维持操作之前的大小。对于vector容器来说，如果有大量的数据需要进行push_back，应当使用reserve()函数提前设定其容量大小，否则会出现许多次容量扩充操作，导致效率低下。

reserve成员函数允许你最小化必须进行的重新分配的次数，因而可以避免真分配的开销和迭代器/指针/引用失效。但在我解释reserve为什么可以那么做之前，让我简要介绍有时候令人困惑的四个相关成员函数。在标准容器中，只有vector和string提供了所有这些函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1) size()告诉你容器中有多少元素。它没有告诉你容器为它容纳的元素分配了多少内存。&lt;br&gt;(2) capacity()告诉你容器在它已经分配的内存中可以容纳多少元素。那是容器在那块内存中总共可以容纳多少元素，而不是还可以容纳多少元素。如果你想知道一个vector或string中有多少没有被占用的内存，你必须从capacity()中减去size()。如果size和capacity返回同样的值，容器中就没有剩余空间了，而下一次插入（通过insert或push_back等）会引发上面的重新分配步骤。&lt;br&gt;(3) resize(Container::size_type n)强制把容器改为容纳n个元素。调用resize之后，size将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入之前会发生重新分配。&lt;br&gt;(4) reserve(Container::size_type n)强制容器把它的容量改为至少n，提供的n不小于当前大小。这一般强迫进行一次重新分配，因为容量需要增加。（如果n小于当前容量，vector忽略它，这个调用什么都不做，string可能把它的容量减少为size()和n中大的数，但string的大小没有改变。在我的经验中，使用reserve来从一个string中修整多余容量一般不如使用“交换技巧”，那是条款17的主题。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个简介表示了只要有元素需要插入而且容器的容量不足时就会发生重新分配（包括它们维护的原始内存分配和回收，对象的拷贝和析构和迭代器、指针和引用的失效）。所以，避免重新分配的关键是使用reserve尽快把容器的容量设置为足够大，最好在容器被构造之后立刻进行。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，假定你想建立一个容纳1-1000值的vector&lt;int&gt;。没有使用reserve，你可以像这样来做：&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;vector&lt;int&gt; v;&lt;br&gt;for (int i = 1; i &amp;lt;= 1000; ++i) v.push_back(i);&lt;br&gt;在大多数STL实现中，这段代码在循环过程中将会导致2到10次重新分配。（10这个数没什么奇怪的。记住vector在重新分配发生时一般把容量翻倍，而1000约等于210。）&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;把代码改为使用reserve，我们得到这个：&lt;/p&gt;
&lt;p&gt;vector&lt;int&gt; v;&lt;br&gt;v.reserve(1000);&lt;br&gt;for (int i = 1; i &amp;lt;= 1000; ++i) v.push_back(i);&lt;br&gt;这在循环中不会发生重新分配。&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;在大小和容量之间的关系让我们可以预言什么时候插入将引起vector或string执行重新分配，而且，可以预言什么时候插入会使指向容器中的迭代器、指针和引用失效。例如，给出这段代码，&lt;/p&gt;
&lt;p&gt;string s;&lt;br&gt;…&lt;br&gt;if (s.size() &amp;lt; s.capacity()) {&lt;br&gt;s.push_back(‘x’);&lt;br&gt;}&lt;br&gt;push_back的调用不会使指向这个string中的迭代器、指针或引用失效，因为string的容量保证大于它的大小。如果不是执行push_back，代码在string的任意位置进行一个insert，我们仍然可以保证在插入期间没有发生重新分配，但是，与伴随string插入时迭代器失效的一般规则一致，所有从插入位置到string结尾的迭代器/指针/引用将失效。&lt;/p&gt;
&lt;p&gt;回到本条款的主旨，通常有两情况使用reserve来避免不必要的重新分配。第一个可用的情况是当你确切或者大约知道有多少元素将最后出现在容器中。那样的话，就像上面的vector代码，你只是提前reserve适当数量的空间。第二种情况是保留你可能需要的最大的空间，然后，一旦你添加完全部数据，修整掉任何多余的容量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2》使用“交换技巧”来修整vector过剩空间/内存

有一种方法来把它从曾经最大的容量减少到它现在需要的容量。这样减少容量的方法常常被称为“收缩到合适（shrink to fit）”。该方法只需一条语句：vector&amp;lt;int&amp;gt;(ivec).swap(ivec);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表达式vector&lt;int&gt;(ivec)建立一个临时vector，它是ivec的一份拷贝：vector的拷贝构造函数做了这个工作。但是，vector的拷贝构造函数只分配拷贝的元素需要的内存，所以这个临时vector没有多余的容量。然后我们让临时vector和ivec交换数据，这时我们完成了，ivec只有临时变量的修整过的容量，而这个临时变量则持有了曾经在ivec中的没用到的过剩容量。在这里（这个语句结尾），临时vector被销毁，因此释放了以前ivec使用的内存，收缩到合适。&lt;/int&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3》用swap方法强行释放STL Vector所占内存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;template &amp;lt; class T&amp;gt; void ClearVector( vector&lt;t&gt;&amp;amp; v )&lt;br&gt;{&lt;br&gt;    vector&lt;t&gt;vtTemp;&lt;br&gt;    vtTemp.swap( v );&lt;br&gt;}&lt;br&gt;如&lt;br&gt;    vector&lt;int&gt; v ;&lt;br&gt;    nums.push_back(1);&lt;br&gt;    nums.push_back(3);&lt;br&gt;    nums.push_back(2);&lt;br&gt;    nums.push_back(4);&lt;br&gt;    vector&lt;int&gt;().swap(v);&lt;/int&gt;&lt;/int&gt;&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 或者v.swap(vector&lt;int&gt;()); &lt;/int&gt;&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;或者{ std::vector&lt;int&gt; tmp = v;   v.swap(tmp);   }; //加大括号{ }是让tmp退出{ }时自动析构&lt;/int&gt;&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;5.Vector 内存管理成员函数的行为测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C++ STL的vector使用非常广泛，但是对其内存的管理模型一直有多种猜测，下面用实例代码测试来了解其内存管理方式，测试代码如下：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#include &lt;iostream&gt;&lt;/iostream&gt;&lt;/p&gt;
&lt;p&gt;#include &lt;vector&gt;&lt;br&gt;using namespace std;&lt;/vector&gt;&lt;/p&gt;
&lt;p&gt;int main()&lt;br&gt;{&lt;br&gt;vector&lt;int&gt; iVec;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //1个元素， 容器容量为1&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;iVec.push_back(1);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //2个元素， 容器容量为2&lt;/p&gt;
&lt;p&gt;iVec.push_back(2);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //3个元素， 容器容量为4&lt;/p&gt;
&lt;p&gt;iVec.push_back(3);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //4个元素， 容器容量为4&lt;/p&gt;
&lt;p&gt;iVec.push_back(4);&lt;br&gt;iVec.push_back(5);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //5个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(6);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //6个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(7);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //7个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(8);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //8个元素， 容器容量为8&lt;/p&gt;
&lt;p&gt;iVec.push_back(9);&lt;br&gt;cout &amp;lt;&amp;lt; “容器 大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “容器 容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl; //9个元素， 容器容量为16&lt;br&gt;/&lt;em&gt; vs2005/8 容量增长不是翻倍的，如&lt;br&gt;    9个元素   容量9&lt;br&gt;    10个元素 容量13 &lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 测试effective stl中的特殊的交换 swap() &lt;/em&gt;/&lt;br&gt;cout &amp;lt;&amp;lt; “当前vector 的大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “当前vector 的容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl;&lt;br&gt;vector&lt;int&gt;(iVec).swap(iVec);&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;cout &amp;lt;&amp;lt; “临时的vector&lt;int&gt;对象 的大小为: “ &amp;lt;&amp;lt; (vector&lt;int&gt;(iVec)).size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “临时的vector&lt;int&gt;对象 的容量为: “ &amp;lt;&amp;lt; (vector&lt;int&gt;(iVec)).capacity() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “交换后，当前vector 的大小为: “ &amp;lt;&amp;lt; iVec.size() &amp;lt;&amp;lt; endl;&lt;br&gt;cout &amp;lt;&amp;lt; “交换后，当前vector 的容量为: “ &amp;lt;&amp;lt; iVec.capacity() &amp;lt;&amp;lt; endl;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;return 0;&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;6.vector的其他成员函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c.assign(beg,end)：将[beg; end)区间中的数据赋值给c。
c.assign(n,elem)：将n个elem的拷贝赋值给c。 
c.at(idx)：传回索引idx所指的数据，如果idx越界，抛出out_of_range。 
c.back()：传回最后一个数据，不检查这个数据是否存在。
c.front()：传回地一个数据。 
get_allocator：使用构造函数返回一个拷贝。 
c.rbegin()：传回一个逆向队列的第一个数据。 
c.rend()：传回一个逆向队列的最后一个数据的下一个位置。 
c.~ vector &amp;lt;Elem&amp;gt;()：销毁所有数据，释放内存。    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.备注:在用vector的过程中的一些问题,特此列出讨论:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1)

     vector &amp;lt;int &amp;gt; a;

     int  b = 5;

     a.push_back(b);

     此时若对b另外赋值时不会影响a[0]的值

 2)

     vector &amp;lt;int*&amp;gt; a;
      int *b;
      b= new int[4];
      b[0]=0;
      b[1]=1;
      b[2]=2;
      a.push_back(b);
      delete b;          //释放b的地址空间
      for(int i=0 ; i &amp;lt;3 ; i++)
      {
            cout&amp;lt;&amp;lt;a[0][i]&amp;lt;&amp;lt;endl;
      }

      此时输出的值并不是一开始b数组初始化的值,而是一些无法预计的值.

     分析:根据1) 2)的结果,可以想到,在1)中,  往a向量中压入的是b的值,即a[0]=b,此时a[0]和b是存储在两个不同的地址中的.因此改变b的值不会影响a[0];而在2)中,因为是把一个地址(指针)压入向量a,即a[0]=b,因此释放了b的地址也就释放了a[0]的地址,因此a[0]数组中存放的数值也就不得而知了.   
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的vector类的时候，其中的很多方法与python中list很类似。&lt;br&gt; vector(向量): C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>c++ string类的用法总结</title>
    <link href="http://yoursite.com/2016/04/08/c-string%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/08/c-string类的用法总结/</id>
    <published>2016-04-07T16:14:15.000Z</published>
    <updated>2016-04-07T16:33:10.118Z</updated>
    
    <content type="html">&lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的string类的时候，其中的很多方法与python中list很类似。&lt;br&gt;要想使用标准C++中string类，必须要包含&lt;/p&gt;
&lt;p&gt;#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件&lt;/string.h&gt;&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;
&lt;p&gt;using  std::string;&lt;/p&gt;
&lt;p&gt;using  std::wstring;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;或&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。&lt;/p&gt;
&lt;p&gt;string和wstring的用法是一样的，以下只用string作介绍：&lt;/p&gt;
&lt;h1 id=&quot;string类的构造函数：&quot;&gt;&lt;a href=&quot;#string类的构造函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的构造函数：&quot;&gt;&lt;/a&gt;string类的构造函数：&lt;/h1&gt;&lt;p&gt;string(const char *s);    //用c字符串s初始化&lt;br&gt;string(int n,char c);     //用n个字符c初始化&lt;br&gt;此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；&lt;/p&gt;
&lt;h1 id=&quot;string类的字符操作：&quot;&gt;&lt;a href=&quot;#string类的字符操作：&quot; class=&quot;headerlink&quot; title=&quot;string类的字符操作：&quot;&gt;&lt;/a&gt;string类的字符操作：&lt;/h1&gt;&lt;p&gt;const char &amp;amp;operator&lt;a href=&quot;int n&quot;&gt;&lt;/a&gt;const;&lt;br&gt;const char &amp;amp;at(int n)const;&lt;br&gt;char &amp;amp;operator&lt;a href=&quot;int n&quot;&gt;&lt;/a&gt;;&lt;br&gt;char &amp;amp;at(int n);&lt;br&gt;operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。&lt;br&gt;const char &lt;em&gt;data()const;//返回一个非null终止的c字符数组&lt;br&gt;const char &lt;/em&gt;c_str()const;//返回一个以null终止的c字符串&lt;br&gt;int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目&lt;/p&gt;
&lt;h1 id=&quot;string的特性描述&quot;&gt;&lt;a href=&quot;#string的特性描述&quot; class=&quot;headerlink&quot; title=&quot;string的特性描述:&quot;&gt;&lt;/a&gt;string的特性描述:&lt;/h1&gt;&lt;p&gt;int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）&lt;br&gt;int max_size()const;    //返回string对象中可存放的最大字符串的长度&lt;br&gt;int size()const;        //返回当前字符串的大小&lt;br&gt;int length()const;       //返回当前字符串的长度&lt;br&gt;bool empty()const;        //当前字符串是否为空&lt;br&gt;void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分&lt;/p&gt;
&lt;h1 id=&quot;string类的输入输出操作&quot;&gt;&lt;a href=&quot;#string类的输入输出操作&quot; class=&quot;headerlink&quot; title=&quot;string类的输入输出操作:&quot;&gt;&lt;/a&gt;string类的输入输出操作:&lt;/h1&gt;&lt;p&gt;string类重载运算符operator&amp;gt;&amp;gt;用于输入，同样重载运算符operator&amp;lt;&amp;lt;用于输出操作。&lt;br&gt;函数getline(istream &amp;amp;in,string &amp;amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。&lt;/p&gt;
&lt;h1 id=&quot;string的赋值：&quot;&gt;&lt;a href=&quot;#string的赋值：&quot; class=&quot;headerlink&quot; title=&quot;string的赋值：&quot;&gt;&lt;/a&gt;string的赋值：&lt;/h1&gt;&lt;p&gt;string &amp;amp;operator=(const string &amp;amp;s);//把字符串s赋给当前字符串&lt;br&gt;string &amp;amp;assign(const char &lt;em&gt;s);//用c类型字符串s赋值&lt;br&gt;string &amp;amp;assign(const char &lt;/em&gt;s,int n);//用c字符串s开始的n个字符赋值&lt;br&gt;string &amp;amp;assign(const string &amp;amp;s);//把字符串s赋给当前字符串&lt;br&gt;string &amp;amp;assign(int n,char c);//用n个字符c赋值给当前字符串&lt;br&gt;string &amp;amp;assign(const string &amp;amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串&lt;br&gt;string &amp;amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串&lt;/p&gt;
&lt;h1 id=&quot;string的连接：&quot;&gt;&lt;a href=&quot;#string的连接：&quot; class=&quot;headerlink&quot; title=&quot;string的连接：&quot;&gt;&lt;/a&gt;string的连接：&lt;/h1&gt;&lt;p&gt;string &amp;amp;operator+=(const string &amp;amp;s);//把字符串s连接到当前字符串的结尾&lt;br&gt;string &amp;amp;append(const char &lt;em&gt;s);            //把c类型字符串s连接到当前字符串结尾&lt;br&gt;string &amp;amp;append(const char &lt;/em&gt;s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾&lt;br&gt;string &amp;amp;append(const string &amp;amp;s);    //同operator+=()&lt;br&gt;string &amp;amp;append(const string &amp;amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾&lt;br&gt;string &amp;amp;append(int n,char c);        //在当前字符串结尾添加n个字符c&lt;br&gt;string &amp;amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾&lt;/p&gt;
&lt;h1 id=&quot;string的比较：&quot;&gt;&lt;a href=&quot;#string的比较：&quot; class=&quot;headerlink&quot; title=&quot;string的比较：&quot;&gt;&lt;/a&gt;string的比较：&lt;/h1&gt;&lt;p&gt;bool operator==(const string &amp;amp;s1,const string &amp;amp;s2)const;//比较两个字符串是否相等&lt;br&gt;运算符”&amp;gt;”,”&amp;lt;”,”&amp;gt;=”,”&amp;lt;=”,”!=”均被重载用于字符串的比较；&lt;br&gt;int compare(const string &amp;amp;s) const;//比较当前字符串和s的大小&lt;br&gt;int compare(int pos, int n,const string &amp;amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小&lt;br&gt;int compare(int pos, int n,const string &amp;amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//pos2开始的n2个字符组成的字符串的大小&lt;br&gt;int compare(const char &lt;em&gt;s) const;&lt;br&gt;int compare(int pos, int n,const char &lt;/em&gt;s) const;&lt;br&gt;int compare(int pos, int n,const char *s, int pos2) const;&lt;br&gt;compare函数在&amp;gt;时返回1，&amp;lt;时返回-1，==时返回0  &lt;/p&gt;
&lt;h1 id=&quot;string的子串：&quot;&gt;&lt;a href=&quot;#string的子串：&quot; class=&quot;headerlink&quot; title=&quot;string的子串：&quot;&gt;&lt;/a&gt;string的子串：&lt;/h1&gt;&lt;p&gt;string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串&lt;/p&gt;
&lt;h1 id=&quot;string的交换：&quot;&gt;&lt;a href=&quot;#string的交换：&quot; class=&quot;headerlink&quot; title=&quot;string的交换：&quot;&gt;&lt;/a&gt;string的交换：&lt;/h1&gt;&lt;p&gt;void swap(string &amp;amp;s2);    //交换当前字符串与s2的值&lt;/p&gt;
&lt;h1 id=&quot;string类的查找函数：&quot;&gt;&lt;a href=&quot;#string类的查找函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的查找函数：&quot;&gt;&lt;/a&gt;string类的查找函数：&lt;/h1&gt;&lt;p&gt;int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置&lt;br&gt;int find(const char &lt;em&gt;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置&lt;br&gt;int find(const char &lt;/em&gt;s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置&lt;br&gt;int find(const string &amp;amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置&lt;br&gt;//查找成功时返回所在位置，失败返回string::npos的值&lt;br&gt;int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置&lt;br&gt;int rfind(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int rfind(const char &lt;/em&gt;s, int pos, int n = npos) const;&lt;br&gt;int rfind(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值&lt;br&gt;int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置&lt;br&gt;int find_first_of(const char &lt;em&gt;s, int pos = 0) const;&lt;br&gt;int find_first_of(const char &lt;/em&gt;s, int pos, int n) const;&lt;br&gt;int find_first_of(const string &amp;amp;s,int pos = 0) const;&lt;br&gt;//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos&lt;br&gt;int find_first_not_of(char c, int pos = 0) const;&lt;br&gt;int find_first_not_of(const char &lt;em&gt;s, int pos = 0) const;&lt;br&gt;int find_first_not_of(const char &lt;/em&gt;s, int pos,int n) const;&lt;br&gt;int find_first_not_of(const string &amp;amp;s,int pos = 0) const;&lt;br&gt;//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos&lt;br&gt;int find_last_of(char c, int pos = npos) const;&lt;br&gt;int find_last_of(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int find_last_of(const char &lt;/em&gt;s, int pos, int n = npos) const;&lt;br&gt;int find_last_of(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;int find_last_not_of(char c, int pos = npos) const;&lt;br&gt;int find_last_not_of(const char &lt;em&gt;s, int pos = npos) const;&lt;br&gt;int find_last_not_of(const char &lt;/em&gt;s, int pos, int n) const;&lt;br&gt;int find_last_not_of(const string &amp;amp;s,int pos = npos) const;&lt;br&gt;//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找&lt;/p&gt;
&lt;h1 id=&quot;string类的替换函数：&quot;&gt;&lt;a href=&quot;#string类的替换函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的替换函数：&quot;&gt;&lt;/a&gt;string类的替换函数：&lt;/h1&gt;&lt;p&gt;string &amp;amp;replace(int p0, int n0,const char &lt;em&gt;s);//删除从p0开始的n0个字符，然后在p0处插入串s&lt;br&gt;string &amp;amp;replace(int p0, int n0,const char &lt;/em&gt;s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符&lt;br&gt;string &amp;amp;replace(int p0, int n0,const string &amp;amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s&lt;br&gt;string &amp;amp;replace(int p0, int n0,const string &amp;amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符&lt;br&gt;string &amp;amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const char &lt;em&gt;s);//把[first0，last0）之间的部分替换为字符串s&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const char &lt;/em&gt;s, int n);//把[first0，last0）之间的部分替换为s的前n个字符&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const string &amp;amp;s);//把[first0，last0）之间的部分替换为串s&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c&lt;br&gt;string &amp;amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串&lt;/p&gt;
&lt;h1 id=&quot;string类的插入函数：&quot;&gt;&lt;a href=&quot;#string类的插入函数：&quot; class=&quot;headerlink&quot; title=&quot;string类的插入函数：&quot;&gt;&lt;/a&gt;string类的插入函数：&lt;/h1&gt;&lt;p&gt;string &amp;amp;insert(int p0, const char &lt;em&gt;s);&lt;br&gt;string &amp;amp;insert(int p0, const char &lt;/em&gt;s, int n);&lt;br&gt;string &amp;amp;insert(int p0,const string &amp;amp;s);&lt;br&gt;string &amp;amp;insert(int p0,const string &amp;amp;s, int pos, int n);&lt;br&gt;//前4个函数在p0位置插入字符串s中pos开始的前n个字符&lt;br&gt;string &amp;amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c&lt;br&gt;iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置&lt;br&gt;void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符&lt;br&gt;void insert(iterator it, int n, char c);//在it处插入n个字符c&lt;/p&gt;
&lt;h1 id=&quot;string类的删除函数&quot;&gt;&lt;a href=&quot;#string类的删除函数&quot; class=&quot;headerlink&quot; title=&quot;string类的删除函数&quot;&gt;&lt;/a&gt;string类的删除函数&lt;/h1&gt;&lt;p&gt;iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置&lt;br&gt;iterator erase(it&lt;img src=&quot;http://&quot; alt=&quot;&quot;&gt;erator it);//删除it指向的字符，返回删除后迭代器的位置&lt;br&gt;string &amp;amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串&lt;/p&gt;
&lt;h1 id=&quot;string类的迭代器处理：&quot;&gt;&lt;a href=&quot;#string类的迭代器处理：&quot; class=&quot;headerlink&quot; title=&quot;string类的迭代器处理：&quot;&gt;&lt;/a&gt;string类的迭代器处理：&lt;/h1&gt;&lt;p&gt;string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。&lt;br&gt;用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：&lt;br&gt;const_iterator begin()const;&lt;br&gt;iterator begin();                //返回string的起始位置&lt;br&gt;const_iterator end()const;&lt;br&gt;iterator end();                    //返回string的最后一个字符后面的位置&lt;br&gt;const_iterator rbegin()const;&lt;br&gt;iterator rbegin();                //返回string的最后一个字符的位置&lt;br&gt;const_iterator rend()const;&lt;br&gt;iterator rend();                    //返回string第一个字符位置的前面&lt;br&gt;rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现&lt;/p&gt;
&lt;h1 id=&quot;字符串流处理：&quot;&gt;&lt;a href=&quot;#字符串流处理：&quot; class=&quot;headerlink&quot; title=&quot;字符串流处理：&quot;&gt;&lt;/a&gt;字符串流处理：&lt;/h1&gt;&lt;p&gt;通过定义ostringstream和istringstream变量实现，#include &lt;sstream&gt;头文件中&lt;br&gt;例如：&lt;br&gt;    string input(“hello,this is a test”);&lt;br&gt;    istringstream is(input);&lt;br&gt;    string s1,s2,s3,s4;&lt;br&gt;    is&amp;gt;&amp;gt;s1&amp;gt;&amp;gt;s2&amp;gt;&amp;gt;s3&amp;gt;&amp;gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”&lt;br&gt;    ostringstream os;&lt;br&gt;    os&amp;lt;&amp;lt;s1&amp;lt;&amp;lt;s2&amp;lt;&amp;lt;s3&amp;lt;&amp;lt;s4;&lt;br&gt;    cout&amp;lt;&amp;lt;os.str();&lt;/sstream&gt;&lt;/p&gt;
&lt;h1 id=&quot;处理string对象中的字符&quot;&gt;&lt;a href=&quot;#处理string对象中的字符&quot; class=&quot;headerlink&quot; title=&quot;处理string对象中的字符&quot;&gt;&lt;/a&gt;处理string对象中的字符&lt;/h1&gt;&lt;h2 id=&quot;字符测试&quot;&gt;&lt;a href=&quot;#字符测试&quot; class=&quot;headerlink&quot; title=&quot;字符测试&quot;&gt;&lt;/a&gt;字符测试&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/akof1314/EntryImages/20091001/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;字符映射&quot;&gt;&lt;a href=&quot;#字符映射&quot; class=&quot;headerlink&quot; title=&quot;字符映射&quot;&gt;&lt;/a&gt;字符映射&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/akof1314/EntryImages/20091001/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本科的时候，主要使用的是c语言做嵌入式以及python，重新学习c++,阅读《c++ primer》，同时在网上查找资料，阅读并记录下来，方便下次查阅。看到STL中的string类的时候，其中的很多方法与python中list很类似。&lt;br&gt;要想使用标准C++中string类，必须要包含&lt;/p&gt;
&lt;p&gt;#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件&lt;/p&gt;
&lt;p&gt;using  std::string;&lt;/p&gt;
&lt;p&gt;using  std::wstring;&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的c/c++框架和库</title>
    <link href="http://yoursite.com/2016/04/07/%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%E7%9A%84c-c-%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93/"/>
    <id>http://yoursite.com/2016/04/07/值得推荐的c-c-框架和库/</id>
    <published>2016-04-07T15:57:57.000Z</published>
    <updated>2016-04-07T16:00:31.734Z</updated>
    
    <content type="html">&lt;p&gt;【本文系外部转贴，原文地址：&lt;a href=&quot;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&lt;/a&gt;&lt;br&gt;下次造轮子前先看看现有的轮子吧&lt;/p&gt;
&lt;h1 id=&quot;值得学习的C语言开源项目&quot;&gt;&lt;a href=&quot;#值得学习的C语言开源项目&quot; class=&quot;headerlink&quot; title=&quot;值得学习的C语言开源项目&quot;&gt;&lt;/a&gt;值得学习的C语言开源项目&lt;/h1&gt;&lt;h2 id=&quot;Webbench&quot;&gt;&lt;a href=&quot;#Webbench&quot; class=&quot;headerlink&quot; title=&quot;Webbench&quot;&gt;&lt;/a&gt;Webbench&lt;/h2&gt;&lt;p&gt;Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://home.tiscali.cz/~cz210552/webbench.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-Tinyhttpd&quot;&gt;&lt;a href=&quot;#2-Tinyhttpd&quot; class=&quot;headerlink&quot; title=&quot;2. Tinyhttpd&quot;&gt;&lt;/a&gt;2. Tinyhttpd&lt;/h2&gt;&lt;p&gt;tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://sourceforge.net/projects/tinyhttpd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/tinyhttpd/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-cJSON&quot;&gt;&lt;a href=&quot;#3-cJSON&quot; class=&quot;headerlink&quot; title=&quot;3. cJSON&quot;&gt;&lt;/a&gt;3. cJSON&lt;/h2&gt;&lt;p&gt;cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。&lt;/p&gt;
&lt;p&gt;cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。&lt;/p&gt;
&lt;p&gt;项目主页:&lt;a href=&quot;http://sourceforge.net/projects/cjson/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/projects/cjson/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-CMockery&quot;&gt;&lt;a href=&quot;#4-CMockery&quot; class=&quot;headerlink&quot; title=&quot;4. CMockery&quot;&gt;&lt;/a&gt;4. CMockery&lt;/h2&gt;&lt;p&gt;cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。&lt;/p&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;p&gt;免费且开源，google提供技术支持；&lt;br&gt;轻量级的框架，使测试更加快速简单；&lt;br&gt;避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;&lt;br&gt;并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用&lt;br&gt;下载链接：&lt;a href=&quot;http://code.google.com/p/cmockery/downloads/list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://code.google.com/p/cmockery/downloads/list&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-Libev&quot;&gt;&lt;a href=&quot;#5-Libev&quot; class=&quot;headerlink&quot; title=&quot;5. Libev&quot;&gt;&lt;/a&gt;5. Libev&lt;/h2&gt;&lt;p&gt;libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://software.schmorp.de/pkg/libev.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://software.schmorp.de/pkg/libev.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-Memcached&quot;&gt;&lt;a href=&quot;#6-Memcached&quot; class=&quot;headerlink&quot; title=&quot;6. Memcached&quot;&gt;&lt;/a&gt;6. Memcached&lt;/h2&gt;&lt;p&gt;Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://memcached.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://memcached.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;7-Lua&quot;&gt;&lt;a href=&quot;#7-Lua&quot; class=&quot;headerlink&quot; title=&quot;7. Lua&quot;&gt;&lt;/a&gt;7. Lua&lt;/h2&gt;&lt;p&gt;Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。&lt;/p&gt;
&lt;p&gt;让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.lua.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.lua.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;8-SQLite&quot;&gt;&lt;a href=&quot;#8-SQLite&quot; class=&quot;headerlink&quot; title=&quot;8. SQLite&quot;&gt;&lt;/a&gt;8. SQLite&lt;/h2&gt;&lt;p&gt;SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.sqlite.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sqlite.org/&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;9-UNIX-v6&quot;&gt;&lt;a href=&quot;#9-UNIX-v6&quot; class=&quot;headerlink&quot; title=&quot;9. UNIX v6&quot;&gt;&lt;/a&gt;9. UNIX v6&lt;/h2&gt;&lt;p&gt;UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？&lt;/p&gt;
&lt;p&gt;另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;10-NETBSD&quot;&gt;&lt;a href=&quot;#10-NETBSD&quot; class=&quot;headerlink&quot; title=&quot;10. NETBSD&quot;&gt;&lt;/a&gt;10. NETBSD&lt;/h2&gt;&lt;p&gt;NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://www.netbsd.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.netbsd.org/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-资源大全&quot;&gt;&lt;a href=&quot;#C-资源大全&quot; class=&quot;headerlink&quot; title=&quot;C++ 资源大全&quot;&gt;&lt;/a&gt;C++ 资源大全&lt;/h1&gt;&lt;p&gt;关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。&lt;/p&gt;
&lt;p&gt;标准库&lt;/p&gt;
&lt;p&gt;C++标准库，包括了STL容器，算法和函数等。&lt;/p&gt;
&lt;p&gt;C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。&lt;br&gt;Standard Template Library：标准模板库&lt;br&gt;C POSIX library ： POSIX系统的C标准库规范&lt;br&gt;ISO C++ Standards Committee ：C++标准委员会&lt;/p&gt;
&lt;p&gt;框架&lt;/p&gt;
&lt;p&gt;C++通用框架和库&lt;/p&gt;
&lt;p&gt;Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合&lt;br&gt;ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。&lt;br&gt;Boost ：大量通用C++库的集合。&lt;br&gt;BDE ：来自于彭博资讯实验室的开发环境。&lt;br&gt;Cinder：提供专业品质创造性编码的开源开发社区。&lt;br&gt;Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。&lt;br&gt;Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。&lt;br&gt;EASTL ：EA-STL公共部分&lt;br&gt;ffead-cpp ：企业应用程序开发框架&lt;br&gt;Folly：由Facebook开发和使用的开源C++库&lt;br&gt;JUCE ：包罗万象的C++类库，用于开发跨平台软件&lt;br&gt;libPhenom：用于构建高性能和高度可扩展性系统的事件框架。&lt;br&gt;LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO&lt;br&gt;LibU ： C语言写的多平台工具库&lt;br&gt;Loki ：C++库的设计，包括常见的设计模式和习语的实现。&lt;br&gt;MiLi ：只含头文件的小型C++库&lt;br&gt;openFrameworks ：开发C++工具包，用于创意性编码。&lt;br&gt;Qt ：跨平台的应用程序和用户界面框架&lt;br&gt;Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。&lt;br&gt;ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。&lt;br&gt;STLport：是STL具有代表性的版本&lt;br&gt;STXXL：用于额外的大型数据集的标准模板库。&lt;br&gt;Ultimate++ ：C++跨平台快速应用程序开发框架&lt;br&gt;Windows Template Library：用于开发Windows应用程序和UI组件的C++库&lt;br&gt;Yomm11 ：C++11的开放multi-methods.&lt;/p&gt;
&lt;p&gt;人工智能&lt;/p&gt;
&lt;p&gt;btsk ：游戏行为树启动器工具&lt;br&gt;Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。&lt;br&gt;Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。&lt;/p&gt;
&lt;p&gt;异步事件循环&lt;/p&gt;
&lt;p&gt;Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。&lt;br&gt;libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。&lt;br&gt;libevent ：事件通知库&lt;br&gt;libuv ：跨平台异步I/O。&lt;/p&gt;
&lt;p&gt;音频&lt;/p&gt;
&lt;p&gt;音频，声音，音乐，数字化音乐库&lt;/p&gt;
&lt;p&gt;FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。&lt;br&gt;Maximilian ：C++音频和音乐数字信号处理库&lt;br&gt;OpenAL ：开源音频库—跨平台的音频API&lt;br&gt;Opus：一个完全开放的，免版税的，高度通用的音频编解码器&lt;br&gt;Speex：免费编解码器，为Opus所废弃&lt;br&gt;Tonic： C++易用和高效的音频合成&lt;br&gt;Vorbis： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。&lt;/p&gt;
&lt;p&gt;生态学&lt;/p&gt;
&lt;p&gt;生物信息，基因组学和生物技术&lt;/p&gt;
&lt;p&gt;libsequence：用于表示和分析群体遗传学数据的C++库。&lt;br&gt;SeqAn：专注于生物数据序列分析的算法和数据结构。&lt;br&gt;Vcflib ：用于解析和处理VCF文件的C++库&lt;br&gt;Wham：直接把联想测试应用到BAM文件的基因结构变异。&lt;/p&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;p&gt;压缩和归档库&lt;/p&gt;
&lt;p&gt;bzip2：一个完全免费，免费专利和高质量的数据压缩&lt;br&gt;doboz：能够快速解压缩的压缩库&lt;br&gt;PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。&lt;br&gt;KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。&lt;br&gt;LZ4 ：非常快速的压缩算法&lt;br&gt;LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。&lt;br&gt;LZMA ：7z格式默认和通用的压缩方法。&lt;br&gt;LZMAT ：及其快速的实时无损数据压缩库&lt;br&gt;miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。&lt;br&gt;Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。&lt;br&gt;Snappy ：快速压缩和解压缩&lt;br&gt;ZLib ：非常紧凑的数据流压缩库&lt;br&gt;ZZIPlib：提供ZIP归档的读权限。&lt;/p&gt;
&lt;p&gt;并发性&lt;/p&gt;
&lt;p&gt;并发执行和多线程&lt;/p&gt;
&lt;p&gt;Boost.Compute ：用于OpenCL的C++GPU计算库&lt;br&gt;Bolt ：针对GPU进行优化的C++模板库&lt;br&gt;C++React ：用于C++11的反应性编程库&lt;br&gt;Intel TBB ：Intel线程构件块&lt;br&gt;Libclsph：基于OpenCL的GPU加速SPH流体仿真库&lt;br&gt;OpenCL ：并行编程的异构系统的开放标准&lt;br&gt;OpenMP：OpenMP API&lt;br&gt;Thrust ：类似于C++标准模板库的并行算法库&lt;br&gt;HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统&lt;br&gt;VexCL ：用于OpenCL/CUDA 的C++向量表达式模板库。&lt;/p&gt;
&lt;p&gt;容器&lt;/p&gt;
&lt;p&gt;C++ B-tree ：基于B树数据结构，实现命令内存容器的模板库&lt;br&gt;Hashmaps： C++中开放寻址哈希表算法的实现&lt;/p&gt;
&lt;p&gt;密码学&lt;/p&gt;
&lt;p&gt;Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。&lt;br&gt;BeeCrypt：&lt;br&gt;Botan： C++加密库&lt;br&gt;Crypto++：一个有关加密方案的免费的C++库&lt;br&gt;GnuPG： OpenPGP标准的完整实现&lt;br&gt;GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库&lt;br&gt;Libgcrypt&lt;br&gt;libmcrypt&lt;br&gt;LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支&lt;br&gt;LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具&lt;br&gt;libsodium：基于NaCI的加密库，固执己见，容易使用&lt;br&gt;Nettle 底层的加密库&lt;br&gt;OpenSSL ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。&lt;br&gt;Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法&lt;/p&gt;
&lt;p&gt;数据库&lt;/p&gt;
&lt;p&gt;数据库，SQL服务器，ODBC驱动程序和工具&lt;/p&gt;
&lt;p&gt;hiberlite ：用于Sqlite3的C++对象关系映射&lt;br&gt;Hiredis： 用于Redis数据库的很简单的C客户端库&lt;br&gt;LevelDB： 快速键值存储库&lt;br&gt;LMDB：符合数据库四大基本元素的嵌入键值存储&lt;br&gt;MySQL++：封装了MySql的C API的C++ 包装器&lt;br&gt;RocksDB：来自Facebook的嵌入键值的快速存储&lt;br&gt;SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。&lt;/p&gt;
&lt;p&gt;调试&lt;/p&gt;
&lt;p&gt;调试库， 内存和资源泄露检测，单元测试&lt;/p&gt;
&lt;p&gt;Boost.Test：Boost测试库&lt;br&gt;Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。&lt;br&gt;CppUnit：由JUnit移植过来的C++测试框架&lt;br&gt;CTest：CMake测试驱动程序&lt;br&gt;googletest：谷歌C++测试框架&lt;br&gt;ig-debugheap：用于跟踪内存错误的多平台调试堆&lt;br&gt;libtap：用C语言编写测试&lt;br&gt;MemTrack —用于C++跟踪内存分配&lt;br&gt;microprofile- 跨平台的网络试图分析器&lt;br&gt;minUnit ：使用C写的迷你单元测试框架，只使用了两个宏&lt;br&gt;Remotery：用于web视图的单一C文件分析器&lt;br&gt;UnitTest++：轻量级的C++单元测试框架&lt;/p&gt;
&lt;p&gt;游戏引擎&lt;/p&gt;
&lt;p&gt;Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。&lt;br&gt;Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。&lt;br&gt;Irrlicht ：C++语言编写的开源高性能的实时#D引擎&lt;br&gt;Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。&lt;/p&gt;
&lt;p&gt;图形用户界面&lt;/p&gt;
&lt;p&gt;CEGUI ： 很灵活的跨平台GUI库&lt;br&gt;FLTK ：快速，轻量级的跨平台的C++GUI工具包。&lt;br&gt;GTK+： 用于创建图形用户界面的跨平台工具包&lt;br&gt;gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。&lt;br&gt;imgui：拥有最小依赖关系的立即模式图形用户界面&lt;br&gt;libRocket ：libRocket 是一个C++ HTML/CSS 游戏接口中间件&lt;br&gt;MyGUI ：快速，灵活，简单的GUI&lt;br&gt;Ncurses：终端用户界面&lt;br&gt;QCustomPlot ：没有更多依赖关系的Qt绘图控件&lt;br&gt;Qwt ：用户与技术应用的Qt 控件&lt;br&gt;QwtPlot3D ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件&lt;br&gt;OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案&lt;br&gt;PDCurses 包含源代码和预编译库的公共图形函数库&lt;br&gt;wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序&lt;/p&gt;
&lt;p&gt;图形&lt;/p&gt;
&lt;p&gt;bgfx：跨平台的渲染库&lt;br&gt;Cairo：支持多种输出设备的2D图形库&lt;br&gt;Horde3D 一个小型的3D渲染和动画引擎&lt;br&gt;magnum C++11和OpenGL 2D/3D 图形引擎&lt;br&gt;Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）&lt;br&gt;OpenSceneGraph 具有高性能的开源3D图形工具包&lt;br&gt;Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。&lt;br&gt;Skia 用于绘制文字，图形和图像的完整的2D图形库&lt;br&gt;urho3d 跨平台的渲染和游戏引擎。&lt;/p&gt;
&lt;p&gt;图像处理&lt;/p&gt;
&lt;p&gt;Boost.GIL：通用图像库&lt;br&gt;CImg ：用于图像处理的小型开源C++工具包&lt;br&gt;CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。&lt;br&gt;FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。&lt;br&gt;GDCM：Grassroots DICOM 库&lt;br&gt;ITK：跨平台的开源图像分析系统&lt;br&gt;Magick++：ImageMagick程序的C++接口&lt;br&gt;MagickWnd：ImageMagick程序的C++接口&lt;br&gt;OpenCV ： 开源计算机视觉类库&lt;br&gt;tesseract-ocr：OCR引擎&lt;br&gt;VIGRA ：用于图像分析通用C++计算机视觉库&lt;br&gt;VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。&lt;/p&gt;
&lt;p&gt;国际化&lt;/p&gt;
&lt;p&gt;gettext ：GNU `gettext’&lt;br&gt;IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库&lt;br&gt;libiconv ：用于不同字符编码之间的编码转换库&lt;/p&gt;
&lt;p&gt;Jason&lt;/p&gt;
&lt;p&gt;frozen ： C/C++的Jason解析生成器&lt;br&gt;Jansson ：进行编解码和处理Jason数据的C语言库&lt;br&gt;jbson ：C++14中构建和迭代BSON data,和Json 文档的库&lt;br&gt;JeayeSON：非常健全的C++ JSON库，只包含头文件&lt;br&gt;JSON++ ： C++ JSON 解析器&lt;br&gt;json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少&lt;br&gt;json11 ：一个迷你的C++11 JSON库&lt;br&gt;jute ：非常简单的C++ JSON解析器&lt;br&gt;ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。&lt;br&gt;libjson：轻量级的JSON库&lt;br&gt;PicoJSON：C++中JSON解析序列化，只包含头文件&lt;br&gt;qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类&lt;br&gt;QJson：将JSON数据映射到QVariant对象的基于Qt的库&lt;br&gt;RapidJSON： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API&lt;br&gt;YAJL ：C语言中快速流JSON解析库&lt;/p&gt;
&lt;p&gt;日志&lt;/p&gt;
&lt;p&gt;Boost.Log ：设计非常模块化，并且具有扩展性&lt;br&gt;easyloggingpp：C++日志库，只包含单一的头文件。&lt;br&gt;Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。&lt;br&gt;templog：轻量级C++库，可以添加日志到你的C++应用程序中&lt;/p&gt;
&lt;p&gt;机器学习&lt;/p&gt;
&lt;p&gt;Caffe ：快速的神经网络框架&lt;br&gt;CCV ：以C语言为核心的现代计算机视觉库&lt;br&gt;mlpack ：可扩展的C++机器学习库&lt;br&gt;OpenCV：开源计算机视觉库&lt;br&gt;Recommender：使用协同过滤进行产品推荐/建议的C语言库。&lt;br&gt;SHOGUN：Shogun 机器学习工具&lt;br&gt;sofia-ml ：用于机器学习的快速增量算法套件&lt;/p&gt;
&lt;p&gt;数学&lt;/p&gt;
&lt;p&gt;Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似&lt;br&gt;blaze：高性能的C++数学库，用于密集和稀疏算法。&lt;br&gt;ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。&lt;br&gt;CGal： 高效，可靠的集合算法集合&lt;br&gt;cml ：用于游戏和图形的免费C++数学库&lt;br&gt;Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。&lt;br&gt;GMTL：数学图形模板库是一组广泛实现基本图形的工具。&lt;br&gt;GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。&lt;/p&gt;
&lt;p&gt;多媒体&lt;/p&gt;
&lt;p&gt;GStreamer ：构建媒体处理组件图形的库&lt;br&gt;LIVE555 Streaming Media ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库&lt;br&gt;libVLC ：libVLC (VLC SDK)媒体框架&lt;br&gt;QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器&lt;br&gt;SDL ：简单直控媒体层&lt;br&gt;SFML ：快速，简单的多媒体库&lt;/p&gt;
&lt;p&gt;网络&lt;/p&gt;
&lt;p&gt;ACE：C++面向对象网络变成工具包&lt;br&gt;Boost.Asio：用于网络和底层I/O编程的跨平台的C++库&lt;br&gt;Casablanca：C++ REST SDK&lt;br&gt;cpp-netlib：高级网络编程的开源库集合&lt;br&gt;Dyad.c：C语言的异步网络&lt;br&gt;libcurl :多协议文件传输库&lt;br&gt;Mongoose：非常轻量级的网络服务器&lt;br&gt;Muduo ：用于Linux多线程服务器的C++非阻塞网络库&lt;br&gt;net_skeleton ：C/C++的TCP 客户端/服务器库&lt;br&gt;nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js&lt;br&gt;Onion :C语言HTTP服务器库，其设计为轻量级，易使用。&lt;br&gt;POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。&lt;br&gt;RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。&lt;br&gt;Tuf o ：用于Qt之上的C++构建的异步Web框架。&lt;br&gt;WebSocket++ ：基于C++/Boost Aiso的websocket 客户端/服务器库&lt;br&gt;ZeroMQ ：高速，模块化的异步通信库&lt;/p&gt;
&lt;p&gt;物理学&lt;/p&gt;
&lt;p&gt;动力学仿真引擎&lt;/p&gt;
&lt;p&gt;Box2D：2D的游戏物理引擎。&lt;br&gt;Bullet ：3D的游戏物理引擎。&lt;br&gt;Chipmunk ：快速，轻量级的2D游戏物理库&lt;br&gt;LiquidFun：2D的游戏物理引擎&lt;br&gt;ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。&lt;br&gt;ofxBox2d：Box2D开源框架包装器。&lt;br&gt;Simbody ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。&lt;/p&gt;
&lt;p&gt;机器人学&lt;/p&gt;
&lt;p&gt;MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。&lt;br&gt;MRPT：移动机器人编程工具包&lt;br&gt;PCL ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。&lt;br&gt;Robotics Library (RL)： 一个独立的C++库，包括机器人动力学，运动规划和控制。&lt;br&gt;RobWork：一组C++库的集合，用于机器人系统的仿真和控制。&lt;br&gt;ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。&lt;/p&gt;
&lt;p&gt;科学计算&lt;/p&gt;
&lt;p&gt;FFTW :用一维或者多维计算DFT的C语言库。&lt;br&gt;GSL：GNU科学库。&lt;/p&gt;
&lt;p&gt;脚本&lt;/p&gt;
&lt;p&gt;ChaiScript ：用于C++的易于使用的嵌入式脚本语言。&lt;br&gt;Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。&lt;br&gt;luacxx：用于创建Lua绑定的C++ 11 API&lt;br&gt;SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器&lt;br&gt;V7：嵌入式的JavaScript 引擎。&lt;br&gt;V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。&lt;/p&gt;
&lt;p&gt;序列化&lt;/p&gt;
&lt;p&gt;Cap’n Proto ：快速数据交换格式和RPC系统。&lt;br&gt;cereal ：C++11 序列化库&lt;br&gt;FlatBuffers ：内存高效的序列化库&lt;br&gt;MessagePack ：C/C++的高效二进制序列化库，例如 JSON&lt;br&gt;protobuf ：协议缓冲，谷歌的数据交换格式。&lt;br&gt;protobuf-c ：C语言的协议缓冲实现&lt;br&gt;SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。&lt;br&gt;Thrift ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。注：原文有误，应该是 facebook 在2007年开发的，现在是 Apache 在维护&lt;/p&gt;
&lt;p&gt;视频&lt;/p&gt;
&lt;p&gt;libvpx ：VP8/VP9编码解码SDK&lt;br&gt;FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。&lt;br&gt;libde265 ：开放的h.265视频编解码器的实现。&lt;br&gt;OpenH264：开源H.364 编解码器。&lt;br&gt;Theora ：免费开源的视频压缩格式。&lt;/p&gt;
&lt;p&gt;虚拟机&lt;/p&gt;
&lt;p&gt;CarpVM：C中有趣的VM，让我们一起来看看这个。&lt;br&gt;MicroPython ：旨在实现单片机上Python3.x的实现&lt;br&gt;TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。&lt;/p&gt;
&lt;p&gt;Web应用框架&lt;/p&gt;
&lt;p&gt;Civetweb ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。&lt;br&gt;CppCMS ：免费高性能的Web开发框架（不是 CMS）.&lt;br&gt;Crow ：一个C++微型web框架（灵感来自于Python Flask）&lt;br&gt;Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。&lt;br&gt;libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。&lt;br&gt;QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。&lt;br&gt;Wt ：开发Web应用的C++库。&lt;/p&gt;
&lt;p&gt;XML&lt;/p&gt;
&lt;p&gt;XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds&lt;/p&gt;
&lt;p&gt;Expat ：用C语言编写的xml解析库&lt;br&gt;Libxml2 ：Gnome的xml C解析器和工具包&lt;br&gt;libxml++ ：C++的xml解析器&lt;br&gt;PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。&lt;br&gt;RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。&lt;br&gt;TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。&lt;br&gt;TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。&lt;br&gt;TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。&lt;br&gt;Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。&lt;/p&gt;
&lt;p&gt;多项混杂&lt;/p&gt;
&lt;p&gt;一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。&lt;/p&gt;
&lt;p&gt;C++ Format ：C++的小型，安全和快速格式化库&lt;br&gt;casacore ：从aips++ 派生的一系列C++核心库&lt;br&gt;cxx-prettyprint：用于C++容器的打印库&lt;br&gt;DynaPDF ：易于使用的PDF生成库&lt;br&gt;gcc-poison ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。&lt;br&gt;googlemock：编写和使用C++模拟类的库&lt;br&gt;HTTP Parser ：C的http请求/响应解析器&lt;br&gt;libcpuid ：用于x86 CPU检测盒特征提取的小型C库&lt;br&gt;libevil ：许可证管理器&lt;br&gt;libusb：允许移动访问USB设备的通用USB库&lt;br&gt;PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。&lt;br&gt;Remote Call Framework ：C++的进程间通信框架。&lt;br&gt;Scintilla ：开源的代码编辑控件&lt;br&gt;Serial Communication Library ：C++语言编写的跨平台，串口库。&lt;br&gt;SDS：C的简单动态字符串库&lt;br&gt;SLDR ：超轻的DNS解析器&lt;br&gt;SLRE： 超轻的正则表达式库&lt;br&gt;Stage ：移动机器人模拟器&lt;br&gt;VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。&lt;br&gt;ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。&lt;br&gt;CppVerbalExpressions ：易于使用的C++正则表达式&lt;br&gt;QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库&lt;br&gt;PHP-CPP：使用C++来构建PHP扩展的库&lt;br&gt;Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。&lt;/p&gt;
&lt;p&gt;软件&lt;/p&gt;
&lt;p&gt;用于创建开发环境的软件&lt;/p&gt;
&lt;p&gt;编译器&lt;/p&gt;
&lt;p&gt;C/C++编译器列表&lt;/p&gt;
&lt;p&gt;Clang :由苹果公司开发的&lt;br&gt;GCC：GNU编译器集合&lt;br&gt;Intel C++ Compiler ：由英特尔公司开发&lt;br&gt;LLVM ：模块化和可重用编译器和工具链技术的集合&lt;br&gt;Microsoft Visual C++ ：MSVC，由微软公司开发&lt;br&gt;Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具&lt;br&gt;TCC ：轻量级的C语言编译器&lt;/p&gt;
&lt;p&gt;在线编译器&lt;/p&gt;
&lt;p&gt;在线C/C++编译器列表&lt;/p&gt;
&lt;p&gt;codepad ：在线编译器/解释器，一个简单的协作工具&lt;br&gt;CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果&lt;br&gt;coliru ：在线编译器/shell， 支持各种C++编译器&lt;br&gt;Compiler Explorer：交互式编译器，可以进行汇编输出&lt;br&gt;CompileOnline：Linux上在线编译和执行C++程序&lt;br&gt;Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。&lt;/p&gt;
&lt;p&gt;调试器&lt;/p&gt;
&lt;p&gt;C/C++调试器列表&lt;/p&gt;
&lt;p&gt;Comparison of debuggers ：来自维基百科的调试器列表&lt;br&gt;GDB ：GNU调试器&lt;br&gt;Valgrind：内存调试，内存泄露检测，性能分析工具。&lt;/p&gt;
&lt;p&gt;集成开发环境（IDE）&lt;/p&gt;
&lt;p&gt;C/C++集成开发环境列表&lt;/p&gt;
&lt;p&gt;AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境&lt;br&gt;CLion：来自JetBrains的跨平台的C/C++的集成开发环境&lt;br&gt;Code::Blocks ：免费C，C++和Fortran的集成开发环境&lt;br&gt;CodeLite ：另一个跨平台的免费的C/C++集成开发环境&lt;br&gt;Dev-C++：可移植的C/C++/C++11集成开发环境&lt;br&gt;Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境&lt;br&gt;Geany ：轻量级的快速，跨平台的集成开发环境。&lt;br&gt;IBM VisualAge ：来自IBM的家庭计算机集成开发环境。&lt;br&gt;Irony-mode：由libclang驱动的用于Emacs的C/C++微模式&lt;br&gt;KDevelop：免费开源集成开发环境&lt;br&gt;Microsoft Visual Studio ：来自微软的集成开发环境&lt;br&gt;NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。&lt;br&gt;Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。&lt;br&gt;rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成&lt;br&gt;Xcode ：由苹果公司开发&lt;br&gt;YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。&lt;/p&gt;
&lt;p&gt;构建系统&lt;/p&gt;
&lt;p&gt;Bear ：用于为clang工具生成编译数据库的工具&lt;br&gt;Biicode：基于文件的简单依赖管理器。&lt;br&gt;CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。&lt;br&gt;CPM：基于CMake和Git的C++包管理器&lt;br&gt;FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。&lt;br&gt;Ninja ：专注于速度的小型构建系统&lt;br&gt;Scons ：使用Python scipt 配置的软件构建工具&lt;br&gt;tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。&lt;br&gt;tup：基于文件的构建系统，用于后台监控变化的文件。&lt;/p&gt;
&lt;p&gt;静态代码分析&lt;/p&gt;
&lt;p&gt;提高质量，减少瑕疵的代码分析工具列表&lt;/p&gt;
&lt;p&gt;Cppcheck ：静态C/C++代码分析工具&lt;br&gt;include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。&lt;br&gt;OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。&lt;br&gt;Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具&lt;br&gt;List of tools for static code analysis ：来自维基百科的静态代码分析工具列表&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;【本文系外部转贴，原文地址：&lt;a href=&quot;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&quot;&gt;http://coolshell.info/c/c++/2014/12/13/c-open-project.htm】留作存档&lt;/a&gt;&lt;br&gt;下次造轮子前先看看现有的轮子吧&lt;/p&gt;
&lt;h1 id=&quot;值得学习的C语言开源项目&quot;&gt;&lt;a href=&quot;#值得学习的C语言开源项目&quot; class=&quot;headerlink&quot; title=&quot;值得学习的C语言开源项目&quot;&gt;&lt;/a&gt;值得学习的C语言开源项目&lt;/h1&gt;&lt;h2 id=&quot;Webbench&quot;&gt;&lt;a href=&quot;#Webbench&quot; class=&quot;headerlink&quot; title=&quot;Webbench&quot;&gt;&lt;/a&gt;Webbench&lt;/h2&gt;&lt;p&gt;Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。&lt;/p&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;http://home.tiscali.cz/~cz210552/webbench.html&quot;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="推荐框架和库" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>const用法总结</title>
    <link href="http://yoursite.com/2016/04/07/const%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/07/const用法总结/</id>
    <published>2016-04-07T15:21:41.000Z</published>
    <updated>2016-04-07T16:39:43.906Z</updated>
    
    <content type="html">&lt;p&gt;【原文&lt;a href=&quot;http://blog.csdn.net/Eric_Jo/article/details/4138548】&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/Eric_Jo/article/details/4138548】&lt;/a&gt;&lt;br&gt;C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。&lt;br&gt;Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。&lt;/p&gt;
&lt;h1 id=&quot;Const作用&quot;&gt;&lt;a href=&quot;#Const作用&quot; class=&quot;headerlink&quot; title=&quot;Const作用&quot;&gt;&lt;/a&gt;Const作用&lt;/h1&gt;&lt;p&gt;   如下图所示：&lt;br&gt;&lt;img src=&quot;http://v2.freep.cn/3tb_160407234443rs9v512293.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Const的使用&quot;&gt;&lt;a href=&quot;#Const的使用&quot; class=&quot;headerlink&quot; title=&quot;Const的使用&quot;&gt;&lt;/a&gt;Const的使用&lt;/h1&gt;&lt;h2 id=&quot;定义常量&quot;&gt;&lt;a href=&quot;#定义常量&quot; class=&quot;headerlink&quot; title=&quot;定义常量&quot;&gt;&lt;/a&gt;定义常量&lt;/h2&gt;&lt;p&gt;(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。&lt;/p&gt;
&lt;p&gt; TYPE const ValueName = value;&lt;br&gt;     const TYPE ValueName = value;&lt;/p&gt;
&lt;p&gt;(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extend const int ValueName = value;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;指针使用CONST&quot;&gt;&lt;a href=&quot;#指针使用CONST&quot; class=&quot;headerlink&quot; title=&quot;指针使用CONST&quot;&gt;&lt;/a&gt;指针使用CONST&lt;/h2&gt;&lt;p&gt;(1)指针本身是常量不可变&lt;br&gt;     (char&lt;em&gt;) const pContent;&lt;br&gt;     const (char&lt;/em&gt;) pContent; &lt;/p&gt;
&lt;p&gt;(2)指针所指向的内容是常量不可变&lt;br&gt;     const (char) &lt;em&gt;pContent;&lt;br&gt;     (char) const &lt;/em&gt;pContent; &lt;/p&gt;
&lt;p&gt;(3)两者都不可变&lt;br&gt;      const char* const pContent; &lt;/p&gt;
&lt;p&gt;(4)还有其中区别方法，沿着&lt;em&gt;号划一条线：&lt;br&gt;如果const位于&lt;/em&gt;的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；&lt;br&gt;如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。&lt;/p&gt;
&lt;h2 id=&quot;函数中使用CONST&quot;&gt;&lt;a href=&quot;#函数中使用CONST&quot; class=&quot;headerlink&quot; title=&quot;函数中使用CONST&quot;&gt;&lt;/a&gt;函数中使用CONST&lt;/h2&gt;&lt;p&gt;(1)const修饰函数参数&lt;br&gt;a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)&lt;/p&gt;
&lt;p&gt;void function(const int Var);&lt;/p&gt;
&lt;p&gt;b.参数指针所指内容为常量不可变&lt;/p&gt;
&lt;p&gt;void function(const char* Var);&lt;/p&gt;
&lt;p&gt;c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)&lt;/p&gt;
&lt;p&gt;void function(char* const Var);&lt;/p&gt;
&lt;p&gt;d.参数为引用，为了增加效率同时防止修改。修饰引用参数时：&lt;/p&gt;
&lt;p&gt;void function(const Class&amp;amp; Var); //引用参数在函数内不可以改变&lt;/p&gt;
&lt;p&gt;void function(const TYPE&amp;amp; Var); //引用参数在函数内为常量不可变&lt;/p&gt;
&lt;p&gt;这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙.&lt;/p&gt;
&lt;p&gt;(2)const 修饰函数返回值&lt;br&gt;    const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。&lt;br&gt;    a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。&lt;br&gt;    b. const int &lt;em&gt; fun2() //调用时 const int &lt;/em&gt;pValue = fun2();&lt;br&gt;                          //我们可以把fun2()看作成一个变量，即指针内容不可变。&lt;br&gt;    c.int&lt;em&gt; const fun3()   //调用时 int &lt;/em&gt; const pValue = fun2();&lt;br&gt;                          //我们可以把fun2()看作成一个变量，即指针本身不可变。&lt;/p&gt;
&lt;p&gt;一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp;amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。&lt;/p&gt;
&lt;h2 id=&quot;类相关CONST&quot;&gt;&lt;a href=&quot;#类相关CONST&quot; class=&quot;headerlink&quot; title=&quot;类相关CONST&quot;&gt;&lt;/a&gt;类相关CONST&lt;/h2&gt;&lt;p&gt;(1)const修饰成员变量&lt;br&gt;const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。&lt;br&gt;    class A&lt;br&gt;    {&lt;br&gt;        …&lt;br&gt;        const int nValue;         //成员常量不能被修改&lt;br&gt;        …&lt;br&gt;        A(int x): nValue(x) { } ; //只能在初始化列表中赋值&lt;br&gt;     } &lt;/p&gt;
&lt;p&gt;(2)const修饰成员函数&lt;br&gt;const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。&lt;br&gt;    class A&lt;br&gt;    {&lt;br&gt;        …&lt;br&gt;       void function()const; //常成员函数, 它不改变对象的成员变量.                        &lt;/p&gt;
&lt;p&gt;//也不能调用类中任何非const成员函数。&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。&lt;/p&gt;
&lt;p&gt;a. const成员函数不被允许修改它所在对象的任何一个数据成员。&lt;/p&gt;
&lt;p&gt;b. const成员函数能够访问对象的const成员，而其他成员函数不可以。&lt;/p&gt;
&lt;p&gt;(3)const修饰类对象/对象指针/对象引用&lt;/p&gt;
&lt;p&gt;·             const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。&lt;/p&gt;
&lt;p&gt;·             const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。&lt;br&gt;例如：&lt;br&gt;class AAA&lt;br&gt;{&lt;br&gt;    void func1();&lt;br&gt;void func2() const;&lt;br&gt;}&lt;br&gt;const AAA aObj;&lt;br&gt;aObj.func1(); ×&lt;br&gt;aObj.func2(); 正确&lt;/p&gt;
&lt;p&gt;const AAA* aObj = new AAA();&lt;br&gt;aObj-&amp;gt; func1(); ×&lt;br&gt;aObj-&amp;gt; func2(); 正确&lt;/p&gt;
&lt;h1 id=&quot;将Const类型转化为非Const类型的方法&quot;&gt;&lt;a href=&quot;#将Const类型转化为非Const类型的方法&quot; class=&quot;headerlink&quot; title=&quot;将Const类型转化为非Const类型的方法&quot;&gt;&lt;/a&gt;将Const类型转化为非Const类型的方法&lt;/h1&gt;&lt;p&gt;采用const_cast 进行转换。&lt;br&gt;用法：const_cast &lt;type_id&gt;  (expression)&lt;br&gt;该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。&lt;/type_id&gt;&lt;/p&gt;
&lt;p&gt;·             常量指针被转化成非常量指针，并且仍然指向原来的对象；&lt;/p&gt;
&lt;p&gt;·             常量引用被转换成非常量引用，并且仍然指向原来的对象；&lt;/p&gt;
&lt;p&gt;·             常量对象被转换成非常量对象。&lt;/p&gt;
&lt;h1 id=&quot;使用const的一些建议&quot;&gt;&lt;a href=&quot;#使用const的一些建议&quot; class=&quot;headerlink&quot; title=&quot;使用const的一些建议&quot;&gt;&lt;/a&gt;使用const的一些建议&lt;/h1&gt;&lt;p&gt;·             要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委；&lt;br&gt;·             要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题；&lt;br&gt;·             在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上；&lt;br&gt;·             const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；&lt;br&gt;·             不要轻易的将函数的返回值类型定为const;&lt;br&gt;·             除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;&lt;br&gt;·             任何不会修改数据成员的函数都应该声明为const 类型。&lt;/p&gt;
&lt;h1 id=&quot;补充重要说明&quot;&gt;&lt;a href=&quot;#补充重要说明&quot; class=&quot;headerlink&quot; title=&quot;补充重要说明&quot;&gt;&lt;/a&gt;补充重要说明&lt;/h1&gt;&lt;p&gt;·             类内部的常量限制：使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式&lt;/p&gt;
&lt;p&gt;初始化的整型或枚举类型，而且必须是static和const形式。&lt;/p&gt;
&lt;p&gt;·             如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如：&lt;/p&gt;
&lt;p&gt;class A { public: A() {} private: static const int i; file://注意必须是静态的！ }；&lt;/p&gt;
&lt;p&gt;const int A::i=3;另一个很常见的方法就是初始化列表： class A { public: A(int&lt;/p&gt;
&lt;p&gt;i=0):test(i) {} private: const int i; }； 还有一种方式就是在外部初始化，&lt;/p&gt;
&lt;p&gt;·             如果在非const成员函数中，this指针只是一个类类型的；如果在const成员函数中，&lt;/p&gt;
&lt;p&gt;this指针是一个const类类型的；如果在volatile成员函数中,this指针就是一个&lt;/p&gt;
&lt;p&gt;volatile类类型的。&lt;/p&gt;
&lt;p&gt;·             new返回的指针必须是const类型的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;【原文&lt;a href=&quot;http://blog.csdn.net/Eric_Jo/article/details/4138548】&quot;&gt;http://blog.csdn.net/Eric_Jo/article/details/4138548】&lt;/a&gt;&lt;br&gt;C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。&lt;br&gt;Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。&lt;/p&gt;
&lt;h1 id=&quot;Const作用&quot;&gt;&lt;a href=&quot;#Const作用&quot; class=&quot;headerlink&quot; title=&quot;Const作用&quot;&gt;&lt;/a&gt;Const作用&lt;/h1&gt;&lt;p&gt;   如下图所示：&lt;br&gt;&lt;img src=&quot;http://v2.freep.cn/3tb_160407234443rs9v512293.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="const" scheme="http://yoursite.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>c++资源汇总</title>
    <link href="http://yoursite.com/2016/04/01/c-%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2016/04/01/c-资源汇总/</id>
    <published>2016-04-01T13:48:14.000Z</published>
    <updated>2016-04-01T13:49:20.579Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhixing/archive/2013/06/04/3116814.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;c++ char&lt;em&gt;, const char&lt;/em&gt;, string 的相互转换&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhixing/archive/2013/06/04/3116814.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;c++ char&lt;em&gt;, const char&lt;/em&gt;, st
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>learn to detect partially overlapping instance笔记</title>
    <link href="http://yoursite.com/2016/03/31/learn-to-detect-partially-overlapping-instance%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/31/learn-to-detect-partially-overlapping-instance笔记/</id>
    <published>2016-03-31T02:28:03.000Z</published>
    <updated>2016-03-31T08:15:35.291Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：本文的工作就是找到一副图片中某一类（细胞或人类）的所有实例。这些实例可能部分重叠或聚在一起，目前来说这对传统算法很困难，传统的方法主要是找到单个实例。&lt;br&gt;&lt;strong&gt;方法&lt;/strong&gt;：找到候选区域，然后优化全局的分类得分来找到这个选择区域，使这个选择区域满足非重叠的约束。本文新贡献是通过引入对象的元组单独的类到检测过程来扩展标准的对象检测。例如我们的检测器可以挑选含有两个或三个对象实例的区域中，而分配这样的区域适当标签。本文表明，使用结构化输出的SVM框架可以找到这个实例的区域。并且使用数构造区域图上的动态规划完成这个模型的推断。此外，这个学习只需要一个弱创新——每个实例用点表示。&lt;br&gt;&lt;strong&gt;数据&lt;/strong&gt;：荧光显微镜图像和UCSD行人。&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;大多数计算机视觉方法有两个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一类是基于独立物体识别。这类识别主要基于滑动窗口和Hough变换。这些方法有：&lt;ul&gt;
&lt;li&gt;近似非最大值抑制[3,8,14]&lt;/li&gt;
&lt;li&gt;随机匹配感兴趣部分或对象模型[9,10,24]&lt;/li&gt;
&lt;li&gt;基于区域检测[2,18,19]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二类不是检测独立实例，而是基于局部或全局上下文分析和外观描述。这些方法有：&lt;ul&gt;
&lt;li&gt;图片中物体的总体实值计数[5,12,16,22]&lt;/li&gt;
&lt;li&gt;推测每一个感兴趣区域的局部物体的真实密度[11,15]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;低重叠上述方法可以，但是高密度图像性能表现就会差很多。低密度与高密度共存的情况上述两种方法的性能并不好。这就促使我们在这里提出的方法。这个方法是简历载我们区域探测方法的基础之上的[2]。这主要方法的创新点在于能够分析输入图像，检测不同尺寸的对象（大小为1的“群”是一个特殊的情况）。通过对一组弱注释的训练图像进行训练，所提出的方法根据对象木渎的不痛那个学习不同组的大小。因此，与局部密度估计想死，这样可避免试图当它们成簇一起辨别各个对象。又不像局部密度评估，但是，该方法能够判断每个簇的中对象的数量。&lt;br&gt;与我们最初的方法[2]一样，解析过程是根据有效且精确的推理过程，这个过程检测提供一个最大的解析功能的一组非重叠的极值的区域的。学习是在一个结构化的框架，SVM执行和优化（凸上界）计数的损失。我们观察到这样的学习产生了理想的偏向喜欢最详细的解释，例如，选择最小尺寸的群体，只要对象是明显的，因为这种策略往往会提供最高的计算精度。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：本文的工作就是找到一副图片中某一类（细胞或人类）的所有实例。这些实例可能部分重叠或聚在一起，目前来说
    
    </summary>
    
      <category term="论文笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="overlapping" scheme="http://yoursite.com/tags/overlapping/"/>
    
  </entry>
  
  <entry>
    <title>部分优化算法对比</title>
    <link href="http://yoursite.com/2016/03/29/%E9%83%A8%E5%88%86%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2016/03/29/部分优化算法对比/</id>
    <published>2016-03-29T14:46:13.000Z</published>
    <updated>2016-03-29T14:49:32.398Z</updated>
    
    <content type="html">&lt;p&gt;#部分优化算法对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度下降法，基于目标函数梯度的，算法的收敛速度是线性的，并且当问题是病态时或者问题规模较大时，收敛速度尤其慢（几乎不适用）；&lt;/li&gt;
&lt;li&gt;坐标下降法，虽然不用计算目标函数的梯度，但是其收敛速度依然很慢，因此它的适用范围也有局限；&lt;/li&gt;
&lt;li&gt;牛顿法，基于目标函数的二次阶导数（海森矩阵，二阶导数矩阵）的，其收敛速度较快，迭代次数较少，尤其是在最优值附件时，收敛速度是二次的。&lt;strong&gt;问题&lt;/strong&gt;在于当海森矩阵稠密时，每次迭代的计算量比较大时，不仅计算量大（有时大到不可计算）而且需要的存储空间也多，因此牛顿法载面对海量数据时由于每一步迭代的开销巨大而变得不适用。牛顿法在每次迭代时不恩能够综述保证海森矩阵是正定的，一旦海森矩阵不是正定，优化方向就会“跑偏”，从而使得牛顿法失效，也说明了牛顿法的鲁班性较差&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;拟牛顿法，在牛顿法的基础上引入了海森矩阵的近似矩阵，避免每次迭代都要计算海森矩阵的逆，逆牛顿法的收敛速度介于梯度下降法和牛顿法之间，是超线性的。拟牛顿法的问题也是当问题规模很大时，近似矩阵变得&lt;strong&gt;很稠密&lt;/strong&gt;，在计算和存储上也有很大的开销，因此变得不适用。用海森矩阵的逆矩阵来替代还是票矩阵，虽然每次迭代不能保证是最优的优化方向，但是近似矩阵始终是正定的，因此算法总是朝着最优值的方向载搜索。&lt;/li&gt;
&lt;li&gt;L-BFGS算法是对牛顿算法的一个改进，适合实际工程中解决大规模优化问题，L-BFGS算法的基本思想是：算法只保存并利用最近m次迭代的曲率信息来构造海森矩阵的近似距离。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#部分优化算法对比&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度下降法，基于目标函数梯度的，算法的收敛速度是线性的，并且当问题是病态时或者问题规模较大时，收敛速度尤其慢（几乎不适用）；&lt;/li&gt;
&lt;li&gt;坐标下降法，虽然不用计算目标函数的梯度，但是其收敛速度依然很慢，因此它的适用范围也有局限；&lt;/li&gt;
&lt;li&gt;牛顿法，基于目标函数的二次阶导数（海森矩阵，二阶导数矩阵）的，其收敛速度较快，迭代次数较少，尤其是在最优值附件时，收敛速度是二次的。&lt;strong&gt;问题&lt;/strong&gt;在于当海森矩阵稠密时，每次迭代的计算量比较大时，不仅计算量大（有时大到不可计算）而且需要的存储空间也多，因此牛顿法载面对海量数据时由于每一步迭代的开销巨大而变得不适用。牛顿法在每次迭代时不恩能够综述保证海森矩阵是正定的，一旦海森矩阵不是正定，优化方向就会“跑偏”，从而使得牛顿法失效，也说明了牛顿法的鲁班性较差
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="优化算法" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2015年总结</title>
    <link href="http://yoursite.com/2016/03/29/my2015/"/>
    <id>http://yoursite.com/2016/03/29/my2015/</id>
    <published>2016-03-29T14:40:29.000Z</published>
    <updated>2016-03-29T14:41:59.014Z</updated>
    
    <content type="html">&lt;p&gt;在家度过了最寒冷的冬天，再次回到魔都。每次回家都是精神彻底的放松，不管在外面有着多么大的压力，只要回到家就不想思考，不想活动，不想论文、不想将来的工作。但是，就像太阳总是要出来一样，我也还是要回到学校中来了。学校里的梅花都盛开了，学生们都已经回到校园了，而我是时候为对去年做一个总结，对新年开启篇新的展望了。&lt;br&gt;去年一月份的时候，我想抽出时间来写一篇总结，记忆已经模糊，忘了是因为什么而忽略了这份迟早要到来的总结。今天刚刚下完课，就乘着这个时候把我放在显微镜下剖析一下了吧。&lt;br&gt;过去的一年，在我的记忆立总是灰蒙蒙的，大概是受到了雾霾的影响吧。去年主要经历归纳为一条线为：考研——调剂——毕设——暑假学习——开学。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一、考研&quot;&gt;&lt;a href=&quot;#第一、考研&quot; class=&quot;headerlink&quot; title=&quot;第一、考研&quot;&gt;&lt;/a&gt;第一、考研&lt;/h1&gt;&lt;p&gt;　　决定的是考华科，15年分数线涨了有二三十分，差一点，最后调剂到了上海大学。虽然最后没有考上一个理想的分数，但是这一年的经历还是让我记忆深刻。&lt;br&gt;　　从最开始的浮躁的准备着数学，英语，到最后慢慢沉下心来一点一点的复习，慢慢专注；做模拟卷子的时候，困难重重，一度认为自己没有希望了，差一点就放弃了，谢谢同伴的鼓励，谢谢女友的支持，同时也要感谢大学期间看的书籍，让我坚持了下来；找一个与你志同道合的人一起做一件事情，这个过程中相互鼓励，相互影响，一起加油。&lt;br&gt;　　当然这其中的问题还是有不少的。特别是数学，遇到问题，看了答案，恩，知道解了。但是下次遇到类似的题目，甚至是一模一样的题目，我还是做不对。这个问题很严重，遇到一个知识点的时候，一定要理解，自己愚钝点，那就把这个知识点的东西背下来，抄下来，将来的某一天总是会理解的。切记贪多嚼不烂！！！把看过的东西，啃完了再进行下一个。日子长着呢，厚积才能薄发！！！！！&lt;br&gt;　　&lt;img src=&quot;http://ww1.sinaimg.cn/large/d1ac17f6jw1e8brr4r4y3j20ez06zq54.jpg&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;　　&lt;br&gt;　　选择调剂到上海大学。记得当时复试完了之后，自己的内心是一种失望。是对自己失望，还是对自己没有考上华科失望？其实这个已经不重要了。利用好接下来的每一分钟吧。　　&lt;/p&gt;
&lt;h1 id=&quot;二、还未起步的创业&quot;&gt;&lt;a href=&quot;#二、还未起步的创业&quot; class=&quot;headerlink&quot; title=&quot;二、还未起步的创业&quot;&gt;&lt;/a&gt;二、还未起步的创业&lt;/h1&gt;&lt;p&gt;　　那时我有一个想法，做一款时间管理软件app，让你的时间能够产生价值。跟勇哥还有斯斯说了这件事情，将我的想法跟他们详细的描述了一下。问问他们这个想法怎么样。他们都觉得不错，于是每周抽出一天来讨论我们开始提需求，试用其他类似产品的app，使用报告，设计功能，功能排序，界面设计。完成上面的几步，就开始着手写代码了。但是我们三个人都没有写app的经验，准备让斯斯学习安卓开发。后来由于课程比较多，慢慢每周也就没有讨论了，也只有勇哥做了一点点网页的部分。&lt;br&gt;    　在刚开始设计的时候，还是很有动力，每天都在学习这，走路都在思考。可是到后来做的时候，因为各种原因，而放弃了。这个事情一定要引起警戒，畅想的那么美好，竟然连第一步都没有迈出去。我感觉创业把第一步迈出去，一定要把第一步迈出去！！！&lt;/p&gt;
&lt;h1 id=&quot;三、2015年书单&quot;&gt;&lt;a href=&quot;#三、2015年书单&quot; class=&quot;headerlink&quot; title=&quot;三、2015年书单&quot;&gt;&lt;/a&gt;三、2015年书单&lt;/h1&gt;&lt;p&gt;　　“读万卷书，行万里路”，我没有办法到达世界的每一个地方，不能面对面与大牛交谈，不能接受名师的面授，我能做的就是靠读书来“神游”了。&lt;br&gt;　　我阅读的书分为技术与非技术。看书的速度也是时快时慢，有选择性看书。每次选书的时候，我想了解哪一个方面的知识，我就百度这个方面的推荐书籍。买了一个Kindle， 我可以随时随地给自己充电。&lt;br&gt;　　包括以下：&lt;br&gt;技术类：&lt;br&gt;　　《Pattern Recognition and Machine Learning》（在读）&lt;br&gt;　　《统计学习方法》（在读）&lt;br&gt;　　《快学scala》&lt;br&gt;　　《Spark大数据处理计数》&lt;br&gt;　　《R语言实战》&lt;br&gt;　　《使用python进行数据分析》&lt;br&gt;　　《python自然语言处理》（在读）&lt;br&gt;　　《算法导论》（基本算法）&lt;br&gt;非技术：&lt;br&gt;　　《知日-明治维新》&lt;br&gt;　　《九型人格》&lt;br&gt;　　《二胡》&lt;br&gt;　　《牛棚杂记》&lt;br&gt;　　《人类简史》&lt;br&gt;　　《时间简史》&lt;br&gt;　　《史玉柱自述》&lt;br&gt;　　《少年凯哥》&lt;br&gt;　　《21岁当总裁》&lt;br&gt;　　《统计数字会撒谎》&lt;br&gt;　　《奇特的一生》&lt;br&gt;　　《黑天鹅》&lt;br&gt;　　《人人都是产品经理》&lt;br&gt;　　《暗时间》&lt;br&gt;　　《拖延心理学》&lt;br&gt;　　《集装箱改变世界》&lt;br&gt;　　《秘密》&lt;br&gt;　　《IT创业疯魔史》&lt;br&gt;　　《如何阅读一本书》&lt;br&gt;　　《思考：快与慢》&lt;br&gt;　　《番茄工作法》&lt;br&gt;　　《乌合之众》三卷&lt;br&gt;　　《风口上的猪》&lt;br&gt;　　《旁观者》&lt;br&gt;　　《用户体验要素有感》&lt;br&gt;　　《历史的教训》&lt;br&gt;　　《卓有成效的管理者》&lt;br&gt;　　《吃掉那只青蛙》&lt;br&gt;　　《从0到1》&lt;br&gt;　　《我是这样拿到风投》&lt;br&gt;　　《怪诞行为学》&lt;br&gt;　　《精益创业》&lt;/p&gt;
&lt;h1 id=&quot;2016年期望&quot;&gt;&lt;a href=&quot;#2016年期望&quot; class=&quot;headerlink&quot; title=&quot;2016年期望&quot;&gt;&lt;/a&gt;2016年期望&lt;/h1&gt;&lt;p&gt;1、发表一篇论文&lt;br&gt;2、找到一个好的实习&lt;br&gt;3、常读书&lt;br&gt;4、专心干好每件事（一件一件干好再干下一件事情）&lt;br&gt;5、每天工作看书不少于10个小时&lt;br&gt;6、学习如何挣钱&lt;br&gt;7、学习一门技能：Spark，深入源码&lt;br&gt;8、看过的每一个机器学习算法，写一篇博客，最好使用或者编写过代码。以scikitlearn库为中心！&lt;/p&gt;
&lt;p&gt;明天的阳光明媚，取决于今天的汗水！！Fighting吧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在家度过了最寒冷的冬天，再次回到魔都。每次回家都是精神彻底的放松，不管在外面有着多么大的压力，只要回到家就不想思考，不想活动，不想论文、不想将来的工作。但是，就像太阳总是要出来一样，我也还是要回到学校中来了。学校里的梅花都盛开了，学生们都已经回到校园了，而我是时候为对去年做一个总结，对新年开启篇新的展望了。&lt;br&gt;去年一月份的时候，我想抽出时间来写一篇总结，记忆已经模糊，忘了是因为什么而忽略了这份迟早要到来的总结。今天刚刚下完课，就乘着这个时候把我放在显微镜下剖析一下了吧。&lt;br&gt;过去的一年，在我的记忆立总是灰蒙蒙的，大概是受到了雾霾的影响吧。去年主要经历归纳为一条线为：考研——调剂——毕设——暑假学习——开学。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>spark探秘 </title>
    <link href="http://yoursite.com/2016/03/29/spark/"/>
    <id>http://yoursite.com/2016/03/29/spark/</id>
    <published>2016-03-29T14:28:24.000Z</published>
    <updated>2016-03-29T14:55:54.558Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1、spark简介&quot;&gt;&lt;a href=&quot;#1、spark简介&quot; class=&quot;headerlink&quot; title=&quot;1、spark简介&quot;&gt;&lt;/a&gt;1、spark简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-这是什么？&quot;&gt;&lt;a href=&quot;#1-1-这是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.1 这是什么？&quot;&gt;&lt;/a&gt;1.1 这是什么？&lt;/h2&gt;&lt;p&gt;  &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Spark于2009年诞生于加州大学伯克利分校AMPLab（出身高贵呀）。目前，已经成为Apache软件基金会旗下的顶级项目（后妈同样很强）。Spark是基于内存计算的大数据并行计算架构。这里面有两个概念：内存计算，并行计算架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存计算，把数据放在内存中，运算的时候从内存中读取数据，而不是从硬盘中读取数据。&lt;/li&gt;
&lt;li&gt;并行计算框架，使用多台计算机同时工作解决一件计算任务的框架。&lt;h2 id=&quot;1-2-优势&quot;&gt;&lt;a href=&quot;#1-2-优势&quot; class=&quot;headerlink&quot; title=&quot;1.2.优势&quot;&gt;&lt;/a&gt;1.2.优势&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;支持复杂查询。（能干的活多）&lt;/li&gt;
&lt;li&gt;轻量级快速处理。（代码少，速度快）&lt;/li&gt;
&lt;li&gt;易于使用。支持Scala.java.python编写程序，最新版的Spark1.4还支持R语言。&lt;/li&gt;
&lt;li&gt;于HDFS等存储层兼容。（Spark只负责计算，存储使用其他存储层）&lt;/li&gt;
&lt;li&gt;社区活跃程度高。（很多人支持，不怕倒下）&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-3-Spark生态系统BDAS&quot;&gt;&lt;a href=&quot;#1-3-Spark生态系统BDAS&quot; class=&quot;headerlink&quot; title=&quot;1.3.Spark生态系统BDAS&quot;&gt;&lt;/a&gt;1.3.Spark生态系统BDAS&lt;/h2&gt;伯克利将Spark的整个生态系统称为伯克利数据分析栈（BDAS).其核心是Spark，围绕着Spark有着一系列的子项目，提供了更高层/更丰富的计算范式。底层同时也有其他重量级的选手，如分布式内存文件系统Tachyon,分布式文件系统HDFS,资源管理框架Mesos。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://www.2cto.com/uploadfile/2014/1203/20141203021322155.png&quot; alt=&quot;BDAS项目结构图&quot;&gt;&lt;br&gt;（1）Spark&lt;br&gt;Spark是整个BDAS的核心组件，是一个大数据分布式编程框架，不仅实现了MapReduce的算子map 函数和reduce函数及计算模型，还提供更为丰富的算子，如filter、join、groupByKey等。Spark将分布式数据抽象为弹性分布式数据集（RDD），实现了应用任务调度、RPC、序列化和压缩，并为运行在其上的上层组件提供API。其底层采用Scala这种函数式语言书写而成，并且所提供的API深度借鉴Scala函数式的编程思想，提供与Scala类似的编程接口。&lt;/p&gt;
&lt;p&gt;（2）Shark&lt;br&gt;Shark是构建在Spark和Hive基础之上的数据仓库。目前，Shark已经完成学术使命，终止开发，但其架构和原理仍具有借鉴意义。它提供了能够查询Hive中所存储数据的一套SQL接口，兼容现有的Hive QL语法。这样，熟悉Hive QL或者SQL的用户可以基于Shark进行快速的Ad-Hoc、Reporting等类型的SQL查询。Shark底层复用Hive的解析器、优化器以及元数据存储和序列化接口。Shark会将Hive QL编译转化为一组Spark任务，进行分布式运算。&lt;/p&gt;
&lt;p&gt;（3）Spark SQL&lt;br&gt;Spark SQL提供在大数据上的SQL查询功能，类似于Shark在整个生态系统的角色，它们可以统称为SQL on Spark。之前，Shark的查询编译和优化器依赖于Hive，使得Shark不得不维护一套Hive分支，而Spark SQL使用Catalyst做查询解析和优化器，并在底层使用Spark作为执行引擎实现SQL 的Operator。用户可以在Spark上直接书写SQL，相当于为Spark扩充了一套SQL算子，这无疑更加丰富了Spark的算子和功能，同时Spark SQL不断兼容不同的持久化存储（如HDFS、Hive等），为其发展奠定广阔的空间。&lt;/p&gt;
&lt;p&gt;（4）Spark Streaming&lt;br&gt;Spark Streaming通过将流数据按指定时间片累积为RDD，然后将每个RDD进行批处理，进而实现大规模的流数据处理。其吞吐量能够超越现有主流流处理框架Storm，并提供丰富的API用于流数据计算。&lt;/p&gt;
&lt;p&gt;（5）GraphX&lt;br&gt;GraphX基于BSP模型，在Spark之上封装类似Pregel的接口，进行大规模同步全局的图计算，尤其是当用户进行多轮迭代时，基于Spark内存计算的优势尤为明显。&lt;/p&gt;
&lt;p&gt;（6）Tachyon&lt;br&gt;Tachyon是一个分布式内存文件系统，可以理解为内存中的HDFS。为了提供更高的性能，将数据存储剥离Java Heap。用户可以基于Tachyon实现RDD或者文件的跨应用共享，并提供高容错机制，保证数据的可靠性。&lt;/p&gt;
&lt;p&gt;（7）Mesos&lt;br&gt;Mesos是一个资源管理框架，提供类似于YARN的功能。用户可以在其中插件式地运行Spark、MapReduce、Tez等计算框架的任务。Mesos会对资源和任务进行隔离，并实现高效的资源任务调度。&lt;/p&gt;
&lt;p&gt;（8）BlinkDB&lt;br&gt;BlinkDB是一个用于在海量数据上进行交互式 SQL 的近似查询引擎。它允许用户通过在查询准确性和查询响应时间之间做出权衡，完成近似查询。其数据的精度被控制在允许的误差范围内。为了达到这个目标，BlinkDB的核心思想是：通过一个自适应优化框架，随着时间的推移，从原始数据建立并维护一组多维样本；通过一个动态样本选择策略，选择一个适当大小的示例，然后基于查询的准确性和响应时间满足用户查询需求。&lt;/p&gt;
&lt;h2 id=&quot;1-4-Spark架构&quot;&gt;&lt;a href=&quot;#1-4-Spark架构&quot; class=&quot;headerlink&quot; title=&quot;1.4.Spark架构&quot;&gt;&lt;/a&gt;1.4.Spark架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.2cto.com/uploadfile/2014/1203/20141203022320916.png&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;Spark集群成功部署了之后，需要在主节点和从节点分别启动Master进程和Worker进程。Client客户机将计算任务提交到主节点中的master进程，master进程找到一个worker启动Driver，Driver向Master或ClusterManager申请资源，之后将任务转化成RDD DAG，DAGScheduler将RDD DAG转化位Stage的有向无环图图提交给TaskScheduler，再又TaskScheduler提交计算任务给Executor执行。&lt;/p&gt;
&lt;h1 id=&quot;2-RDD的Transformations操作&quot;&gt;&lt;a href=&quot;#2-RDD的Transformations操作&quot; class=&quot;headerlink&quot; title=&quot;2.RDD的Transformations操作&quot;&gt;&lt;/a&gt;2.RDD的Transformations操作&lt;/h1&gt;&lt;h2 id=&quot;2-1、简介&quot;&gt;&lt;a href=&quot;#2-1、简介&quot; class=&quot;headerlink&quot; title=&quot;2.1、简介&quot;&gt;&lt;/a&gt;2.1、简介&lt;/h2&gt;&lt;p&gt;　　Spark中的核心数据模型是弹性分布式数据集（RDD），而弹性分布式数据集（RDD）是个抽象类，具体的实现是由各个子类实现的。Spark将常用的大数据操作都转换为对RDD的子类操作。&lt;br&gt;　　Transformation操作的对象有两种：Value数据类型，Key-Value数据类型。下面将这两种数据类型的操作列出来：&lt;/p&gt;
&lt;h2 id=&quot;2-2、Translation操作&quot;&gt;&lt;a href=&quot;#2-2、Translation操作&quot; class=&quot;headerlink&quot; title=&quot;2.2、Translation操作&quot;&gt;&lt;/a&gt;2.2、Translation操作&lt;/h2&gt;&lt;h3 id=&quot;2-1-Value数据类型&quot;&gt;&lt;a href=&quot;#2-1-Value数据类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 Value数据类型&quot;&gt;&lt;/a&gt;2.1 Value数据类型&lt;/h3&gt;&lt;p&gt;map(func)&lt;br&gt;　　将原来RDD中的每个元素通过自定义函数func转换为一个包含新元素的RDD。&lt;/p&gt;
&lt;p&gt;filter(func)&lt;br&gt;　　对原有RDD中的元素进行过滤，每个元素输入到func函数中，如果func函数返回为true则保留，返回false则丢弃。&lt;/p&gt;
&lt;p&gt;flatMap(func)&lt;br&gt;　　功能与map相似，但是输出的是一个集合。&lt;/p&gt;
&lt;p&gt;mapPatitions(func)&lt;br&gt;　　功能与map相似，但是mapPatitions获取的是每个分区的迭代器。&lt;/p&gt;
&lt;p&gt;mapPationsWithIndex(func)&lt;br&gt;　　功能与mapPatitions相似，但是func函数要返回一个表示分区index的interger类型的值&lt;/p&gt;
&lt;p&gt;sanple(withReplacement, fraction, seed)&lt;br&gt;　　对数据集中的数据进行采样，想成一个新的RDD&lt;/p&gt;
&lt;p&gt;union(otherDateset)&lt;br&gt;　　将两个数据类型相同的RDD合并成一个RDD&lt;/p&gt;
&lt;p&gt;intersection(oterDataset)&lt;br&gt;　　返回一个包含两个数据类型相同的RDD的交集的全新的RDD&lt;/p&gt;
&lt;p&gt;distinct([numTasks])&lt;br&gt;　　对RDD中的元素进行去重操作&lt;/p&gt;
&lt;p&gt;cartesian(otherDataset)&lt;br&gt;　　对两个RDD内的所有元素进行笛卡尔积操作。&lt;/p&gt;
&lt;p&gt;pip(command, [envVars])&lt;br&gt; 　　对RDD的每个分区通过脚本命令，RDD元素可以写入进程的stdin和行输出到标准输出作为字符串返回。&lt;/p&gt;
&lt;p&gt; coalesce(numPartitions)&lt;br&gt;  　　设置RDD数据的分区数，可以让数据集的操作更加高校。&lt;/p&gt;
&lt;p&gt;  repartition(numPartitions)&lt;br&gt;  　　修改RDD数据的分区数&lt;/p&gt;
&lt;p&gt;  repartionAndSortWithinPartitions(pationer)&lt;br&gt;  　　重新设置RDD分区，根据keys值排序，这个比repartition更加高效。&lt;/p&gt;
&lt;h3 id=&quot;2-2-Key-value类型&quot;&gt;&lt;a href=&quot;#2-2-Key-value类型&quot; class=&quot;headerlink&quot; title=&quot;2.2 Key-value类型&quot;&gt;&lt;/a&gt;2.2 Key-value类型&lt;/h3&gt;&lt;p&gt;groupByKey([numTasks])&lt;br&gt;　　返回一个（k, iterable&lt;v&gt;)键值对&lt;br&gt;　　注意:如果你分组是为了执行一个聚合(比如求和或平均),使用reduceByKey或aggregateByKey将有更好的性能。&lt;br&gt;　　注意:默认情况下,并行输出的分区数取决于父抽样的分区的数量。您可以通过一个可选的numTasks参数设置不同数量的任务。&lt;br&gt;　　&lt;br&gt;reduceByKey(func, [numTasks])&lt;br&gt;　　对k相同的键值对中的值调用func函数，合并产生一个值&lt;br&gt;　　&lt;br&gt;aggregateByKey(zeroValue)(seqOp, combOp, [numTasks])&lt;br&gt;　　当对(K、V)的数据集对调用函数时,返回一个数据集的(K,U)对每个键值聚合使用给定的组合功能和一个中立的“0”值。允许产生的聚合值类型不同于输入值类型,同时避免不必要的配置。而在groupByKey中,需要配置第二个参数。&lt;br&gt;　　&lt;br&gt;sortedByKey([ascending], [numTasks])&lt;br&gt;　　返回一个按照k值进行排序的键值对RDD。&lt;/v&gt;&lt;/p&gt;
&lt;p&gt;cogroup(oterDataset, [numTasks])&lt;br&gt;　　对两个RDD进行协同划分，每个RDD中形同Key的元素分别聚合为一个集合，并且返回两个RDD中对应key中的元素集合的迭代器。&lt;/p&gt;
&lt;p&gt;join(otherDataset, [numTasks])&lt;br&gt;　　对俩个需要连接的RDD进行cogroup函数操作，cogroup原理如上，cogroup操作后形成的新的RDD，对每个Key下的元素进行笛卡尔积操作，返回结果在展平。&lt;/p&gt;
&lt;h1 id=&quot;3-RDD的action操作&quot;&gt;&lt;a href=&quot;#3-RDD的action操作&quot; class=&quot;headerlink&quot; title=&quot;3.RDD的action操作&quot;&gt;&lt;/a&gt;3.RDD的action操作&lt;/h1&gt;&lt;p&gt;本质上，Action通过SparkContext执行提交作业的runjob操作，触发了RDD DAG的执行。&lt;/p&gt;
&lt;p&gt;reduce(func)&lt;br&gt;　　 将集合中的元素通过func函数合并起来，该函数应该是可交换，结合的，这样才能应用到并行计算中。&lt;/p&gt;
&lt;p&gt;collect()&lt;br&gt;　　将数据中的元素返回为一个数组，这个函数通常用在filter等其他操作后。&lt;/p&gt;
&lt;p&gt;count()&lt;br&gt;　　返回数据集中元素的个数&lt;/p&gt;
&lt;p&gt;first()&lt;br&gt;　　返回数据集中的第一个元素&lt;/p&gt;
&lt;p&gt;take(n)&lt;br&gt;　　返回数据集中前n个元素&lt;/p&gt;
&lt;p&gt;takeSample(withReplacement, num, [seed])&lt;br&gt;　　按设定的采样个数进行采样&lt;/p&gt;
&lt;p&gt;takeOrdered(n, [ordering])&lt;br&gt;　　返回前N个RDD中元素的自然顺序或自定义比较器&lt;/p&gt;
&lt;p&gt;saveAsTextFile(path)&lt;br&gt;　　将数据集中的元素存储起来，存在给定的目录中的本地文件系统，或任何其他的Hadoop HDFS 支持的文件系统。Spark可以调用toString将每个元素以每行的形式存在文本中&lt;/p&gt;
&lt;p&gt;savaAsSequenceFile(path)&lt;br&gt;　　将数据集中的RDD以Hadoop SequenceFile的形式存在给定路径本地的文件系统，HDFS或者其他任何Hadoop支持的文件系统中。这个对读取存在Hadoop中健值对十分有用。&lt;/p&gt;
&lt;p&gt;saveAsObjectFile(path)&lt;br&gt;　　使用java序列化将数据集中的元素存储为一个简单的格式，我们可以通过SparkContext.objectFile()进行读取。&lt;/p&gt;
&lt;p&gt;countBykey()&lt;br&gt;　　返回具有不同健的键值对的个数&lt;/p&gt;
&lt;p&gt;foreach(func)&lt;br&gt;　　对RDD中的每个元素应用func函数，不返回RDD和Arry，而是返回Uint。&lt;/p&gt;
&lt;p&gt;#参考书籍&lt;br&gt;《Spark大数据处理：技术、应用与性能优化》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、spark简介&quot;&gt;&lt;a href=&quot;#1、spark简介&quot; class=&quot;headerlink&quot; title=&quot;1、spark简介&quot;&gt;&lt;/a&gt;1、spark简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-这是什么？&quot;&gt;&lt;a href=&quot;#1-1-这是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.1 这是什么？&quot;&gt;&lt;/a&gt;1.1 这是什么？&lt;/h2&gt;&lt;p&gt;  &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Spark于2009年诞生于加州大学伯克利分校AMPLab（出身高贵呀）。目前，已经成为Apache软件基金会旗下的顶级项目（后妈同样很强）。Spark是基于内存计算的大数据并行计算架构。这里面有两个概念：内存计算，并行计算架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存计算，把数据放在内存中，运算的时候从内存中读取数据，而不是从硬盘中读取数据。&lt;/li&gt;
&lt;li&gt;并行计算框架，使用多台计算机同时工作解决一件计算任务的框架。&lt;h2 id=&quot;1-2-优势&quot;&gt;&lt;a href=&quot;#1-2-优势&quot; class=&quot;headerlink&quot; title=&quot;1.2.优势&quot;&gt;&lt;/a&gt;1.2.优势&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;支持复杂查询。（能干的活多）&lt;/li&gt;
&lt;li&gt;轻量级快速处理。（代码少，速度快）&lt;/li&gt;
&lt;li&gt;易于使用。支持Scala.java.python编写程序，最新版的Spark1.4还支持R语言。&lt;/li&gt;
&lt;li&gt;于HDFS等存储层兼容。（Spark只负责计算，存储使用其他存储层）&lt;/li&gt;
&lt;li&gt;社区活跃程度高。（很多人支持，不怕倒下）
    
    </summary>
    
      <category term="spark" scheme="http://yoursite.com/categories/spark/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>vim命令全集</title>
    <link href="http://yoursite.com/2016/03/29/vim%E5%91%BD%E4%BB%A4%E5%85%A8%E9%9B%86/"/>
    <id>http://yoursite.com/2016/03/29/vim命令全集/</id>
    <published>2016-03-29T12:21:27.000Z</published>
    <updated>2016-03-29T13:18:06.950Z</updated>
    
    <content type="html">&lt;h2 id=&quot;命令历史&quot;&gt;&lt;a href=&quot;#命令历史&quot; class=&quot;headerlink&quot; title=&quot;命令历史&quot;&gt;&lt;/a&gt;命令历史&lt;/h2&gt;&lt;p&gt;以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。&lt;/p&gt;
&lt;h2 id=&quot;启动vim&quot;&gt;&lt;a href=&quot;#启动vim&quot; class=&quot;headerlink&quot; title=&quot;启动vim&quot;&gt;&lt;/a&gt;启动vim&lt;/h2&gt;&lt;p&gt;在命令行窗口中输入以下命令即可&lt;/p&gt;
&lt;p&gt;vim 直接启动vim&lt;/p&gt;
&lt;p&gt;vim filename 打开vim并创建名为filename的文件&lt;/p&gt;
&lt;h2 id=&quot;文件命令&quot;&gt;&lt;a href=&quot;#文件命令&quot; class=&quot;headerlink&quot; title=&quot;文件命令&quot;&gt;&lt;/a&gt;文件命令&lt;/h2&gt;&lt;p&gt;打开单个文件&lt;/p&gt;
&lt;p&gt;vim file&lt;/p&gt;
&lt;p&gt;同时打开多个文件&lt;/p&gt;
&lt;p&gt;vim file1 file2 file3 …&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;在vim窗口中打开一个新文件&lt;/p&gt;
&lt;p&gt;:open file&lt;/p&gt;
&lt;p&gt;在新窗口中打开文件&lt;/p&gt;
&lt;p&gt;:split file&lt;/p&gt;
&lt;p&gt;切换到下一个文件&lt;/p&gt;
&lt;p&gt;:bn&lt;/p&gt;
&lt;p&gt;切换到上一个文件&lt;/p&gt;
&lt;p&gt;:bp&lt;/p&gt;
&lt;p&gt;查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。&lt;/p&gt;
&lt;p&gt;:args&lt;/p&gt;
&lt;p&gt;打开远程文件，比如ftp或者share folder&lt;/p&gt;
&lt;p&gt;:e ftp://192.168.10.76/abc.txt&lt;/p&gt;
&lt;p&gt;:e \qadrive\test\1.txt&lt;/p&gt;
&lt;h2 id=&quot;vim的模式&quot;&gt;&lt;a href=&quot;#vim的模式&quot; class=&quot;headerlink&quot; title=&quot;vim的模式&quot;&gt;&lt;/a&gt;vim的模式&lt;/h2&gt;&lt;p&gt;正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空&lt;br&gt;插入模式（按i键进入） 左下角显示–INSERT–&lt;br&gt;可视模式（不知道如何进入） 左下角显示–VISUAL–&lt;/p&gt;
&lt;h2 id=&quot;导航命令&quot;&gt;&lt;a href=&quot;#导航命令&quot; class=&quot;headerlink&quot; title=&quot;导航命令&quot;&gt;&lt;/a&gt;导航命令&lt;/h2&gt;&lt;p&gt;% 括号匹配&lt;/p&gt;
&lt;h2 id=&quot;插入命令&quot;&gt;&lt;a href=&quot;#插入命令&quot; class=&quot;headerlink&quot; title=&quot;插入命令&quot;&gt;&lt;/a&gt;插入命令&lt;/h2&gt;&lt;p&gt;i 在当前位置生前插入&lt;/p&gt;
&lt;p&gt;I 在当前行首插入&lt;/p&gt;
&lt;p&gt;a 在当前位置后插入&lt;/p&gt;
&lt;p&gt;A 在当前行尾插入&lt;/p&gt;
&lt;p&gt;o 在当前行之后插入一行&lt;/p&gt;
&lt;p&gt;O 在当前行之前插入一行&lt;/p&gt;
&lt;h2 id=&quot;查找命令&quot;&gt;&lt;a href=&quot;#查找命令&quot; class=&quot;headerlink&quot; title=&quot;查找命令&quot;&gt;&lt;/a&gt;查找命令&lt;/h2&gt;&lt;p&gt;/text　　查找text，按n健查找下一个，按N健查找前一个。&lt;/p&gt;
&lt;p&gt;?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。&lt;/p&gt;
&lt;p&gt;vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$&lt;/p&gt;
&lt;p&gt;:set ignorecase　　忽略大小写的查找&lt;/p&gt;
&lt;p&gt;:set noignorecase　　不忽略大小写的查找&lt;/p&gt;
&lt;p&gt;查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。&lt;/p&gt;
&lt;p&gt;:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。&lt;/p&gt;
&lt;p&gt;:set nohlsearch　　关闭高亮搜索显示&lt;/p&gt;
&lt;p&gt;:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。&lt;/p&gt;
&lt;p&gt;:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。&lt;/p&gt;
&lt;p&gt;:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。&lt;/p&gt;
&lt;h2 id=&quot;替换命令&quot;&gt;&lt;a href=&quot;#替换命令&quot; class=&quot;headerlink&quot; title=&quot;替换命令&quot;&gt;&lt;/a&gt;替换命令&lt;/h2&gt;&lt;p&gt;ra 将当前字符替换为a，当期字符即光标所在字符。&lt;/p&gt;
&lt;p&gt;s/old/new/ 用old替换new，替换当前行的第一个匹配&lt;/p&gt;
&lt;p&gt;s/old/new/g 用old替换new，替换当前行的所有匹配&lt;/p&gt;
&lt;p&gt;%s/old/new/ 用old替换new，替换所有行的第一个匹配&lt;/p&gt;
&lt;p&gt;%s/old/new/g 用old替换new，替换整个文件的所有匹配&lt;/p&gt;
&lt;p&gt;:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。&lt;/p&gt;
&lt;p&gt;ddp 交换光标所在行和其下紧邻的一行。&lt;/p&gt;
&lt;h2 id=&quot;移动命令&quot;&gt;&lt;a href=&quot;#移动命令&quot; class=&quot;headerlink&quot; title=&quot;移动命令&quot;&gt;&lt;/a&gt;移动命令&lt;/h2&gt;&lt;p&gt;h 左移一个字符&lt;br&gt;l 右移一个字符，这个命令很少用，一般用w代替。&lt;br&gt;k 上移一个字符&lt;br&gt;j 下移一个字符&lt;br&gt;以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！&lt;esc&gt;，这里的Esc是必须的，否则命令不生效。&lt;/esc&gt;&lt;/p&gt;
&lt;p&gt;w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。&lt;/p&gt;
&lt;p&gt;b 向后移动一个单词 2b 向后移动2个单词&lt;/p&gt;
&lt;p&gt;e，同w，只不过是光标停在单词尾部&lt;/p&gt;
&lt;p&gt;ge，同b，光标停在单词尾部。&lt;/p&gt;
&lt;p&gt;^ 移动到本行第一个非空白字符上。&lt;/p&gt;
&lt;p&gt;0（数字0）移动到本行第一个字符上，&lt;/p&gt;
&lt;p&gt;&lt;home&gt; 移动到本行第一个字符。同0健。&lt;/home&gt;&lt;/p&gt;
&lt;p&gt;$ 移动到行尾 3$ 移动到下面3行的行尾&lt;/p&gt;
&lt;p&gt;gg 移动到文件头。 = [[&lt;/p&gt;
&lt;p&gt;G（shift + g） 移动到文件尾。 = ]]&lt;/p&gt;
&lt;p&gt;f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。&lt;/p&gt;
&lt;p&gt;F 同f，反向查找。&lt;/p&gt;
&lt;p&gt;跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。&lt;/p&gt;
&lt;p&gt;Ctrl + e 向下滚动一行&lt;/p&gt;
&lt;p&gt;Ctrl + y 向上滚动一行&lt;/p&gt;
&lt;p&gt;Ctrl + d 向下滚动半屏&lt;/p&gt;
&lt;p&gt;Ctrl + u 向上滚动半屏&lt;/p&gt;
&lt;p&gt;Ctrl + f 向下滚动一屏&lt;/p&gt;
&lt;p&gt;Ctrl + b 向上滚动一屏&lt;/p&gt;
&lt;h2 id=&quot;撤销和重做&quot;&gt;&lt;a href=&quot;#撤销和重做&quot; class=&quot;headerlink&quot; title=&quot;撤销和重做&quot;&gt;&lt;/a&gt;撤销和重做&lt;/h2&gt;&lt;p&gt;u 撤销（Undo）&lt;br&gt;U 撤销对整行的操作&lt;br&gt;Ctrl + r 重做（Redo），即撤销的撤销。&lt;/p&gt;
&lt;h2 id=&quot;删除命令&quot;&gt;&lt;a href=&quot;#删除命令&quot; class=&quot;headerlink&quot; title=&quot;删除命令&quot;&gt;&lt;/a&gt;删除命令&lt;/h2&gt;&lt;p&gt;x 删除当前字符&lt;/p&gt;
&lt;p&gt;3x 删除当前光标开始向后三个字符&lt;/p&gt;
&lt;p&gt;X 删除当前字符的前一个字符。X=dh&lt;/p&gt;
&lt;p&gt;dl 删除当前字符， dl=x&lt;/p&gt;
&lt;p&gt;dh 删除前一个字符&lt;/p&gt;
&lt;p&gt;dd 删除当前行&lt;/p&gt;
&lt;p&gt;dj 删除上一行&lt;/p&gt;
&lt;p&gt;dk 删除下一行&lt;/p&gt;
&lt;p&gt;10d 删除当前行开始的10行。&lt;/p&gt;
&lt;p&gt;D 删除当前字符至行尾。D=d$&lt;/p&gt;
&lt;p&gt;d$ 删除当前字符之后的所有字符（本行）&lt;/p&gt;
&lt;p&gt;kdgg 删除当前行之前所有行（不包括当前行）&lt;/p&gt;
&lt;p&gt;jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）&lt;/p&gt;
&lt;p&gt;:1,10d 删除1-10行&lt;/p&gt;
&lt;p&gt;:11,$d 删除11行及以后所有的行&lt;/p&gt;
&lt;p&gt;:1,$d 删除所有行&lt;/p&gt;
&lt;p&gt;J(shift + j)　　删除两行之间的空行，实际上是合并两行。&lt;/p&gt;
&lt;h2 id=&quot;拷贝和粘贴&quot;&gt;&lt;a href=&quot;#拷贝和粘贴&quot; class=&quot;headerlink&quot; title=&quot;拷贝和粘贴&quot;&gt;&lt;/a&gt;拷贝和粘贴&lt;/h2&gt;&lt;p&gt;yy 拷贝当前行&lt;/p&gt;
&lt;p&gt;nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。&lt;/p&gt;
&lt;p&gt;p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。&lt;/p&gt;
&lt;p&gt;shift+p 在当前行前粘贴&lt;/p&gt;
&lt;p&gt;:1,10 co 20 将1-10行插入到第20行之后。&lt;/p&gt;
&lt;p&gt;:1,$ co $ 将整个文件复制一份并添加到文件尾部。&lt;/p&gt;
&lt;p&gt;正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制&lt;/p&gt;
&lt;p&gt;ddp交换当前行和其下一行&lt;/p&gt;
&lt;p&gt;xp交换当前字符和其后一个字符&lt;/p&gt;
&lt;h2 id=&quot;剪切命令&quot;&gt;&lt;a href=&quot;#剪切命令&quot; class=&quot;headerlink&quot; title=&quot;剪切命令&quot;&gt;&lt;/a&gt;剪切命令&lt;/h2&gt;&lt;p&gt;正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切&lt;/p&gt;
&lt;p&gt;ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴&lt;/p&gt;
&lt;p&gt;:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。&lt;/p&gt;
&lt;p&gt;:1, 10 m 20 将第1-10行移动到第20行之后。&lt;/p&gt;
&lt;h2 id=&quot;退出命令&quot;&gt;&lt;a href=&quot;#退出命令&quot; class=&quot;headerlink&quot; title=&quot;退出命令&quot;&gt;&lt;/a&gt;退出命令&lt;/h2&gt;&lt;p&gt;:wq 保存并退出&lt;/p&gt;
&lt;p&gt;ZZ 保存并退出&lt;/p&gt;
&lt;p&gt;:q! 强制退出并忽略所有更改&lt;/p&gt;
&lt;p&gt;:e! 放弃所有修改，并打开原来文件。&lt;/p&gt;
&lt;h2 id=&quot;窗口命令&quot;&gt;&lt;a href=&quot;#窗口命令&quot; class=&quot;headerlink&quot; title=&quot;窗口命令&quot;&gt;&lt;/a&gt;窗口命令&lt;/h2&gt;&lt;p&gt;:split或new 打开一个新窗口，光标停在顶层的窗口上&lt;/p&gt;
&lt;p&gt;:split file或:new file 用新窗口打开文件&lt;/p&gt;
&lt;p&gt;split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。&lt;/p&gt;
&lt;p&gt;Ctrl+ww 移动到下一个窗口&lt;/p&gt;
&lt;p&gt;Ctrl+wj 移动到下方的窗口&lt;/p&gt;
&lt;p&gt;Ctrl+wk 移动到上方的窗口&lt;/p&gt;
&lt;h2 id=&quot;关闭窗口&quot;&gt;&lt;a href=&quot;#关闭窗口&quot; class=&quot;headerlink&quot; title=&quot;关闭窗口&quot;&gt;&lt;/a&gt;关闭窗口&lt;/h2&gt;&lt;p&gt;:close 最后一个窗口不能使用此命令，可以防止意外退出vim。&lt;/p&gt;
&lt;p&gt;:q 如果是最后一个被关闭的窗口，那么将退出vim。&lt;/p&gt;
&lt;p&gt;ZZ 保存并退出。&lt;/p&gt;
&lt;p&gt;关闭所有窗口，只保留当前窗口&lt;/p&gt;
&lt;p&gt;:only&lt;/p&gt;
&lt;p&gt;录制宏&lt;/p&gt;
&lt;p&gt;按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。&lt;/p&gt;
&lt;h2 id=&quot;执行shell命令&quot;&gt;&lt;a href=&quot;#执行shell命令&quot; class=&quot;headerlink&quot; title=&quot;执行shell命令&quot;&gt;&lt;/a&gt;执行shell命令&lt;/h2&gt;&lt;p&gt;:!command&lt;/p&gt;
&lt;p&gt;:!ls 列出当前目录下文件&lt;/p&gt;
&lt;p&gt;:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。&lt;/p&gt;
&lt;p&gt;:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。&lt;/p&gt;
&lt;p&gt;:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。&lt;/p&gt;
&lt;h2 id=&quot;注释命令&quot;&gt;&lt;a href=&quot;#注释命令&quot; class=&quot;headerlink&quot; title=&quot;注释命令&quot;&gt;&lt;/a&gt;注释命令&lt;/h2&gt;&lt;p&gt;perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#&lt;/p&gt;
&lt;p&gt;3,5 s/^/#/g 注释第3-5行&lt;/p&gt;
&lt;p&gt;3,5 s/^#//g 解除3-5行的注释&lt;/p&gt;
&lt;p&gt;1,$ s/^/#/g 注释整个文档。&lt;/p&gt;
&lt;p&gt;:%s/^/#/g 注释整个文档，此法更快。&lt;/p&gt;
&lt;h2 id=&quot;帮助命令&quot;&gt;&lt;a href=&quot;#帮助命令&quot; class=&quot;headerlink&quot; title=&quot;帮助命令&quot;&gt;&lt;/a&gt;帮助命令&lt;/h2&gt;&lt;p&gt;:help or F1 显示整个帮助&lt;br&gt;:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。&lt;br&gt;:help ‘number’ Vim选项的帮助用单引号括起&lt;br&gt;:help &lt;esc&gt; 特殊键的帮助用&amp;lt;&amp;gt;扩起&lt;br&gt;:help -t Vim启动参数的帮助用-&lt;br&gt;：help i&lt;em&gt;&lt;esc&gt; 插入模式下Esc的帮助，某个模式下的帮助用模式&lt;/esc&gt;&lt;/em&gt;主题的模式&lt;br&gt;帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回&lt;/esc&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他非编辑命令&quot;&gt;&lt;a href=&quot;#其他非编辑命令&quot; class=&quot;headerlink&quot; title=&quot;其他非编辑命令&quot;&gt;&lt;/a&gt;其他非编辑命令&lt;/h2&gt;&lt;p&gt;. 重复前一次命令&lt;/p&gt;
&lt;p&gt;:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看&lt;/p&gt;
&lt;p&gt;:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。&lt;/p&gt;
&lt;p&gt;:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&amp;gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。&lt;/p&gt;
&lt;h2 id=&quot;Vim教程&quot;&gt;&lt;a href=&quot;#Vim教程&quot; class=&quot;headerlink&quot; title=&quot;Vim教程&quot;&gt;&lt;/a&gt;Vim教程&lt;/h2&gt;&lt;p&gt;在Unix系统上&lt;br&gt;$ vimtutor&lt;br&gt;在Windows系统上&lt;br&gt;:help tutor&lt;/p&gt;
&lt;p&gt;:syntax 列出已经定义的语法项&lt;br&gt;:syntax clear 清除已定义的语法规则&lt;br&gt;:syntax case match 大小写敏感，int和Int将视为不同的语法元素&lt;br&gt;:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案&lt;/p&gt;
&lt;p&gt;im提供多窗口编辑的功能，可以简化复合的编辑任务。vim的多窗口并不是说在终端上启动多个vim实例。&lt;/p&gt;
&lt;h2 id=&quot;启动多窗口编辑&quot;&gt;&lt;a href=&quot;#启动多窗口编辑&quot; class=&quot;headerlink&quot; title=&quot;启动多窗口编辑&quot;&gt;&lt;/a&gt;启动多窗口编辑&lt;/h2&gt;&lt;p&gt;viｍ的多窗口是动态的，可以开始编辑时就打开多窗口，也可以工作时随时增加新窗口，或者删除一个窗口。&lt;br&gt;$ vim  -o  file1 file2  打开一个编辑会话，显示为水平分割成两半的窗口，一个文件占用一个窗口。&lt;br&gt;$ vim  -O  file1 file2  和上面相同，不过是垂直分割两半的窗口&lt;br&gt;如下 图所示：&lt;/p&gt;
&lt;p&gt;如果画面分割后不足以容纳下所有窗口，那么第一个文件会占用大部分窗口，余下的窗口则载入缓冲区，暂时不能看到，但仍可以取用。&lt;/p&gt;
&lt;p&gt;-o后面加一个数字n，是预分配窗口的形式打开：&lt;br&gt;$ vim  -o5 file1  file2   将分配5个相同的窗口，有3个是闲置的&lt;/p&gt;
&lt;h2 id=&quot;vim的多窗口编辑&quot;&gt;&lt;a href=&quot;#vim的多窗口编辑&quot; class=&quot;headerlink&quot; title=&quot;vim的多窗口编辑&quot;&gt;&lt;/a&gt;vim的多窗口编辑&lt;/h2&gt;&lt;p&gt;：split    新建一个窗口，将当前窗口分割成两半，他们显示的是相同缓冲区的内容（同一个文件）。这样就可以在两个窗口中浏览相同的文件了。&lt;/p&gt;
&lt;p&gt;：vsplit   创建全新的垂直分割的窗口，同样是显示和当前窗口同一个文件内容。效果如下：&lt;/p&gt;
&lt;p&gt;当多个窗口编辑同一个文件时，在任意一个窗口进行编辑（例如删除一行），那么所有相同文件的窗口上都会同时反应效果，因为他们共享同一个文件缓冲区。&lt;/p&gt;
&lt;p&gt;如果想编辑或浏览另一个文件，而又不想失去在当前文件中的编辑位置，就用新文件的参数传给：split命令&lt;br&gt;：split  otherfile&lt;/p&gt;
&lt;p&gt;分割窗口的选项&lt;/p&gt;
&lt;p&gt;：[n] split(vsplit)  [++opt]  [+cmd]  [file]&lt;/p&gt;
&lt;p&gt;命令中：&lt;br&gt;n   为vim指定在新窗口中显示的行数，且新窗口的大小刚好容纳该行数，新窗口位于画面顶端&lt;br&gt;opt  传递vim选项信息给新的窗口会话（请注意，它的前面必须加上两个加号）&lt;br&gt;cmd 传入欲在新窗口中执行的命令（请注意，它的前面必须加上一个加号）&lt;br&gt;file  指定在新窗口中编辑的文件&lt;/p&gt;
&lt;p&gt;：sview  filename  以只读的方式水平分割打开一个新窗口&lt;br&gt;：sfind  [++opt]  [+cmd]  [file]  和split的运作方式相似，但在path中寻找filename，如果vim未找到文件则不显示&lt;/p&gt;
&lt;h2 id=&quot;在窗口间游走&quot;&gt;&lt;a href=&quot;#在窗口间游走&quot; class=&quot;headerlink&quot; title=&quot;在窗口间游走&quot;&gt;&lt;/a&gt;在窗口间游走&lt;/h2&gt;&lt;p&gt;在gvim或vim中，在窗口中移动其实非常简单，因为gvim已默认支持鼠标点击来换编辑窗口，而vim中，则可以打开mouse选项，&lt;br&gt;：set  mouse = a   为命令、输入、导航都激活鼠标的使用&lt;/p&gt;
&lt;p&gt;我们知道vim的特色就是可以脱离鼠标而工作，所以可以使用vim提供的全套导航命令，在会话中快速而准确的移动编辑窗口。&lt;/p&gt;
&lt;p&gt;按住Ctrl + W，然后再加上h, j, k, l，分别表示向左、下、上、右移动窗口&lt;br&gt;Ctrl + w + h：向左移动窗口&lt;br&gt;Ctrl + w + j： 向下移动窗口&lt;br&gt;Ctrl + w + j： 向上移动窗口&lt;br&gt;Ctrl + w + l： 向右移动窗口&lt;/p&gt;
&lt;p&gt;Ctrl + w + w：这个命令会在所有窗口中循环移动&lt;br&gt;Ctrl + w + t：移动到最左上角的窗口&lt;br&gt;Ctrl + w + b：移动到最右下角的窗口&lt;br&gt;Ctrl + w + p：移动到前一个访问的窗口&lt;/p&gt;
&lt;h2 id=&quot;移动窗口&quot;&gt;&lt;a href=&quot;#移动窗口&quot; class=&quot;headerlink&quot; title=&quot;移动窗口&quot;&gt;&lt;/a&gt;移动窗口&lt;/h2&gt;&lt;p&gt;vim中有两种移动窗口方式，一种只是简单地在屏幕上切换窗口，尺寸维持不变；另一种则是改变窗口的实际布局，还会调整尺寸，以填充它移动的位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;移动窗口本身（轮换或交换）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ctrl + w + r：向右或向下方交换窗口，而Ctrl + w + R则和它方向相反。&lt;/p&gt;
&lt;p&gt;光标会随着窗口而移动&lt;/p&gt;
&lt;p&gt;Ctrl + w + x：交换同列或同行的窗口的位置。vim默认交换当前窗口的与它下一个窗口的位置，如果下方没有窗口，则试着与上一个窗口交换位置。亦可在此命令前加上数量，与制定的窗口交换位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;移动窗口并改变其布局&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：下面的第三个字母都是大写，按玩Ctrl + w之后，按shif + 相应的字母。后面用^代替Ctrl&lt;br&gt;Ctrl + w + K ：移动当前窗口至屏幕顶端，并占用全部宽度&lt;br&gt;^WJ： 移动窗口至屏幕底端，并占用全部宽度&lt;br&gt;^WH：移动窗口至屏幕左端，并占用全部高度&lt;br&gt;^WL：移动窗口至屏幕右端，并占用全部高度&lt;/p&gt;
&lt;p&gt;^WT ：移动窗口至屏新的现有分页&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调整窗口尺寸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;改变当前窗口的尺寸，同时当然也会影响到其他窗口。&lt;br&gt;在gvim和vim中，可以用鼠标点击窗口的顶部白色条并窗口直接调整尺寸。&lt;/p&gt;
&lt;p&gt;也可以直接用命令，调整尺寸命令也是以Ctrl + W开头：&lt;br&gt;Ctrl + W + =  ：让所有窗口调整至相同尺寸（平均划分）&lt;br&gt;Ctrl + W + -：将当前窗口的高度减少一行，也可在ex命令中，：resize -4明确指定减少的尺寸&lt;br&gt;Ctrl + W + +：将当前窗口的高度增加一行。同样在ex命令中，：resize +n 明确指定增加尺寸&lt;/p&gt;
&lt;p&gt;Ctrl + W + &amp;lt; ：将当前窗口的宽度减少&lt;br&gt;Ctrl + W + &amp;gt; ：将当前窗口的宽度增加&lt;/p&gt;
&lt;p&gt;Ctrl + W + |：将当前窗口的宽度调到最大，也可他哦你通过ex命令：vertical resize n明确指定改变宽度&lt;/p&gt;
&lt;h2 id=&quot;分页编辑&quot;&gt;&lt;a href=&quot;#分页编辑&quot; class=&quot;headerlink&quot; title=&quot;分页编辑&quot;&gt;&lt;/a&gt;分页编辑&lt;/h2&gt;&lt;p&gt;除了使多窗口编辑外，vim还允许创建多个分页（tab），每个分页各有独自的行为，类似于浏览器firefox或chrome的分页浏览功能。&lt;/p&gt;
&lt;p&gt;我们可以在vim或gvim中使用分页，但在gvim会更好用。&lt;br&gt;最终要的命令&lt;br&gt;：tabnew filename  打开新分页并编辑新文件（可选的）。如果未指定文件，则只打开新分页，并附上空的缓冲区。&lt;br&gt;：tabclose  关闭当前分页&lt;br&gt; ：tabonly  关闭其他所有的分页。如果其他分页中有修改过的文件，则不会移除该分页，除非设置了autowrite选项。此时，所有修改过的文件都在分页关闭前写入磁盘。&lt;/p&gt;
&lt;p&gt;游走分页&lt;/p&gt;
&lt;p&gt;可以直接点鼠标来移动到另一个分页，也可以用命令&lt;br&gt;Ctrl + PageDown：移动到下一个分页&lt;br&gt;Ctrl + PageUp：移动到上一个分页&lt;/p&gt;
&lt;h2 id=&quot;关闭与离开窗口&quot;&gt;&lt;a href=&quot;#关闭与离开窗口&quot; class=&quot;headerlink&quot; title=&quot;关闭与离开窗口&quot;&gt;&lt;/a&gt;关闭与离开窗口&lt;/h2&gt;&lt;p&gt;有4种关闭窗口的方式，分别是：离开（quit）、关闭（close）、隐藏（hide）、关闭其他窗口&lt;/p&gt;
&lt;p&gt;^代表Ctrl键&lt;br&gt;^Wq，离开当前窗口&lt;br&gt;^Wc，关闭当前的窗口&lt;br&gt;^Wo，关闭当前窗口以外的所有窗口&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令历史&quot;&gt;&lt;a href=&quot;#命令历史&quot; class=&quot;headerlink&quot; title=&quot;命令历史&quot;&gt;&lt;/a&gt;命令历史&lt;/h2&gt;&lt;p&gt;以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。&lt;/p&gt;
&lt;h2 id=&quot;启动vim&quot;&gt;&lt;a href=&quot;#启动vim&quot; class=&quot;headerlink&quot; title=&quot;启动vim&quot;&gt;&lt;/a&gt;启动vim&lt;/h2&gt;&lt;p&gt;在命令行窗口中输入以下命令即可&lt;/p&gt;
&lt;p&gt;vim 直接启动vim&lt;/p&gt;
&lt;p&gt;vim filename 打开vim并创建名为filename的文件&lt;/p&gt;
&lt;h2 id=&quot;文件命令&quot;&gt;&lt;a href=&quot;#文件命令&quot; class=&quot;headerlink&quot; title=&quot;文件命令&quot;&gt;&lt;/a&gt;文件命令&lt;/h2&gt;&lt;p&gt;打开单个文件&lt;/p&gt;
&lt;p&gt;vim file&lt;/p&gt;
&lt;p&gt;同时打开多个文件&lt;/p&gt;
&lt;p&gt;vim file1 file2 file3 …&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>时间序列完全教程（R）</title>
    <link href="http://yoursite.com/2016/03/29/test/"/>
    <id>http://yoursite.com/2016/03/29/test/</id>
    <published>2016-03-29T08:07:51.000Z</published>
    <updated>2016-03-29T13:17:22.602Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在商业应用中，时间是最重要的因素，能够提升成功率。然而绝大多数公司很难跟上时间的脚步。但是随着技术的发展，出现了很多有效的方法，能够让我们预测未来。不要担心，本文并不会讨论时间机器，讨论的都是很实用的东西。&lt;br&gt;本文将要讨论关于预测的方法。有一种预测是跟时间相关的，而这种处理与时间相关数据的方法叫做&lt;strong&gt;时间序列模型&lt;/strong&gt;。这个模型能够在与时间相关的数据中，寻到一些隐藏的信息来辅助决策。&lt;br&gt;当我们处理时序序列数据的时候，时间序列模型是非常有用的模型。大多数公司都是基于时间序列数据来分析第二年的销售量，网站流量，竞争地位和更多的东西。然而很多人并不了解的时间序列分析这个领域。&lt;br&gt;所以，如果你不了解时间序列模型。这篇文章将会想你介绍时间序列模型的处理步骤以及它的相关技术。&lt;br&gt;本文包含的内容如下所示：&lt;br&gt;目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、时间序列模型介绍&lt;/li&gt;
&lt;li&gt;2、使用R语言来探索时间序列数据&lt;/li&gt;
&lt;li&gt;3、介绍ARMA时间序列模型&lt;/li&gt;
&lt;li&gt;4、ARIMA时间序列模型的框架与应用&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;让我们开始吧&lt;/p&gt;
&lt;h1 id=&quot;1、时间序列模型介绍&quot;&gt;&lt;a href=&quot;#1、时间序列模型介绍&quot; class=&quot;headerlink&quot; title=&quot;1、时间序列模型介绍&quot;&gt;&lt;/a&gt;1、时间序列模型介绍&lt;/h1&gt;&lt;p&gt;Let’s begin。本节包括平稳序列，随机游走,Rho系数,Dickey Fuller检验平稳性。如果这些知识你都不知道，不用担心-接下来这些概念本节都会进行详细的介绍，我敢打赌你很喜欢我的介绍的。&lt;/p&gt;
&lt;h2 id=&quot;平稳序列&quot;&gt;&lt;a href=&quot;#平稳序列&quot; class=&quot;headerlink&quot; title=&quot;平稳序列&quot;&gt;&lt;/a&gt;平稳序列&lt;/h2&gt;&lt;p&gt;判断一个序列是不是平稳序列有三个评判标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;均值 ，是与时间t 无关的常数。下图（左）满足平稳序列的条件，下图（右）很明显具有时间依赖。&lt;br&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/Mean_nonstationary.png?w=586&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方差 ，是与时间t 无关的常数。这个特性叫做方差齐性。下图显示了什么是方差对齐，什么不是方差对齐。（注意右手边途中的不同分布。）&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/Var_nonstationary.png?w=577&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协方差 ，只与时期间隔k有关，与时间t 无关的常数。如下图（右），可以注意到随着时间的增加，曲线变得越来越近。因此红色序列的协方差并不是恒定的。&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/Cov_nonstationary.png?w=566&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;我们为什么要关心平稳时间序列呢？&quot;&gt;&lt;a href=&quot;#我们为什么要关心平稳时间序列呢？&quot; class=&quot;headerlink&quot; title=&quot;我们为什么要关心平稳时间序列呢？&quot;&gt;&lt;/a&gt;我们为什么要关心平稳时间序列呢？&lt;/h3&gt;&lt;p&gt;除非你的时间序列是平稳的，否则不能建立一个时间序列模型。在很多案例中时间平稳条件常常是不满足的，所以首先要做的就是让时间序列变得平稳，然后尝试使用随机模型预测这个时间序列。有很多方法来平稳数据，比如消除长期趋势，差分化。&lt;/p&gt;
&lt;h2 id=&quot;随机游走&quot;&gt;&lt;a href=&quot;#随机游走&quot; class=&quot;headerlink&quot; title=&quot;随机游走&quot;&gt;&lt;/a&gt;随机游走&lt;/h2&gt;&lt;p&gt;这是时间序列最基本的概念。你可能很了解这个概念。但是，很多工业界的人仍然将随机游走看做一个平稳序列。在这一节中，我会使用一些数学工具，帮助理解这个概念。我们先看一个例子&lt;br&gt;&lt;strong&gt;例子&lt;/strong&gt;：想想一个女孩随机的在想象一个女孩在一个巨型棋盘上面随意移动。这里，下一个位置只取决于上一个位置。&lt;br&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/RandomWalk.gif?resize=520%2C224&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt; (来源: &lt;a href=&quot;http://scifun.chem.wisc.edu/WOP/RandomWalk.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://scifun.chem.wisc.edu/WOP/RandomWalk.html&lt;/a&gt; )&lt;/center&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在想象一下，你在一个封闭的房间里，不能看见这个女孩。但是你想要预测不同时刻这个女孩的位置。怎么才能预测的准一点？当然随着时间的推移你预测的越来越不准。在t=0时刻，你肯定知道这个女孩在哪里。下一个时刻女孩移动到附件8块方格中的一块，这个时候，你预测到的可能性已经降为1/8。继续往下继续预测，现在我们将这个序列公式化：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$X(t) = X(t-1) + Er(t)$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里的$Er_t$代表这这个时间点随机干扰项。这个就是女孩在每一个时间点带来的随机性。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在我们递归所有x时间点，最后我们将得到下面的等式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$X(t) = X(0) + Sum(Er(1),Er(2),Er(3).....Er(t))$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在，让我们尝试验证一下随机游走的平稳性假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否均值为常数？&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;E[X(t)] = E[X(0)] + Sum(E[Er(1)],E[Er(2)],E[Er(3)].....E[Er(t)])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们知道由于随机过程的随机干扰项的期望值为0.到目前为止：E[X(t)] = E[X(0)] = 常数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否方差为常数？&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Var[X(t)] = Var[X(0)] + Sum(Var[Er(1)],Var[Er(2)],Var[Er(3)].....Var[Er(t)])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Var[X(t)] = t * Var(Error) = 时间相关&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，我们推断，随机游走不是一个平稳的过程，因为它有一个时变方差。此外，如果我们检查的协方差，我们看到协方差依赖于时间。&lt;/p&gt;
&lt;h3 id=&quot;我们看一个更有趣的东西&quot;&gt;&lt;a href=&quot;#我们看一个更有趣的东西&quot; class=&quot;headerlink&quot; title=&quot;我们看一个更有趣的东西&quot;&gt;&lt;/a&gt;我们看一个更有趣的东西&lt;/h3&gt;&lt;p&gt;我们已经知道一个随机游走是一个非平稳的过程。让我们在方程中引入一个新的系数，看看我们是否能制定一个检查平稳性的公式。&lt;br&gt;&lt;strong&gt;Rho系数&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;X(t) = Rho * X(t-1) + Er(t)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在，我们将改变Rho看看我们可不可以让这个序列变的平稳。这里我们只是看，并不进行平稳性检验。&lt;br&gt;让我们从一个Rho=0的完全平稳序列开始。这里是时间序列的图：&lt;br&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/rho0.png?w=939&quot; alt=&quot;&quot;&gt;&lt;br&gt;将Rho的值增加到0.5，我们将会得到如下图：&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/rho5.png?w=941&quot; alt=&quot;&quot;&gt;&lt;br&gt;你可能会注意到，我们的周期变长了，但基本上似乎没有一个严重的违反平稳性假设。现在让我们采取更极端的情况下ρ= 0.9&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/rho9.png?w=941&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们仍然看到，在一定的时间间隔后，从极端值返回到零。这一系列也不违反非平稳性明显。现在，让我们用ρ= 1随机游走看看&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/rho1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这显然是违反固定条件。是什么使rho= 1变得这么特殊的呢？，这种情况并不满足平稳性测试？我们来找找这个数学的原因&lt;br&gt;公式X(t) = Rho * X(t-1) + Er(t)的期望为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;E[X(t)] = Rho *E[ X(t-1)]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个公式很有意义。下一个X(或者时间点t)被拉到Rho*上一个x的值。&lt;br&gt;例如，如果x（t–1）= 1，E[X（T）] = 0.5（Rho= 0.5）。现在，如果从零移动到任何方向下一步想要期望为0。唯一可以让期望变得更大的就是错误率。当Rho变成1呢？下一步没有任何可能下降。&lt;/p&gt;
&lt;h2 id=&quot;Dickey-Fuller-Test平稳性&quot;&gt;&lt;a href=&quot;#Dickey-Fuller-Test平稳性&quot; class=&quot;headerlink&quot; title=&quot;Dickey Fuller Test平稳性&quot;&gt;&lt;/a&gt;Dickey Fuller Test平稳性&lt;/h2&gt;&lt;p&gt;这里学习的最后一个知识点是Dickey Fuller检验。。在统计学里，Dickey-Fuller检验是测试一个自回归模型是否存在单位根。这里根据上面Rho系数有一个调整，将公式转换为Dickey-Fuller检验&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;X(t) = Rho * X(t-1) + Er(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt;  X(t) - X(t-1) = (Rho - 1) X(t - 1) + Er(t)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们要测试如果Rho–1=0是否差异显著。如果零假设不成立，我们将得到一个平稳时间序列。&lt;br&gt;平稳性测试和将一个序列转换为平稳性序列是时间序列模型中最重要的部分。因此需要记住本节提到的所有概念方便进入下一节。&lt;br&gt;接下来就看看时间序列的例子。&lt;/p&gt;
&lt;h1 id=&quot;2、使用R探索时间序列&quot;&gt;&lt;a href=&quot;#2、使用R探索时间序列&quot; class=&quot;headerlink&quot; title=&quot;2、使用R探索时间序列&quot;&gt;&lt;/a&gt;2、使用R探索时间序列&lt;/h1&gt;&lt;p&gt;本节我们将学习如何使用R处理时间序列。这里我们只是探索时间序列，并不会建立时间序列模型。&lt;br&gt;本节使用的数据是R中的内置数据：AirPassengers。这个数据集是1949-1960年每个月国际航空的乘客数量的数据。&lt;/p&gt;
&lt;h2 id=&quot;在入数据集&quot;&gt;&lt;a href=&quot;#在入数据集&quot; class=&quot;headerlink&quot; title=&quot;在入数据集&quot;&gt;&lt;/a&gt;在入数据集&lt;/h2&gt;&lt;p&gt;下面的代码将帮助我们在入数据集并且能够看到一些少量的数据集。&lt;br&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; data(AirPassengers)&lt;span class=&quot;comment&quot;&gt;#在入数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; class(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;string&quot;&gt;&quot;ts&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看AirPassengers数据类型，这里是时间序列数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; start(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;1949&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这个是Airpassengers数据开始的时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; end(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;1960&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这个是Airpassengers数据结束的时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; frequency(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#时间序列的频率是一年12个月&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; summary(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Min. 1st Qu. Median Mean 3rd Qu. Max.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;number&quot;&gt;104.0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;180.0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;265.5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;280.3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;360.5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;622.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;矩阵中详细数据&quot;&gt;&lt;a href=&quot;#矩阵中详细数据&quot; class=&quot;headerlink&quot; title=&quot;矩阵中详细数据&quot;&gt;&lt;/a&gt;矩阵中详细数据&lt;/h2&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#The number of passengers are distributed across the spectrum&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; plot(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#绘制出时间序列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;abline(reg=lm(AirPassengers~time(AirPassengers)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 拟合一条直线&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/plot_AP1.png?resize=850%2C367&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; cycle(AirPassengers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Jan Feb Mar Apr May Jun Jul Aug Sep Oct  Nov Dec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1949&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1950&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1951&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1952&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1953&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1954&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1955&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1956&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1957&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1958&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1959&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1960&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 打印每年的周期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; plot(aggregate(AirPassengers,FUN=mean))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#绘制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; boxplot(AirPassengers~cycle(AirPassengers))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#绘制盒图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/plot_aggregate.png?resize=850%2C342&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/plot_month_wise.png?resize=850%2C333&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;重要推论&quot;&gt;&lt;a href=&quot;#重要推论&quot; class=&quot;headerlink&quot; title=&quot;重要推论&quot;&gt;&lt;/a&gt;重要推论&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;每年的趋势显示旅客的数量每年都在增加&lt;/li&gt;
&lt;li&gt;七八月的均值和方差比其他月份要高很多&lt;/li&gt;
&lt;li&gt;每个月的平均值并不相同，但是方差差异很小。因此，可以看出具有很强的周期性。，一个周期为12个月或更少。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看数据，试探数据是建立时间序列模型最重要的一部-如果没有这一步，你将不知道这个序列是不是平稳序列。就像这个例子一样，我们已经知道了很多关于这个模型的很多细节。&lt;br&gt;接下来我们会建立一些时间序列模型以及这些模型的特征，也会最一些预测。&lt;/p&gt;
&lt;h1 id=&quot;3、ARMA时间序列模型&quot;&gt;&lt;a href=&quot;#3、ARMA时间序列模型&quot; class=&quot;headerlink&quot; title=&quot;3、ARMA时间序列模型&quot;&gt;&lt;/a&gt;3、ARMA时间序列模型&lt;/h1&gt;&lt;p&gt;ARMA也叫自回归移动平均混合模型。ARMA模型经常在时间序列中使用。在ARMA模型中，AR代表自回归，MA代表移动平均。如果这些术语听起来很复杂，不用担心-下面将会用几分钟的时间简单介绍这些概念。&lt;br&gt;我们现在就会领略这些模型的特点。在开始之前，你首先要记住，AR或者MA并不是应用在非平稳序列上的。&lt;br&gt;在实际应用中可能会得到一个非平稳序列，你首先要做的就是将这个序列变成平稳序列（通过差分化/转换），然后选择可以使用的时间序列模型。&lt;br&gt;首先，本文将介绍分开介绍两个模型（AR&amp;amp;MA）。接下来我们看一看这些模型的特点。&lt;/p&gt;
&lt;h2 id=&quot;自回归时间序列模型&quot;&gt;&lt;a href=&quot;#自回归时间序列模型&quot; class=&quot;headerlink&quot; title=&quot;自回归时间序列模型&quot;&gt;&lt;/a&gt;自回归时间序列模型&lt;/h2&gt;&lt;p&gt;让我们从下面的例子理解AR模型：&lt;br&gt;现状一个国家的GDP（x(t)）依赖与去年的GDP（x(t-1)).这个假设一个国家今年的GDP总值依赖与去年的GDP总值和今年的新开的工厂和服务。但是GDP的主要依赖与去年去年的GDP。&lt;br&gt;那么，GDP的公式为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x(t) = alpha *  x(t – 1) + error (t)       （1）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个等式就是AR公式。公式（1）表示下一个点完全依赖与前面一个点。alpha是一个系数，希望能够找到alpha最小化错误率。x(t-1)同样依赖x(t)。&lt;br&gt;例如，x(t)代表一个城市在某一天的果汁的销售量。在冬天，极少的供应商进果汁。突然有一天，温度上升了，果汁的需求猛增到1000.然而过了几天，气温有下降了。但是众所周知，人们在热天会喝果汁，这些人会有50%在冷天仍然喝果汁。在接下来的几天，这个比例降到了25%(50%的50%），然后几天后逐渐降到一个很小的数。下图解释了AR序列的惯性：&lt;br&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/AR1.png?w=488&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;移动平均时间序列模型&quot;&gt;&lt;a href=&quot;#移动平均时间序列模型&quot; class=&quot;headerlink&quot; title=&quot;移动平均时间序列模型&quot;&gt;&lt;/a&gt;移动平均时间序列模型&lt;/h2&gt;&lt;p&gt;接下来另一个关于移动平均的例子。&lt;br&gt;一个公司生成某种类型的包，这个很容易理解。作为一个竞争的市场，包的销售量从零开始增加的。所以，有一天他做了一个实验，设计并制作了不同的包，这种包并不会被随时购买。因此，假设市场上总需求是1000个这种包。在某一天，这个包的需求特别高，很快库存快要完了。这天结束了还有100个包没卖掉。我们把这个误差成为时间点误差。接下来的几天仍有几个客户购买这种包。下面通过一个简单的公式来描述这个场景：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x(t) = beta *  error(t-1) + error (t)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;尝试把这个图画出来，就是这个样子的：&lt;br&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/MA1.png?w=488&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意到MA和AR模型的不同了没？在MA模型中，噪声/冲击迅速小时。在AR模型中会受到长时间的影响。&lt;/p&gt;
&lt;h2 id=&quot;AR模型与MA模型的不同&quot;&gt;&lt;a href=&quot;#AR模型与MA模型的不同&quot; class=&quot;headerlink&quot; title=&quot;AR模型与MA模型的不同&quot;&gt;&lt;/a&gt;AR模型与MA模型的不同&lt;/h2&gt;&lt;p&gt;AR与MA模型的主要不同在于时间序列对象在不同时间点的相关性。&lt;br&gt;MA模型用过去各个时期的随机干扰或预测误差的线性组合来表达当前预测值。当n&amp;gt;某一个值时，x(t)与x(t-n)的相关性总为0.AM模型仅通过时间序列变量的自身历史观测值来反映有关因素对预测目标的影响和作用，步骤模型变量相对独立的假设条件约束，所构成的模型可以消除普通回退预测方法中由于自变量选择、多重共线性等造成的困难。即AM模型中x(t)与x(t-1)的相关性随着时间的推移变得越来越小。这个差别要好好利用起来。&lt;/p&gt;
&lt;h2 id=&quot;利用ACF和PACF绘图&quot;&gt;&lt;a href=&quot;#利用ACF和PACF绘图&quot; class=&quot;headerlink&quot; title=&quot;利用ACF和PACF绘图&quot;&gt;&lt;/a&gt;利用ACF和PACF绘图&lt;/h2&gt;&lt;p&gt;一旦我们得到一个平稳时间序列。我们必须要回答两个最重要的问题；&lt;br&gt;Q1：这个是AR或者MA过程？&lt;br&gt;Q2：我们需要利用的AR或者MA过程的顺序是什么？&lt;/p&gt;
&lt;p&gt;解决这两个问题我们要借助两个系数：&lt;br&gt;时间序列x(t)滞后k阶的样本自相关系数（ACF）和滞后k期的情况下样本偏自相关系数（PACF）。公式省略。&lt;br&gt;AR模型的ACF和PACF：&lt;br&gt;通过计算证明可知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AR的ACF为拖尾序列，即无论滞后期k取多大，ACF的计算值均与其1到p阶滞后的自相关函数有关。&lt;/li&gt;
&lt;li&gt;AR的PACF为截尾序列，即当滞后期k&amp;gt;p时PACF=0的现象。&lt;br&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/Gradual-decline.gif&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/cut-off.gif?resize=318%2C284&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图蓝线显示值与0具有显著的差异。很显然上面PACF图显示截尾于第二个滞后，这意味这是一个AR（2）过程。&lt;br&gt;MA模型的ACF和PACF：&lt;/li&gt;
&lt;li&gt;MA的ACF为截尾序列，即当滞后期k&amp;gt;p时PACF=0的现象。&lt;/li&gt;
&lt;li&gt;AR的PACF为拖尾序列，即无论滞后期k取多大，ACF的计算值均与其1到p阶滞后的自相关函数有关。&lt;br&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/cut-off.gif?resize=318%2C284&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/Gradual-decline.gif?resize=318%2C284&quot; alt=&quot;&quot;&gt;&lt;br&gt;很显然，上面ACF图截尾于第二个滞后，这以为这是一个MA（2）过程。&lt;br&gt;目前，本文已经介绍了关于使用ACF&amp;amp;PACF图识别平稳序列的类型。现在，我将介绍一个时间序列模型的整体框架。此外，还将讨论时间序列模型的实际应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4、ARIMA时间序列模型的框架与应用&quot;&gt;&lt;a href=&quot;#4、ARIMA时间序列模型的框架与应用&quot; class=&quot;headerlink&quot; title=&quot;4、ARIMA时间序列模型的框架与应用&quot;&gt;&lt;/a&gt;4、ARIMA时间序列模型的框架与应用&lt;/h1&gt;&lt;p&gt;到此，本文快速介绍了时间序列模型的基础概念、使用R探索时间序列和ARMA模型。现在我们将这些零散的东西组织起来，做一件很有趣的事情。&lt;/p&gt;
&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h2&gt;&lt;p&gt;下图的框架展示了如何一步一步的“&lt;strong&gt;做一个时间序列分析&lt;/strong&gt;”&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160322174807405&quot; alt=&quot;&quot;&gt;&lt;br&gt;前三步我们在前文意见讨论了。尽管如此，这里还是需要简单说明一下：&lt;/p&gt;
&lt;h3 id=&quot;第一步：时间序列可视化&quot;&gt;&lt;a href=&quot;#第一步：时间序列可视化&quot; class=&quot;headerlink&quot; title=&quot;第一步：时间序列可视化&quot;&gt;&lt;/a&gt;第一步：时间序列可视化&lt;/h3&gt;&lt;p&gt;在构建任何类型的时间序列模型之前，分析其趋势是至关重要的。我们感兴趣的细节包括序列中的各种趋势、周期\季节性或者随机行为。在本文的第二部分已经介绍了。&lt;/p&gt;
&lt;h3 id=&quot;第二步：序列平稳&quot;&gt;&lt;a href=&quot;#第二步：序列平稳&quot; class=&quot;headerlink&quot; title=&quot;第二步：序列平稳&quot;&gt;&lt;/a&gt;第二步：序列平稳&lt;/h3&gt;&lt;p&gt;一旦我们知道了模式、趋势、周期。我们就可以检查序列是否平稳。Dicky-Fuller是一种很流行的检验方式。在第一部分意见介绍了这种检验方式。在这里还没有结束！如果发现序列是非平稳序列怎么办？&lt;br&gt;这里有三种比较常用的技术来让一个时间序列平稳。&lt;br&gt;1 &lt;strong&gt;消除趋势&lt;/strong&gt;：这里我们简单的删除时间序列中的趋势成分。例如，我的时间序列的方程是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x(t) = (mean + trend * t) + error&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里我简单的删除上述公式中的trend&lt;em&gt;t部分，建立x(t)=mean+error模型&lt;br&gt;2 &lt;em&gt;*差分&lt;/em&gt;&lt;/em&gt;：这个技术常常用来消除非平稳性。这里我们是对序列的差分的结果建立模型而不是真正的序列。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x(t) – x(t-1) = ARMA (p ,  q)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个差分也是ARIMA的部分。现在我们有3个参数了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;p:AR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d:I&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;q:MA&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3 &lt;strong&gt;季节性&lt;/strong&gt;：季节性直接被纳入ARIMA模型中。下面的应用部分我们再讨论这个。&lt;/p&gt;
&lt;h3 id=&quot;第三步：找到最优参数&quot;&gt;&lt;a href=&quot;#第三步：找到最优参数&quot; class=&quot;headerlink&quot; title=&quot;第三步：找到最优参数&quot;&gt;&lt;/a&gt;第三步：找到最优参数&lt;/h3&gt;&lt;p&gt;参数p,q可以使用ACF和PACF图发现。除了这种方法，如果相关系数ACF和偏相关系数PACF逐渐减小，这表明我们需要进行时间序列平稳并引入d参数。&lt;/p&gt;
&lt;h3 id=&quot;第四步：简历ARIMA模型&quot;&gt;&lt;a href=&quot;#第四步：简历ARIMA模型&quot; class=&quot;headerlink&quot; title=&quot;第四步：简历ARIMA模型&quot;&gt;&lt;/a&gt;第四步：简历ARIMA模型&lt;/h3&gt;&lt;p&gt;找到了这些参数，我们现在就可以尝试简历ARIMA模型了。从上一步找到的值可能只是一个近似估计的值，我们需要探索更多(p,d,q）的组合。最小的BIC和AIC的模型参数才是我们要的。我们也可以尝试一些季节性成分。在这里，在ACF/PACF图中我们会注意到一些季节性的东西。&lt;/p&gt;
&lt;h3 id=&quot;第五步：预测&quot;&gt;&lt;a href=&quot;#第五步：预测&quot; class=&quot;headerlink&quot; title=&quot;第五步：预测&quot;&gt;&lt;/a&gt;第五步：预测&lt;/h3&gt;&lt;p&gt;到这步，我们就有了ARIMA模型，我们现在就可以做预测了。我们也可以将这种趋势可视化，进行交叉验证。&lt;/p&gt;
&lt;h2 id=&quot;时间序列模型的应用。&quot;&gt;&lt;a href=&quot;#时间序列模型的应用。&quot; class=&quot;headerlink&quot; title=&quot;时间序列模型的应用。&quot;&gt;&lt;/a&gt;时间序列模型的应用。&lt;/h2&gt;&lt;p&gt;这里我们用前面的例子。使用这个时间序列做预测。我们建议你在进行下一步之前，先观察这个数据。&lt;/p&gt;
&lt;h3 id=&quot;我们从哪里开始呢？&quot;&gt;&lt;a href=&quot;#我们从哪里开始呢？&quot; class=&quot;headerlink&quot; title=&quot;我们从哪里开始呢？&quot;&gt;&lt;/a&gt;我们从哪里开始呢？&lt;/h3&gt;&lt;p&gt;下图是这些年的乘客数的图。在往下看之前，观察这个图。&lt;br&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/plot_AP.png?resize=1024%2C467&quot; alt=&quot;&quot;&gt;&lt;br&gt;这里是我的观察：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;乘客有着逐年增加的趋势。&lt;/li&gt;
&lt;li&gt;这看起来有季节性，每一个周期不超过12个月。&lt;/li&gt;
&lt;li&gt;数据的方差逐年增加。&lt;br&gt;在我们进行平稳性测试之前我们需要解决两个问题。第一，我们需要消除方差不齐。这里我们对这个序列做求对数。第二我们需要解决序列的趋势性。我们通过对时序序列做差分。现在，我们来检验最终序列的平稳性。&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adf.test(diff(log(AirPassengers)), alternative=&lt;span class=&quot;string&quot;&gt;&quot;stationary&quot;&lt;/span&gt;, k=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这里可能会显示没有这个函数，需要安装一下.install.packages(&quot;tseries&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#加在这个包,library(tseries&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	data: diff(log(AirPassengers))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	Dickey-Fuller = -&lt;span class=&quot;number&quot;&gt;9.6003&lt;/span&gt;, Lag order = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	p-value = &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	alternative hypothesis: stationary&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以看出这个序列是足够平稳做任何时间序列模型。&lt;br&gt;下一步就是找到ARIMA模型的正确的参数。我们意见知道’d‘是1，因此我们需要做1差分让序列平稳。这里我们绘制出相关图。下面就是这个序列的ACF图。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# ACF图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;acf(log(AirPassengers))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/ACF_original.png?w=870&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;从上述表格可以看出什么？&quot;&gt;&lt;a href=&quot;#从上述表格可以看出什么？&quot; class=&quot;headerlink&quot; title=&quot;从上述表格可以看出什么？&quot;&gt;&lt;/a&gt;从上述表格可以看出什么？&lt;/h3&gt;&lt;p&gt;很显然ACF下降的十分的慢，这就意味着乘客的数量并不是平稳的。我们在前面已经讨论了，我们现状准备在序列去对数后的差分上做回归，而不是直接在序列去对数后的数据熵差分。让我们看一下差分后的ACF和PACF曲线吧。&lt;br&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; acf(diff(log(AirPassengers)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; pacf(diff(log(AirPassengers)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/ACF-diff.png?w=872&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://i1.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/PACF-diff.png?w=888&quot; alt=&quot;&quot;&gt;&lt;br&gt;显然ACF截止与第一个滞后，因此我们知道p的值应该是0.而q的值应该是1或者2.几次迭代以后，我们发现(p,d,q)取(0,1,1)时，AIC和BIC最小。&lt;br&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; fit &amp;lt;- arima(log(AirPassengers), c(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),seasonal = list(order = c(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), period = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; pred &amp;lt;- predict(fit, n.ahead = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ts.plot(AirPassengers,&lt;span class=&quot;number&quot;&gt;2.718&lt;/span&gt;^pred$pred, log = &lt;span class=&quot;string&quot;&gt;&quot;y&quot;&lt;/span&gt;, lty = c(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i0.wp.com/www.analyticsvidhya.com/wp-content/uploads/2015/02/predictions.png?w=869&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h1&gt;&lt;p&gt;我参加一个时间序列的比赛，对时间序列的了解止步与马尔科夫模型。而且马尔科夫模型并不适合解纯时间序列的问题，所以就上网搜索一下时间序列的相关知识。很偶然的发现了这篇文章，文章的逻辑清晰，表达清楚，文字浅显易懂，值得我学习，所以我就尝试翻译了这篇文章。中间很多东西并不是很了解，如有错误的地方，欢迎指正。&lt;/p&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Complete Tutorial on Time Series Modeling in R&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://wenku.baidu.com/link?url=b34APzBjz-cGLoxsG4-nvbwKy7FLgPk5n4nzC9w-pWQP7pc4MycpyQZil4Oe5I0285cMGz1WX79Q4aExF8Ft-n0okdqgNs4DhkRsSIWZ2zq&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;时间序列&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;wwwd.docin.com/p-682510490.html&quot;&gt;第八章时间序列分析&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在商业应用中，时间是最重要的因素，能够提升成功率。然而绝大多数公司很难跟上时间的脚步。但是随着技术的发展，出现了很多有效的方法，能够让我们预测未来。不要担心，本文并不会讨论时间机器，讨论的都是很实用的东西。&lt;br&gt;本文将要讨论关于预测的方法。有一种预测是跟时间相关的，而这种处理与时间相关数据的方法叫做&lt;strong&gt;时间序列模型&lt;/strong&gt;。这个模型能够在与时间相关的数据中，寻到一些隐藏的信息来辅助决策。&lt;br&gt;当我们处理时序序列数据的时候，时间序列模型是非常有用的模型。大多数公司都是基于时间序列数据来分析第二年的销售量，网站流量，竞争地位和更多的东西。然而很多人并不了解的时间序列分析这个领域。&lt;br&gt;所以，如果你不了解时间序列模型。这篇文章将会想你介绍时间序列模型的处理步骤以及它的相关技术。&lt;br&gt;本文包含的内容如下所示：&lt;br&gt;目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、时间序列模型介绍&lt;/li&gt;
&lt;li&gt;2、使用R语言来探索时间序列数据&lt;/li&gt;
&lt;li&gt;3、介绍ARMA时间序列模型&lt;/li&gt;
&lt;li&gt;4、ARIMA时间序列模型的框架与应用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="时间序列" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
      <category term="ARMA" scheme="http://yoursite.com/tags/ARMA/"/>
    
      <category term="ARIMA" scheme="http://yoursite.com/tags/ARIMA/"/>
    
      <category term="时序分析" scheme="http://yoursite.com/tags/%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/03/29/hello-world/"/>
    <id>http://yoursite.com/2016/03/29/hello-world/</id>
    <published>2016-03-29T06:55:09.842Z</published>
    <updated>2016-03-29T06:55:09.842Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
